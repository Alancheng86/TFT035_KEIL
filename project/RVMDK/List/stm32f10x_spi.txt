; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_spi.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_spi.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_spi.crf ..\..\library\src\stm32f10x_spi.c]
                          THUMB

                          AREA ||i.I2S_Cmd||, CODE, READONLY, ALIGN=1

                  I2S_Cmd PROC
;;;360    *******************************************************************************/
;;;361    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;362    {
;;;363      /* Check the parameters */
;;;364      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;365      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;366    
;;;367      if (NewState != DISABLE)
;;;368      {
;;;369        /* Enable the selected SPI peripheral (in I2S mode) */
;;;370        SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
;;;371      }
;;;372      else
;;;373      {
;;;374        /* Disable the selected SPI peripheral (in I2S mode) */
;;;375        SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
000002  8b81              LDRH     r1,[r0,#0x1c]
000004  bf14              ITE      NE                    ;370
000006  f4416180          ORRNE    r1,r1,#0x400          ;370
00000a  f4216180          BICEQ    r1,r1,#0x400
00000e  8381              STRH     r1,[r0,#0x1c]         ;370
;;;376      }
;;;377    }
000010  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.I2S_Init||, CODE, READONLY, ALIGN=2

                  I2S_Init PROC
;;;163    ******************************************************************************/
;;;164    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;165    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;166      u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
000006  2002              MOVS     r0,#2
000008  2100              MOVS     r1,#0
;;;167      u32 tmp = 0;
;;;168      RCC_ClocksTypeDef RCC_Clocks;
;;;169       
;;;170      /* Check the I2S parameters */
;;;171      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;172      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;173      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;174      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;175      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
;;;176      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
;;;177      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;178    
;;;179    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;180    
;;;181      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;182      SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
00000a  8baa              LDRH     r2,[r5,#0x1c]
00000c  b085              SUB      sp,sp,#0x14           ;165
00000e  2601              MOVS     r6,#1                 ;166
000010  f02202bf          BIC      r2,r2,#0xbf
000014  f4226270          BIC      r2,r2,#0xf00
000018  83aa              STRH     r2,[r5,#0x1c]
;;;183      SPIx->I2SPR = 0x0002;
00001a  8428              STRH     r0,[r5,#0x20]
;;;184      
;;;185      /* Get the I2SCFGR register value */
;;;186      tmpreg = SPIx->I2SCFGR;
00001c  8baf              LDRH     r7,[r5,#0x1c]
;;;187      
;;;188      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;189      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
00001e  8922              LDRH     r2,[r4,#8]
000020  2a02              CMP      r2,#2
000022  d022              BEQ      |L2.106|
;;;190      {
;;;191        i2sodd = (u16)0;
;;;192        i2sdiv = (u16)2;   
;;;193      }
;;;194      /* If the requested audio frequency is not the default, compute the prescaler */
;;;195      else
;;;196      {
;;;197        /* Check the frame length (For the Prescaler computing) */
;;;198        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
000024  88a0              LDRH     r0,[r4,#4]
000026  2800              CMP      r0,#0
;;;199        {
;;;200          /* Packet length is 16 bits */
;;;201          packetlength = 1;
;;;202        }
;;;203        else
;;;204        {
;;;205          /* Packet length is 32 bits */
;;;206          packetlength = 2;
000028  bf18              IT       NE
00002a  2602              MOVNE    r6,#2
;;;207        }
;;;208        /* Get System Clock frequency */
;;;209        RCC_GetClocksFreq(&RCC_Clocks);
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       RCC_GetClocksFreq
;;;210        
;;;211        /* Compute the Real divider depending on the MCLK output state with a flaoting point */
;;;212        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
000032  88e0              LDRH     r0,[r4,#6]
000034  f5b07f00          CMP      r0,#0x200
000038  d02d              BEQ      |L2.150|
;;;213        {
;;;214          /* MCLK output is enabled */
;;;215          tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct->I2S_AudioFreq)) + 5);
;;;216        }
;;;217        else
;;;218        {
;;;219          /* MCLK output is disabled */
;;;220          tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct->I2S_AudioFreq)) + 5);
00003a  8921              LDRH     r1,[r4,#8]
00003c  0170              LSLS     r0,r6,#5
00003e  4341              MULS     r1,r0,r1
000040  9800              LDR      r0,[sp,#0]
000042  eb000080          ADD      r0,r0,r0,LSL #2
000046  0040              LSLS     r0,r0,#1
000048  fbb0f0f1          UDIV     r0,r0,r1
00004c  1d40              ADDS     r0,r0,#5
00004e  b280              UXTH     r0,r0
                  |L2.80|
;;;221        }
;;;222        
;;;223        /* Remove the flaoting point */
;;;224        tmp = tmp/10;  
000050  4916              LDR      r1,|L2.172|
;;;225          
;;;226        /* Check the parity of the divider */
;;;227        i2sodd = (u16)(tmp & (u16)0x0001);
;;;228       
;;;229        /* Compute the i2sdiv prescaler */
;;;230        i2sdiv = (u16)((tmp - i2sodd) / 2);
;;;231       
;;;232        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;233        i2sodd = (u16) (i2sodd << 8);
000052  f64f72ff          MOV      r2,#0xffff
000056  fba11000          UMULL    r1,r0,r1,r0           ;224
00005a  08c0              LSRS     r0,r0,#3              ;224
00005c  f0000101          AND      r1,r0,#1              ;227
000060  1a40              SUBS     r0,r0,r1              ;230
000062  f3c0004f          UBFX     r0,r0,#1,#16          ;230
000066  ea022101          AND      r1,r2,r1,LSL #8
                  |L2.106|
;;;234      }
;;;235      
;;;236      /* Test if the divider is 1 or 0 */
;;;237      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
00006a  1e82              SUBS     r2,r0,#2
00006c  2afe              CMP      r2,#0xfe
;;;238      {
;;;239        /* Set the default values */
;;;240        i2sdiv = 2;
00006e  bf24              ITT      CS
000070  2002              MOVCS    r0,#2
;;;241        i2sodd = 0;
000072  2100              MOVCS    r1,#0
;;;242      }
;;;243    
;;;244      /* Write to SPIx I2SPR register the computed value */
;;;245      SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);  
000074  88e2              LDRH     r2,[r4,#6]
000076  4308              ORRS     r0,r0,r1
000078  4310              ORRS     r0,r0,r2
00007a  8428              STRH     r0,[r5,#0x20]
;;;246     
;;;247      /* Configure the I2S with the SPI_InitStruct values */
;;;248      tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
00007c  8820              LDRH     r0,[r4,#0]
00007e  8861              LDRH     r1,[r4,#2]
000080  8962              LDRH     r2,[r4,#0xa]
000082  4308              ORRS     r0,r0,r1
000084  88a1              LDRH     r1,[r4,#4]
000086  4311              ORRS     r1,r1,r2
000088  4308              ORRS     r0,r0,r1
00008a  4338              ORRS     r0,r0,r7
00008c  f4406000          ORR      r0,r0,#0x800
;;;249                      I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
;;;250                      I2S_InitStruct->I2S_CPOL);
;;;251     
;;;252      /* Write to SPIx I2SCFGR */  
;;;253      SPIx->I2SCFGR = tmpreg;                                    
000090  83a8              STRH     r0,[r5,#0x1c]
;;;254    }
000092  b005              ADD      sp,sp,#0x14
000094  bdf0              POP      {r4-r7,pc}
                  |L2.150|
000096  9800              LDR      r0,[sp,#0]            ;215
000098  8921              LDRH     r1,[r4,#8]            ;215
00009a  eb000080          ADD      r0,r0,r0,LSL #2       ;215
00009e  0040              LSLS     r0,r0,#1              ;215
0000a0  0209              LSLS     r1,r1,#8              ;215
0000a2  fbb0f0f1          UDIV     r0,r0,r1              ;215
0000a6  1d40              ADDS     r0,r0,#5              ;215
0000a8  b280              UXTH     r0,r0                 ;215
0000aa  e7d1              B        |L2.80|
;;;255    
                          ENDP

                  |L2.172|
                          DCD      0xcccccccd

                          AREA ||i.I2S_StructInit||, CODE, READONLY, ALIGN=1

                  I2S_StructInit PROC
;;;302    *******************************************************************************/
;;;303    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
000000  2100              MOVS     r1,#0
;;;304    {
;;;305    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;306      /* Initialize the I2S_Mode member */
;;;307      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
000002  8001              STRH     r1,[r0,#0]
;;;308      
;;;309      /* Initialize the I2S_Standard member */
;;;310      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
000004  8041              STRH     r1,[r0,#2]
;;;311      
;;;312      /* Initialize the I2S_DataFormat member */
;;;313      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
000006  8081              STRH     r1,[r0,#4]
;;;314      
;;;315      /* Initialize the I2S_MCLKOutput member */
;;;316      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;317      
;;;318      /* Initialize the I2S_AudioFreq member */
;;;319      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
00000a  2202              MOVS     r2,#2
00000c  8102              STRH     r2,[r0,#8]
;;;320      
;;;321      /* Initialize the I2S_CPOL member */
;;;322      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
00000e  8141              STRH     r1,[r0,#0xa]
;;;323    }
000010  4770              BX       lr
;;;324    
                          ENDP


                          AREA ||i.SPI_BiDirectionalLineConfig||, CODE, READONLY, ALIGN=1

                  SPI_BiDirectionalLineConfig PROC
;;;682    *******************************************************************************/
;;;683    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
000000  f5b14f80          CMP      r1,#0x4000
;;;684    {
;;;685      /* Check the parameters */
;;;686      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;687      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;688    
;;;689      if (SPI_Direction == SPI_Direction_Tx)
;;;690      {
;;;691        /* Set the Tx only mode */
;;;692        SPIx->CR1 |= SPI_Direction_Tx;
;;;693      }
;;;694      else
;;;695      {
;;;696        /* Set the Rx only mode */
;;;697        SPIx->CR1 &= SPI_Direction_Rx;
000004  8801              LDRH     r1,[r0,#0]
000006  bf0c              ITE      EQ                    ;692
000008  f4414180          ORREQ    r1,r1,#0x4000         ;692
00000c  f4214180          BICNE    r1,r1,#0x4000
000010  8001              STRH     r1,[r0,#0]            ;692
;;;698      }
;;;699    }
000012  4770              BX       lr
;;;700    
                          ENDP


                          AREA ||i.SPI_CalculateCRC||, CODE, READONLY, ALIGN=1

                  SPI_CalculateCRC PROC
;;;600    *******************************************************************************/
;;;601    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;602    {
;;;603      /* Check the parameters */
;;;604      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;605      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;606    
;;;607      if (NewState != DISABLE)
;;;608      {
;;;609        /* Enable the selected SPI CRC calculation */
;;;610        SPIx->CR1 |= CR1_CRCEN_Set;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Disable the selected SPI CRC calculation */
;;;615        SPIx->CR1 &= CR1_CRCEN_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;610
000006  f4415100          ORRNE    r1,r1,#0x2000         ;610
00000a  f4215100          BICEQ    r1,r1,#0x2000
00000e  8001              STRH     r1,[r0,#0]            ;610
;;;616      }
;;;617    }
000010  4770              BX       lr
;;;618    
                          ENDP


                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=1

                  SPI_Cmd PROC
;;;333    *******************************************************************************/
;;;334    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;338      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;339    
;;;340      if (NewState != DISABLE)
;;;341      {
;;;342        /* Enable the selected SPI peripheral */
;;;343        SPIx->CR1 |= CR1_SPE_Set;
;;;344      }
;;;345      else
;;;346      {
;;;347        /* Disable the selected SPI peripheral */
;;;348        SPIx->CR1 &= CR1_SPE_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;343
000006  f0410140          ORRNE    r1,r1,#0x40           ;343
00000a  f0210140          BICEQ    r1,r1,#0x40
00000e  8001              STRH     r1,[r0,#0]            ;343
;;;349      }
;;;350    }
000010  4770              BX       lr
;;;351    
                          ENDP


                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=1

                  SPI_DataSizeConfig PROC
;;;562    *******************************************************************************/
;;;563    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
000000  8802              LDRH     r2,[r0,#0]
;;;564    {
;;;565      /* Check the parameters */
;;;566      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;567      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
;;;568    
;;;569      /* Clear DFF bit */
;;;570      SPIx->CR1 &= (u16)~SPI_DataSize_16b;
000002  f4226200          BIC      r2,r2,#0x800
000006  8002              STRH     r2,[r0,#0]
;;;571      /* Set new DFF bit value */
;;;572      SPIx->CR1 |= SPI_DataSize;
000008  8802              LDRH     r2,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  8001              STRH     r1,[r0,#0]
;;;573    }
00000e  4770              BX       lr
;;;574    
                          ENDP


                          AREA ||i.SPI_GetCRC||, CODE, READONLY, ALIGN=1

                  SPI_GetCRC PROC
;;;630    *******************************************************************************/
;;;631    u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
000000  2901              CMP      r1,#1
;;;632    {
;;;633      u16 crcreg = 0;
;;;634    
;;;635      /* Check the parameters */
;;;636      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;637      assert_param(IS_SPI_CRC(SPI_CRC));
;;;638    
;;;639      if (SPI_CRC != SPI_CRC_Rx)
;;;640      {
;;;641        /* Get the Tx CRC register */
;;;642        crcreg = SPIx->TXCRCR;
000002  bf14              ITE      NE
000004  8b00              LDRHNE   r0,[r0,#0x18]
;;;643      }
;;;644      else
;;;645      {
;;;646        /* Get the Rx CRC register */
;;;647        crcreg = SPIx->RXCRCR;
000006  8a80              LDRHEQ   r0,[r0,#0x14]
;;;648      }
;;;649    
;;;650      /* Return the selected CRC register */
;;;651      return crcreg;
;;;652    }
000008  4770              BX       lr
;;;653    
                          ENDP


                          AREA ||i.SPI_GetCRCPolynomial||, CODE, READONLY, ALIGN=1

                  SPI_GetCRCPolynomial PROC
;;;660    *******************************************************************************/
;;;661    u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;662    {
;;;663      /* Check the parameters */
;;;664      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;665      
;;;666      /* Return the CRC polynomial register */
;;;667      return SPIx->CRCPR;
;;;668    }
000002  4770              BX       lr
;;;669    
                          ENDP


                          AREA ||i.SPI_I2S_ClearFlag||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ClearFlag PROC
;;;764    *******************************************************************************/
;;;765    void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
000000  43c9              MVNS     r1,r1
;;;766    {
;;;767      /* Check the parameters */
;;;768      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;769      assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
;;;770        
;;;771        /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;772        SPIx->SR = (u16)~SPI_I2S_FLAG;
000002  8101              STRH     r1,[r0,#8]
;;;773    }
000004  4770              BX       lr
;;;774    
                          ENDP


                          AREA ||i.SPI_I2S_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ClearITPendingBit PROC
;;;848    *******************************************************************************/
;;;849    void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
000000  f001010f          AND      r1,r1,#0xf
;;;850    {
;;;851      u16 itpos = 0;
;;;852    
;;;853      /* Check the parameters */
;;;854      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;855      assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
;;;856    
;;;857      /* Get the SPI IT index */
;;;858      itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
000004  2201              MOVS     r2,#1
000006  fa02f101          LSL      r1,r2,r1
;;;859      /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
;;;860      SPIx->SR = (u16)~itpos;
00000a  43c9              MVNS     r1,r1
00000c  8101              STRH     r1,[r0,#8]
;;;861    }
00000e  4770              BX       lr
;;;862    
                          ENDP


                          AREA ||i.SPI_I2S_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_I2S_DMACmd PROC
;;;438    *******************************************************************************/
;;;439    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;440    {
;;;441      /* Check the parameters */
;;;442      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;443      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;444      assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
;;;445    
;;;446      if (NewState != DISABLE)
;;;447      {
;;;448        /* Enable the selected SPI/I2S DMA requests */
;;;449        SPIx->CR2 |= SPI_I2S_DMAReq;
;;;450      }
;;;451      else
;;;452      {
;;;453        /* Disable the selected SPI/I2S DMA requests */
;;;454        SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
000002  8882              LDRH     r2,[r0,#4]
000004  bf14              ITE      NE                    ;449
000006  4311              ORRNE    r1,r1,r2              ;449
000008  ea220101          BICEQ    r1,r2,r1
00000c  8081              STRH     r1,[r0,#4]            ;449
;;;455      }
;;;456    }
00000e  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.SPI_I2S_DeInit||, CODE, READONLY, ALIGN=1

                  SPI_I2S_DeInit PROC
;;;61     *******************************************************************************/
;;;62     void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;63     {
000002  f5a05060          SUB      r0,r0,#0x3800
000006  f1b04080          SUBS     r0,r0,#0x40000000
00000a  d011              BEQ      |L13.48|
;;;64       /* Check the parameters */
;;;65       assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;66       
;;;67       switch (*(u32*)&SPIx)
00000c  f5b06f80          CMP      r0,#0x400
000010  d019              BEQ      |L13.70|
000012  f5b04f78          CMP      r0,#0xf800
;;;68       {
;;;69         case SPI1_BASE:
;;;70           /* Enable SPI1 reset state */
;;;71           RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;72           /* Release SPI1 from reset state */
;;;73           RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
;;;74           break;
;;;75     
;;;76         case SPI2_BASE:
;;;77           /* Enable SPI2 reset state */
;;;78           RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
;;;79           /* Release SPI2 from reset state */
;;;80           RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
;;;81           break;
;;;82     
;;;83         case SPI3_BASE:
;;;84           /* Enable SPI3 reset state */
;;;85           RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
;;;86           /* Release SPI3 from reset state */
;;;87           RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
;;;88           break;
;;;89     
;;;90         default:
;;;91           break;
;;;92       }
;;;93     }
000016  bf18              IT       NE
000018  bd10              POPNE    {r4,pc}
00001a  2101              MOVS     r1,#1                 ;71
00001c  0308              LSLS     r0,r1,#12             ;71
00001e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000022  e8bd4010          POP      {r4,lr}               ;73
000026  2100              MOVS     r1,#0                 ;73
000028  f44f5080          MOV      r0,#0x1000            ;73
00002c  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L13.48|
000030  2101              MOVS     r1,#1                 ;78
000032  0388              LSLS     r0,r1,#14             ;78
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
000038  e8bd4010          POP      {r4,lr}               ;80
00003c  2100              MOVS     r1,#0                 ;80
00003e  f44f4080          MOV      r0,#0x4000            ;80
000042  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L13.70|
000046  2101              MOVS     r1,#1                 ;85
000048  03c8              LSLS     r0,r1,#15             ;85
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004e  e8bd4010          POP      {r4,lr}               ;87
000052  2100              MOVS     r1,#0                 ;87
000054  f44f4000          MOV      r0,#0x8000            ;87
000058  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;94     
                          ENDP


                          AREA ||i.SPI_I2S_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetFlagStatus PROC
;;;719    *******************************************************************************/
;;;720    FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
000000  4602              MOV      r2,r0
;;;721    {
;;;722      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;723    
;;;724      /* Check the parameters */
;;;725      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;726      assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;727    
;;;728      /* Check the status of the specified SPI/I2S flag */
;;;729      if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
000004  8912              LDRH     r2,[r2,#8]
000006  420a              TST      r2,r1
;;;730      {
;;;731        /* SPI_I2S_FLAG is set */
;;;732        bitstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;733      }
;;;734      else
;;;735      {
;;;736        /* SPI_I2S_FLAG is reset */
;;;737        bitstatus = RESET;
;;;738      }
;;;739      /* Return the SPI_I2S_FLAG status */
;;;740      return  bitstatus;
;;;741    }
00000c  4770              BX       lr
;;;742    
                          ENDP


                          AREA ||i.SPI_I2S_GetITStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetITStatus PROC
;;;791    *******************************************************************************/
;;;792    ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
000000  f001030f          AND      r3,r1,#0xf
;;;793    {
;;;794      ITStatus bitstatus = RESET;
;;;795      u16 itpos = 0, itmask = 0, enablestatus = 0;
;;;796    
;;;797      /* Check the parameters */
;;;798      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;799      assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;800    
;;;801      /* Get the SPI/I2S IT index */
;;;802      itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
000004  f04f0c01          MOV      r12,#1
000008  fa0cf303          LSL      r3,r12,r3
00000c  2200              MOVS     r2,#0                 ;794
;;;803    
;;;804      /* Get the SPI/I2S IT mask */
;;;805      itmask = SPI_I2S_IT >> 4;
00000e  0909              LSRS     r1,r1,#4
;;;806      /* Set the IT mask */
;;;807      itmask = (u16)((u16)0x01 << itmask);
000010  fa0cf101          LSL      r1,r12,r1
;;;808      /* Get the SPI_I2S_IT enable bit status */
;;;809      enablestatus = (SPIx->CR2 & itmask) ;
000014  f8b0c004          LDRH     r12,[r0,#4]
000018  b29b              UXTH     r3,r3                 ;802
00001a  b289              UXTH     r1,r1                 ;807
;;;810    
;;;811      /* Check the status of the specified SPI/I2S interrupt */
;;;812      if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
00001c  8900              LDRH     r0,[r0,#8]
00001e  ea0c0101          AND      r1,r12,r1             ;809
000022  4218              TST      r0,r3
000024  bf1c              ITT      NE
000026  2900              CMPNE    r1,#0
;;;813      {
;;;814        /* SPI_I2S_IT is set */
;;;815        bitstatus = SET;
000028  2201              MOVNE    r2,#1
;;;816      }
;;;817      else
;;;818      {
;;;819        /* SPI_I2S_IT is reset */
;;;820        bitstatus = RESET;
;;;821      }
;;;822      /* Return the SPI_I2S_IT status */
;;;823      return bitstatus;
00002a  4610              MOV      r0,r2
;;;824    }
00002c  4770              BX       lr
;;;825    
                          ENDP


                          AREA ||i.SPI_I2S_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ITConfig PROC
;;;395    *******************************************************************************/
;;;396    void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
000000  0909              LSRS     r1,r1,#4
;;;397    {
;;;398      u16 itpos = 0, itmask = 0 ;
;;;399    
;;;400      /* Check the parameters */
;;;401      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403      assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;404    
;;;405      /* Get the SPI/I2S IT index */
;;;406      itpos = SPI_I2S_IT >> 4;
;;;407      /* Set the IT mask */
;;;408      itmask = (u16)((u16)1 << itpos);
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
;;;409    
;;;410      if (NewState != DISABLE)
000008  2a00              CMP      r2,#0
;;;411      {
;;;412        /* Enable the selected SPI/I2S interrupt */
;;;413        SPIx->CR2 |= itmask;
;;;414      }
;;;415      else
;;;416      {
;;;417        /* Disable the selected SPI/I2S interrupt */
;;;418        SPIx->CR2 &= (u16)~itmask;
00000a  8882              LDRH     r2,[r0,#4]
00000c  b289              UXTH     r1,r1                 ;408
00000e  bf14              ITE      NE                    ;413
000010  4311              ORRNE    r1,r1,r2              ;413
000012  ea220101          BICEQ    r1,r2,r1
000016  8081              STRH     r1,[r0,#4]            ;413
;;;419      }
;;;420    }
000018  4770              BX       lr
;;;421    
                          ENDP


                          AREA ||i.SPI_I2S_ReceiveData||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ReceiveData PROC
;;;485    *******************************************************************************/
;;;486    u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
000000  8980              LDRH     r0,[r0,#0xc]
;;;487    {
;;;488      /* Check the parameters */
;;;489      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;490      
;;;491      /* Return the data in the DR register */
;;;492      return SPIx->DR;
;;;493    }
000002  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.SPI_I2S_SendData||, CODE, READONLY, ALIGN=1

                  SPI_I2S_SendData PROC
;;;467    *******************************************************************************/
;;;468    void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
000000  8181              STRH     r1,[r0,#0xc]
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;472      
;;;473      /* Write in the DR register the data to be sent */
;;;474      SPIx->DR = Data;
;;;475    }
000002  4770              BX       lr
;;;476    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=1

                  SPI_Init PROC
;;;105    ******************************************************************************/
;;;106    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000000  b410              PUSH     {r4}
;;;107    {
;;;108      u16 tmpreg = 0;
;;;109      
;;;110      /* check the parameters */
;;;111      assert_param(IS_SPI_ALL_PERIPH(SPIx));   
;;;112      
;;;113      /* Check the SPI parameters */
;;;114      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;115      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;116      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
;;;117      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;118      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;119      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;120      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;121      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;122      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;123    
;;;124    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;125      /* Get the SPIx CR1 value */
;;;126      tmpreg = SPIx->CR1;
000002  8802              LDRH     r2,[r0,#0]
;;;127      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;128      tmpreg &= CR1_CLEAR_Mask;
;;;129      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;130         master/salve mode, CPOL and CPHA */
;;;131      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;132      /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;133      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;134      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;135      /* Set CPOL bit according to SPI_CPOL value */
;;;136      /* Set CPHA bit according to SPI_CPHA value */
;;;137      tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
000004  880b              LDRH     r3,[r1,#0]
000006  f8b1c002          LDRH     r12,[r1,#2]
00000a  88cc              LDRH     r4,[r1,#6]
00000c  ea43030c          ORR      r3,r3,r12
000010  f8b1c004          LDRH     r12,[r1,#4]
000014  f4025241          AND      r2,r2,#0x3040         ;128
000018  ea4c0c04          ORR      r12,r12,r4
00001c  ea43030c          ORR      r3,r3,r12
000020  f8b1c008          LDRH     r12,[r1,#8]
000024  ea43030c          ORR      r3,r3,r12
000028  f8b1c00a          LDRH     r12,[r1,#0xa]
00002c  ea43030c          ORR      r3,r3,r12
000030  f8b1c00c          LDRH     r12,[r1,#0xc]
000034  ea43030c          ORR      r3,r3,r12
000038  f8b1c00e          LDRH     r12,[r1,#0xe]
00003c  ea43030c          ORR      r3,r3,r12
000040  431a              ORRS     r2,r2,r3
;;;138                      SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
;;;139                      SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
;;;140                      SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
;;;141      /* Write to SPIx CR1 */
;;;142      SPIx->CR1 = tmpreg;
000042  8002              STRH     r2,[r0,#0]
;;;143      
;;;144      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;145      SPIx->I2SCFGR &= SPI_Mode_Select;		
000044  8b82              LDRH     r2,[r0,#0x1c]
000046  f4226200          BIC      r2,r2,#0x800
00004a  8382              STRH     r2,[r0,#0x1c]
;;;146    
;;;147    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;148      /* Write to SPIx CRCPOLY */
;;;149      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
00004c  8a09              LDRH     r1,[r1,#0x10]
00004e  8201              STRH     r1,[r0,#0x10]
;;;150    }
000050  bc10              POP      {r4}
000052  4770              BX       lr
;;;151    
                          ENDP


                          AREA ||i.SPI_NSSInternalSoftwareConfig||, CODE, READONLY, ALIGN=1

                  SPI_NSSInternalSoftwareConfig PROC
;;;506    *******************************************************************************/
;;;507    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
000000  f5a1427e          SUB      r2,r1,#0xfe00
;;;508    {
;;;509      /* Check the parameters */
;;;510      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;511      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;512    
;;;513      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
;;;514      {
;;;515        /* Set NSS pin internally by software */
;;;516        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Reset NSS pin internally by software */
;;;521        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
000004  8801              LDRH     r1,[r0,#0]
000006  3aff              SUBS     r2,r2,#0xff           ;513
000008  bf14              ITE      NE                    ;516
00000a  f4417180          ORRNE    r1,r1,#0x100          ;516
00000e  f4217180          BICEQ    r1,r1,#0x100
000012  8001              STRH     r1,[r0,#0]            ;516
;;;522      }
;;;523    }
000014  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.SPI_SSOutputCmd||, CODE, READONLY, ALIGN=1

                  SPI_SSOutputCmd PROC
;;;533    *******************************************************************************/
;;;534    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;535    {
;;;536      /* Check the parameters */
;;;537      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;538      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;539    
;;;540      if (NewState != DISABLE)
;;;541      {
;;;542        /* Enable the selected SPI SS output */
;;;543        SPIx->CR2 |= CR2_SSOE_Set;
;;;544      }
;;;545      else
;;;546      {
;;;547        /* Disable the selected SPI SS output */
;;;548        SPIx->CR2 &= CR2_SSOE_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;543
000006  f0410104          ORRNE    r1,r1,#4              ;543
00000a  f0210104          BICEQ    r1,r1,#4
00000e  8081              STRH     r1,[r0,#4]            ;543
;;;549      }
;;;550    }
000010  4770              BX       lr
;;;551    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;263    *******************************************************************************/
;;;264    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;265    {
;;;266    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;267      /* Initialize the SPI_Direction member */
;;;268      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000002  8001              STRH     r1,[r0,#0]
;;;269    
;;;270      /* initialize the SPI_Mode member */
;;;271      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000004  8041              STRH     r1,[r0,#2]
;;;272    
;;;273      /* initialize the SPI_DataSize member */
;;;274      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000006  8081              STRH     r1,[r0,#4]
;;;275    
;;;276      /* Initialize the SPI_CPOL member */
;;;277      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;278    
;;;279      /* Initialize the SPI_CPHA member */
;;;280      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
00000a  8101              STRH     r1,[r0,#8]
;;;281    
;;;282      /* Initialize the SPI_NSS member */
;;;283      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
00000c  8141              STRH     r1,[r0,#0xa]
;;;284    
;;;285      /* Initialize the SPI_BaudRatePrescaler member */
;;;286      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
00000e  8181              STRH     r1,[r0,#0xc]
;;;287    
;;;288      /* Initialize the SPI_FirstBit member */
;;;289      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
000010  81c1              STRH     r1,[r0,#0xe]
;;;290    
;;;291      /* Initialize the SPI_CRCPolynomial member */
;;;292      SPI_InitStruct->SPI_CRCPolynomial = 7;
000012  2107              MOVS     r1,#7
000014  8201              STRH     r1,[r0,#0x10]
;;;293    }
000016  4770              BX       lr
;;;294    
                          ENDP


                          AREA ||i.SPI_TransmitCRC||, CODE, READONLY, ALIGN=1

                  SPI_TransmitCRC PROC
;;;581    *******************************************************************************/
;;;582    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000000  8801              LDRH     r1,[r0,#0]
;;;583    {
;;;584      /* Check the parameters */
;;;585      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;586      
;;;587      /* Enable the selected SPI CRC transmission */
;;;588      SPIx->CR1 |= CR1_CRCNext_Set;
000002  f4415180          ORR      r1,r1,#0x1000
000006  8001              STRH     r1,[r0,#0]
;;;589    }
000008  4770              BX       lr
;;;590    
                          ENDP

