; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_usart.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=517 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_usart.crf ..\..\library\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;872    *******************************************************************************/
;;;873    void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
000000  43c9              MVNS     r1,r1
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;877      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;878      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;879       
;;;880      USARTx->SR = (u16)~USART_FLAG;
000002  8001              STRH     r1,[r0,#0]
;;;881    }
000004  4770              BX       lr
;;;882    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;985    *******************************************************************************/
;;;986    void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
000000  0a09              LSRS     r1,r1,#8
;;;987    {
;;;988      u16 bitpos = 0x00, itmask = 0x00;
;;;989    
;;;990      /* Check the parameters */
;;;991      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;992      assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;993      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;994      
;;;995      bitpos = USART_IT >> 0x08;
;;;996    
;;;997      itmask = (u16)((u16)0x01 << bitpos);
000002  2201              MOVS     r2,#1
000004  fa02f101          LSL      r1,r2,r1
;;;998      USARTx->SR = (u16)~itmask;
000008  43c9              MVNS     r1,r1
00000a  8001              STRH     r1,[r0,#0]
;;;999    }
00000c  4770              BX       lr
;;;1000   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;254    *******************************************************************************/
;;;255    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;256    {
;;;257      u32 tmpreg = 0x00;
;;;258    
;;;259      /* Check the parameters */
;;;260      assert_param(IS_USART_123_PERIPH(USARTx));
;;;261      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;262      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;263      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;264      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
;;;265      
;;;266    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;267      tmpreg = USARTx->CR2;
;;;268      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;269      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000002  f24f03ff          MOV      r3,#0xf0ff
000006  401a              ANDS     r2,r2,r3
;;;270    
;;;271      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;272      /* Set CLKEN bit according to USART_Clock value */
;;;273      /* Set CPOL bit according to USART_CPOL value */
;;;274      /* Set CPHA bit according to USART_CPHA value */
;;;275      /* Set LBCL bit according to USART_LastBit value */
;;;276      tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000008  880b              LDRH     r3,[r1,#0]
00000a  f8b1c002          LDRH     r12,[r1,#2]
00000e  ea43030c          ORR      r3,r3,r12
000012  f8b1c004          LDRH     r12,[r1,#4]
000016  88c9              LDRH     r1,[r1,#6]
000018  ea4c0101          ORR      r1,r12,r1
00001c  4319              ORRS     r1,r1,r3
00001e  4311              ORRS     r1,r1,r2
;;;277                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;278    
;;;279      /* Write to USART CR2 */
;;;280      USARTx->CR2 = (u16)tmpreg;
000020  8201              STRH     r1,[r0,#0x10]
;;;281    }
000022  4770              BX       lr
;;;282    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;290    *******************************************************************************/
;;;291    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;292    {
;;;293      /* USART_ClockInitStruct members default value */
;;;294      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;295      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;296      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;297      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;298    }
00000a  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;310    *******************************************************************************/
;;;311    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;312    {
;;;313      /* Check the parameters */
;;;314      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;315      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;316      
;;;317      if (NewState != DISABLE)
;;;318      {
;;;319        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;320        USARTx->CR1 |= CR1_UE_Set;
;;;321      }
;;;322      else
;;;323      {
;;;324        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;325        USARTx->CR1 &= CR1_UE_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;320
000006  f4415100          ORRNE    r1,r1,#0x2000         ;320
00000a  f4215100          BICEQ    r1,r1,#0x2000
00000e  8181              STRH     r1,[r0,#0xc]          ;320
;;;326      }
;;;327    }
000010  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;412    *******************************************************************************/
;;;413    void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;414    {
;;;415      /* Check the parameters */
;;;416      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;417      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;418      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;419    
;;;420      if (NewState != DISABLE)
;;;421      {
;;;422        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;423           DMAR bits in the USART CR3 register */
;;;424        USARTx->CR3 |= USART_DMAReq;
;;;425      }
;;;426      else
;;;427      {
;;;428        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;429           DMAR bits in the USART CR3 register */
;;;430        USARTx->CR3 &= (u16)~USART_DMAReq;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  bf14              ITE      NE                    ;424
000006  4311              ORRNE    r1,r1,r2              ;424
000008  ea220101          BICEQ    r1,r2,r1
00000c  8281              STRH     r1,[r0,#0x14]         ;424
;;;431      }
;;;432    }
00000e  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;89     *******************************************************************************/
;;;90     void USART_DeInit(USART_TypeDef* USARTx)
000000  4a26              LDR      r2,|L7.156|
;;;91     {
000002  b510              PUSH     {r4,lr}
;;;92       /* Check the parameters */
;;;93       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;94     
;;;95       switch (*(u32*)&USARTx)
000004  1a81              SUBS     r1,r0,r2
000006  4290              CMP      r0,r2
000008  d031              BEQ      |L7.110|
00000a  dc13              BGT      |L7.52|
00000c  f5a04088          SUB      r0,r0,#0x4400
000010  f1b04080          SUBS     r0,r0,#0x40000000
000014  d020              BEQ      |L7.88|
000016  f5b06f80          CMP      r0,#0x400
;;;96       {
;;;97         case USART1_BASE:
;;;98           RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;99           RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;100          break;
;;;101    
;;;102        case USART2_BASE:
;;;103          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
;;;104          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
;;;105          break;
;;;106    
;;;107        case USART3_BASE:
;;;108          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
;;;109          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
;;;110          break;
;;;111        
;;;112        case UART4_BASE:
;;;113          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
;;;114          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
;;;115          break;
;;;116        
;;;117        case UART5_BASE:
;;;118          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
;;;119          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
;;;120          break;            
;;;121    
;;;122        default:
;;;123          break;
;;;124      }
;;;125    }
00001a  bf18              IT       NE
00001c  bd10              POPNE    {r4,pc}
00001e  2101              MOVS     r1,#1                 ;108
000020  0488              LSLS     r0,r1,#18             ;108
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
000026  e8bd4010          POP      {r4,lr}               ;109
00002a  2100              MOVS     r1,#0                 ;109
00002c  f44f2080          MOV      r0,#0x40000           ;109
000030  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.52|
000034  f5b16f80          CMP      r1,#0x400             ;95
000038  d024              BEQ      |L7.132|
00003a  f5b14f6c          CMP      r1,#0xec00            ;95
00003e  bf18              IT       NE
000040  bd10              POPNE    {r4,pc}
000042  2101              MOVS     r1,#1                 ;98
000044  0388              LSLS     r0,r1,#14             ;98
000046  f7fffffe          BL       RCC_APB2PeriphResetCmd
00004a  e8bd4010          POP      {r4,lr}               ;99
00004e  2100              MOVS     r1,#0                 ;99
000050  f44f4080          MOV      r0,#0x4000            ;99
000054  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.88|
000058  2101              MOVS     r1,#1                 ;103
00005a  0448              LSLS     r0,r1,#17             ;103
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000060  e8bd4010          POP      {r4,lr}               ;104
000064  2100              MOVS     r1,#0                 ;104
000066  f44f3000          MOV      r0,#0x20000           ;104
00006a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.110|
00006e  2101              MOVS     r1,#1                 ;113
000070  04c8              LSLS     r0,r1,#19             ;113
000072  f7fffffe          BL       RCC_APB1PeriphResetCmd
000076  e8bd4010          POP      {r4,lr}               ;114
00007a  2100              MOVS     r1,#0                 ;114
00007c  f44f2000          MOV      r0,#0x80000           ;114
000080  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.132|
000084  2101              MOVS     r1,#1                 ;118
000086  0508              LSLS     r0,r1,#20             ;118
000088  f7fffffe          BL       RCC_APB1PeriphResetCmd
00008c  e8bd4010          POP      {r4,lr}               ;119
000090  2100              MOVS     r1,#0                 ;119
000092  f44f1080          MOV      r0,#0x100000          ;119
000096  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;126    
                          ENDP

00009a  0000              DCW      0x0000
                  |L7.156|
                          DCD      0x40004c00

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;820    *******************************************************************************/
;;;821    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
000000  4602              MOV      r2,r0
;;;822    {
;;;823      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;824    
;;;825      /* Check the parameters */
;;;826      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;827      assert_param(IS_USART_FLAG(USART_FLAG));
;;;828      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;829    
;;;830      if ((USARTx->SR & USART_FLAG) != (u16)RESET)
000004  8812              LDRH     r2,[r2,#0]
000006  420a              TST      r2,r1
;;;831      {
;;;832        bitstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;833      }
;;;834      else
;;;835      {
;;;836        bitstatus = RESET;
;;;837      }
;;;838      return bitstatus;
;;;839    }
00000c  4770              BX       lr
;;;840    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;905    *******************************************************************************/
;;;906    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
000000  b410              PUSH     {r4}
;;;907    {
;;;908      u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;909      ITStatus bitstatus = RESET;
;;;910    
;;;911      /* Check the parameters */
;;;912      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;913      assert_param(IS_USART_GET_IT(USART_IT));
;;;914      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;915      
;;;916      /* Get the USART register index */
;;;917      usartreg = (((u8)USART_IT) >> 0x05);
;;;918    
;;;919      /* Get the interrupt position */
;;;920      itmask = USART_IT & IT_Mask;
000002  f001021f          AND      r2,r1,#0x1f
;;;921    
;;;922      itmask = (u32)0x01 << itmask;
000006  2401              MOVS     r4,#1
000008  f3c11342          UBFX     r3,r1,#5,#3           ;917
00000c  fa04f202          LSL      r2,r4,r2
000010  f04f0c00          MOV      r12,#0                ;909
;;;923      
;;;924      if (usartreg == 0x01) /* The IT  is in CR1 register */
000014  2b01              CMP      r3,#1
;;;925      {
;;;926        itmask &= USARTx->CR1;
000016  bf04              ITT      EQ
000018  8983              LDRHEQ   r3,[r0,#0xc]
00001a  401a              ANDEQ    r2,r2,r3
00001c  d004              BEQ      |L9.40|
;;;927      }
;;;928      else if (usartreg == 0x02) /* The IT  is in CR2 register */
00001e  2b02              CMP      r3,#2
;;;929      {
;;;930        itmask &= USARTx->CR2;
000020  bf0c              ITE      EQ
000022  8a03              LDRHEQ   r3,[r0,#0x10]
;;;931      }
;;;932      else /* The IT  is in CR3 register */
;;;933      {
;;;934        itmask &= USARTx->CR3;
000024  8a83              LDRHNE   r3,[r0,#0x14]
000026  401a              ANDS     r2,r2,r3              ;930
                  |L9.40|
;;;935      }
;;;936      
;;;937      bitpos = USART_IT >> 0x08;
000028  0a09              LSRS     r1,r1,#8
;;;938    
;;;939      bitpos = (u32)0x01 << bitpos;
;;;940      bitpos &= USARTx->SR;
00002a  8800              LDRH     r0,[r0,#0]
00002c  fa04f101          LSL      r1,r4,r1              ;939
000030  4008              ANDS     r0,r0,r1
;;;941    
;;;942      if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
000032  2a00              CMP      r2,#0
000034  bf1c              ITT      NE
000036  2800              CMPNE    r0,#0
;;;943      {
;;;944        bitstatus = SET;
000038  f04f0c01          MOVNE    r12,#1
;;;945      }
;;;946      else
;;;947      {
;;;948        bitstatus = RESET;
;;;949      }
;;;950      
;;;951      return bitstatus;  
00003c  4660              MOV      r0,r12
;;;952    }
00003e  bc10              POP      {r4}
000040  4770              BX       lr
;;;953    
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;728    *******************************************************************************/
;;;729    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;730    {
;;;731      /* Check the parameters */
;;;732      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;733      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;734      
;;;735      if (NewState != DISABLE)
;;;736      {
;;;737        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;738        USARTx->CR3 |= CR3_HDSEL_Set;
;;;739      }
;;;740      else
;;;741      {
;;;742        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;743        USARTx->CR3 &= CR3_HDSEL_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;738
000006  f0410108          ORRNE    r1,r1,#8              ;738
00000a  f0210108          BICEQ    r1,r1,#8
00000e  8281              STRH     r1,[r0,#0x14]         ;738
;;;744      }
;;;745    }
000010  4770              BX       lr
;;;746    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;353    *******************************************************************************/
;;;354    void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
000000  f3c11342          UBFX     r3,r1,#5,#3
;;;355    {
;;;356      u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;357      u32 usartxbase = 0x00;
;;;358    
;;;359      /* Check the parameters */
;;;360      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;361      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;362      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364    
;;;365      usartxbase = (*(u32*)&(USARTx));
;;;366    
;;;367      /* Get the USART register index */
;;;368      usartreg = (((u8)USART_IT) >> 0x05);
;;;369    
;;;370      /* Get the interrupt position */
;;;371      itpos = USART_IT & IT_Mask;
000004  f001011f          AND      r1,r1,#0x1f
;;;372    
;;;373      itmask = (((u32)0x01) << itpos);
000008  f04f0c01          MOV      r12,#1
00000c  fa0cf101          LSL      r1,r12,r1
;;;374        
;;;375      if (usartreg == 0x01) /* The IT is in CR1 register */
000010  2b01              CMP      r3,#1
000012  bf08              IT       EQ
000014  300c              ADDEQ    r0,r0,#0xc
000016  d003              BEQ      |L11.32|
;;;376      {
;;;377        usartxbase += 0x0C;
;;;378      }
;;;379      else if (usartreg == 0x02) /* The IT is in CR2 register */
000018  2b02              CMP      r3,#2
00001a  bf0c              ITE      EQ
00001c  3010              ADDEQ    r0,r0,#0x10
00001e  3014              ADDNE    r0,r0,#0x14
                  |L11.32|
;;;380      {
;;;381        usartxbase += 0x10;
;;;382      }
;;;383      else /* The IT is in CR3 register */
;;;384      {
;;;385        usartxbase += 0x14; 
;;;386      }
;;;387      if (NewState != DISABLE)
000020  2a00              CMP      r2,#0
;;;388      {
;;;389        *(vu32*)usartxbase  |= itmask;
;;;390      }
;;;391      else
;;;392      {
;;;393        *(vu32*)usartxbase &= ~itmask;
000022  6802              LDR      r2,[r0,#0]
000024  bf14              ITE      NE                    ;389
000026  4311              ORRNE    r1,r1,r2              ;389
000028  ea220101          BICEQ    r1,r2,r1
00002c  6001              STR      r1,[r0,#0]            ;389
;;;394      }
;;;395    }
00002e  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;139    *******************************************************************************/
;;;140    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;141    {
000002  4604              MOV      r4,r0
;;;142      u32 tmpreg = 0x00, apbclock = 0x00;
;;;143      u32 integerdivider = 0x00;
;;;144      u32 fractionaldivider = 0x00;
;;;145      u32 usartxbase = 0;
;;;146      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;147    
;;;148      /* Check the parameters */
;;;149      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;150      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;151      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;152      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;153      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;154      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;155      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;156      /* The hardware flow control is available only for USART1, USART2 and USART3 */          
;;;157      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;158      
;;;159      usartxbase = (*(u32*)&USARTx);
;;;160    
;;;161    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;162      tmpreg = USARTx->CR2;
000004  8a00              LDRH     r0,[r0,#0x10]
000006  b085              SUB      sp,sp,#0x14           ;141
000008  460d              MOV      r5,r1                 ;141
;;;163      /* Clear STOP[13:12] bits */
;;;164      tmpreg &= CR2_STOP_CLEAR_Mask;
00000a  f64c71ff          MOV      r1,#0xcfff
00000e  4008              ANDS     r0,r0,r1
;;;165    
;;;166      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;167      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;168      tmpreg |= (u32)USART_InitStruct->USART_StopBits;
000010  88e9              LDRH     r1,[r5,#6]
000012  4308              ORRS     r0,r0,r1
;;;169      
;;;170      /* Write to USART CR2 */
;;;171      USARTx->CR2 = (u16)tmpreg;
000014  8220              STRH     r0,[r4,#0x10]
;;;172    
;;;173    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;174      tmpreg = USARTx->CR1;
000016  89a0              LDRH     r0,[r4,#0xc]
;;;175      /* Clear M, PCE, PS, TE and RE bits */
;;;176      tmpreg &= CR1_CLEAR_Mask;
000018  f64e11f3          MOV      r1,#0xe9f3
00001c  4008              ANDS     r0,r0,r1
;;;177    
;;;178      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;179      /* Set the M bits according to USART_WordLength value */
;;;180      /* Set PCE and PS bits according to USART_Parity value */
;;;181      /* Set TE and RE bits according to USART_Mode value */
;;;182      tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00001e  88a9              LDRH     r1,[r5,#4]
000020  892a              LDRH     r2,[r5,#8]
000022  4311              ORRS     r1,r1,r2
000024  896a              LDRH     r2,[r5,#0xa]
000026  4310              ORRS     r0,r0,r2
000028  4308              ORRS     r0,r0,r1
;;;183                USART_InitStruct->USART_Mode;
;;;184    
;;;185      /* Write to USART CR1 */
;;;186      USARTx->CR1 = (u16)tmpreg;
00002a  81a0              STRH     r0,[r4,#0xc]
;;;187    
;;;188    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;189      tmpreg = USARTx->CR3;
00002c  8aa0              LDRH     r0,[r4,#0x14]
;;;190      /* Clear CTSE and RTSE bits */
;;;191      tmpreg &= CR3_CLEAR_Mask;
00002e  f64f41ff          MOV      r1,#0xfcff
000032  4008              ANDS     r0,r0,r1
;;;192    
;;;193      /* Configure the USART HFC -------------------------------------------------*/
;;;194      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;195      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000034  89a9              LDRH     r1,[r5,#0xc]
000036  4308              ORRS     r0,r0,r1
;;;196    
;;;197      /* Write to USART CR3 */
;;;198      USARTx->CR3 = (u16)tmpreg;
000038  82a0              STRH     r0,[r4,#0x14]
;;;199    
;;;200    /*---------------------------- USART BRR Configuration -----------------------*/
;;;201      /* Configure the USART Baud Rate -------------------------------------------*/
;;;202      RCC_GetClocksFreq(&RCC_ClocksStatus);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       RCC_GetClocksFreq
;;;203      if (usartxbase == USART1_BASE)
000040  f1a44080          SUB      r0,r4,#0x40000000
000044  f5b0309c          SUBS     r0,r0,#0x13800
;;;204      {
;;;205        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000048  bf0c              ITE      EQ
00004a  9803              LDREQ    r0,[sp,#0xc]
;;;206      }
;;;207      else
;;;208      {
;;;209        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00004c  9802              LDRNE    r0,[sp,#8]
;;;210      }
;;;211    
;;;212      /* Determine the integer part */
;;;213      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
00004e  eb0001c0          ADD      r1,r0,r0,LSL #3
000052  eb011000          ADD      r0,r1,r0,LSL #4
000056  6829              LDR      r1,[r5,#0]
;;;214      tmpreg = (integerdivider / 0x64) << 0x04;
000058  4a0c              LDR      r2,|L12.140|
00005a  0089              LSLS     r1,r1,#2              ;213
00005c  fbb0f0f1          UDIV     r0,r0,r1              ;213
000060  fba23100          UMULL    r3,r1,r2,r0
000064  0949              LSRS     r1,r1,#5
000066  0109              LSLS     r1,r1,#4
;;;215    
;;;216      /* Determine the fractional part */
;;;217      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
000068  090b              LSRS     r3,r1,#4
00006a  f06f0c18          MVN      r12,#0x18
00006e  fb03f30c          MUL      r3,r3,r12
000072  eb000083          ADD      r0,r0,r3,LSL #2
;;;218      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
000076  2332              MOVS     r3,#0x32
000078  eb031000          ADD      r0,r3,r0,LSL #4
00007c  fba22000          UMULL    r2,r0,r2,r0
000080  f3c01043          UBFX     r0,r0,#5,#4
000084  4308              ORRS     r0,r0,r1
;;;219    
;;;220      /* Write to USART BRR */
;;;221      USARTx->BRR = (u16)tmpreg;
000086  8120              STRH     r0,[r4,#8]
;;;222    }
000088  b005              ADD      sp,sp,#0x14
00008a  bd30              POP      {r4,r5,pc}
;;;223    
                          ENDP

                  |L12.140|
                          DCD      0x51eb851f

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;780    *******************************************************************************/
;;;781    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;782    {
;;;783      /* Check the parameters */
;;;784      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;785      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;786        
;;;787      if (NewState != DISABLE)
;;;788      {
;;;789        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;790        USARTx->CR3 |= CR3_IREN_Set;
;;;791      }
;;;792      else
;;;793      {
;;;794        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;795        USARTx->CR3 &= CR3_IREN_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;790
000006  f0410102          ORRNE    r1,r1,#2              ;790
00000a  f0210102          BICEQ    r1,r1,#2
00000e  8281              STRH     r1,[r0,#0x14]         ;790
;;;796      }
;;;797    }
000010  4770              BX       lr
;;;798    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;759    *******************************************************************************/
;;;760    void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;761    {
;;;762      /* Check the parameters */
;;;763      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;764      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;765        
;;;766      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f0220204          BIC      r2,r2,#4
000006  8282              STRH     r2,[r0,#0x14]
;;;767      USARTx->CR3 |= USART_IrDAMode;
000008  8a82              LDRH     r2,[r0,#0x14]
00000a  4311              ORRS     r1,r1,r2
00000c  8281              STRH     r1,[r0,#0x14]
;;;768    }
00000e  4770              BX       lr
;;;769    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;521    *******************************************************************************/
;;;522    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;526      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;527      
;;;528      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f0220220          BIC      r2,r2,#0x20
000006  8202              STRH     r2,[r0,#0x10]
;;;529      USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  4311              ORRS     r1,r1,r2
00000c  8201              STRH     r1,[r0,#0x10]
;;;530    }
00000e  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;542    *******************************************************************************/
;;;543    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;547      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;548      
;;;549      if (NewState != DISABLE)
;;;550      {
;;;551        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;552        USARTx->CR2 |= CR2_LINEN_Set;
;;;553      }
;;;554      else
;;;555      {
;;;556        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;557        USARTx->CR2 &= CR2_LINEN_Reset;
000002  8a01              LDRH     r1,[r0,#0x10]
000004  bf14              ITE      NE                    ;552
000006  f4414180          ORRNE    r1,r1,#0x4000         ;552
00000a  f4214180          BICEQ    r1,r1,#0x4000
00000e  8201              STRH     r1,[r0,#0x10]         ;552
;;;558      }
;;;559    }
000010  4770              BX       lr
;;;560    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;589    *******************************************************************************/
;;;590    u16 USART_ReceiveData(USART_TypeDef* USARTx)
000000  8880              LDRH     r0,[r0,#4]
;;;591    {
;;;592      /* Check the parameters */
;;;593      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;594      
;;;595      /* Receive Data */
;;;596      return (u16)(USARTx->DR & (u16)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;597    }
000006  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;489    *******************************************************************************/
;;;490    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;491    {
;;;492      /* Check the parameters */
;;;493      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;494      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;495      
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;499        USARTx->CR1 |= CR1_RWU_Set;
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;504        USARTx->CR1 &= CR1_RWU_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;499
000006  f0410102          ORRNE    r1,r1,#2              ;499
00000a  f0210102          BICEQ    r1,r1,#2
00000e  8181              STRH     r1,[r0,#0xc]          ;499
;;;505      }
;;;506    }
000010  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;607    *******************************************************************************/
;;;608    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;609    {
;;;610      /* Check the parameters */
;;;611      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;612      
;;;613      /* Send break characters */
;;;614      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;615    }
000008  4770              BX       lr
;;;616    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;570    *******************************************************************************/
;;;571    void USART_SendData(USART_TypeDef* USARTx, u16 Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;572    {
;;;573      /* Check the parameters */
;;;574      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;575      assert_param(IS_USART_DATA(Data)); 
;;;576        
;;;577      /* Transmit Data */
;;;578      USARTx->DR = (Data & (u16)0x01FF);
000004  8081              STRH     r1,[r0,#4]
;;;579    }
000006  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;443    *******************************************************************************/
;;;444    void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;445    {
;;;446      /* Check the parameters */
;;;447      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;448      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;449        
;;;450      /* Clear the USART address */
;;;451      USARTx->CR2 &= CR2_Address_Mask;
000002  f022020f          BIC      r2,r2,#0xf
000006  8202              STRH     r2,[r0,#0x10]
;;;452      /* Set the USART address node */
;;;453      USARTx->CR2 |= USART_Address;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  4311              ORRS     r1,r1,r2
00000c  8201              STRH     r1,[r0,#0x10]
;;;454    }
00000e  4770              BX       lr
;;;455    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;626    *******************************************************************************/
;;;627    void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;628    {    
;;;629      /* Check the parameters */
;;;630      assert_param(IS_USART_123_PERIPH(USARTx));
;;;631      
;;;632      /* Clear the USART Guard time */
;;;633      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;634      /* Set the USART guard time */
;;;635      USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8301              STRH     r1,[r0,#0x18]
;;;636    }
00000e  4770              BX       lr
;;;637    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;648    *******************************************************************************/
;;;649    void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;650    { 
;;;651      /* Check the parameters */
;;;652      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;653      
;;;654      /* Clear the USART prescaler */
;;;655      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;656      /* Set the USART prescaler */
;;;657      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  4311              ORRS     r1,r1,r2
00000c  8301              STRH     r1,[r0,#0x18]
;;;658    }
00000e  4770              BX       lr
;;;659    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;670    *******************************************************************************/
;;;671    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;672    {
;;;673      /* Check the parameters */
;;;674      assert_param(IS_USART_123_PERIPH(USARTx));
;;;675      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;676    
;;;677      if (NewState != DISABLE)
;;;678      {
;;;679        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;680        USARTx->CR3 |= CR3_SCEN_Set;
;;;681      }
;;;682      else
;;;683      {
;;;684        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;685        USARTx->CR3 &= CR3_SCEN_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;680
000006  f0410120          ORRNE    r1,r1,#0x20           ;680
00000a  f0210120          BICEQ    r1,r1,#0x20
00000e  8281              STRH     r1,[r0,#0x14]         ;680
;;;686      }
;;;687    }
000010  4770              BX       lr
;;;688    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;699    *******************************************************************************/
;;;700    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;701    {
;;;702      /* Check the parameters */
;;;703      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;705    
;;;706      if (NewState != DISABLE)
;;;707      {
;;;708        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;709        USARTx->CR3 |= CR3_NACK_Set;
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;714        USARTx->CR3 &= CR3_NACK_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;709
000006  f0410110          ORRNE    r1,r1,#0x10           ;709
00000a  f0210110          BICEQ    r1,r1,#0x10
00000e  8281              STRH     r1,[r0,#0x14]         ;709
;;;715      }
;;;716    }
000010  4770              BX       lr
;;;717    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;231    *******************************************************************************/
;;;232    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;233    {
;;;234      /* USART_InitStruct members default value */
;;;235      USART_InitStruct->USART_BaudRate = 9600;
;;;236      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;237      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;238      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;239      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;240      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;241    }
000014  4770              BX       lr
;;;242    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;468    *******************************************************************************/
;;;469    void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;470    {
;;;471      /* Check the parameters */
;;;472      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;473      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;474      
;;;475      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f4226200          BIC      r2,r2,#0x800
000006  8182              STRH     r2,[r0,#0xc]
;;;476      USARTx->CR1 |= USART_WakeUp;
000008  8982              LDRH     r2,[r0,#0xc]
00000a  4311              ORRS     r1,r1,r2
00000c  8181              STRH     r1,[r0,#0xc]
;;;477    }
00000e  4770              BX       lr
;;;478    
                          ENDP

