; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=517 -DVECT_TAB_FLASH --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Decrement_TimingDelay||, CODE, READONLY, ALIGN=2

                  Decrement_TimingDelay PROC
;;;1016   *******************************************************************************/
;;;1017   void Decrement_TimingDelay(void)
000000  4804              LDR      r0,|L1.20|
;;;1018   {
;;;1019     if (TimingDelay != 0x00)
000002  6981              LDR      r1,[r0,#0x18]  ; TimingDelay
000004  2900              CMP      r1,#0                 ;1018
;;;1020     {
;;;1021       TimingDelay--;
;;;1022     }
;;;1023   }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  6981              LDR      r1,[r0,#0x18]         ;1021  ; TimingDelay
00000c  1e49              SUBS     r1,r1,#1              ;1021
00000e  6181              STR      r1,[r0,#0x18]         ;1021  ; TimingDelay
000010  4770              BX       lr
;;;1024   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.data||

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=2

                  Delay PROC
;;;986    *******************************************************************************/
;;;987    void Delay(u32 nCount)				 //////delay  10ms
000000  b510              PUSH     {r4,lr}
;;;988    {
;;;989      TimingDelay = nCount*10;
000002  4c07              LDR      r4,|L2.32|
000004  eb000080          ADD      r0,r0,r0,LSL #2
000008  0040              LSLS     r0,r0,#1
00000a  61a0              STR      r0,[r4,#0x18]  ; TimingDelay
;;;990      /* Enable the SysTick Counter */
;;;991      //SysTick_CounterCmd(SysTick_Counter_Enable);	
;;;992      SysTick_ITConfig(ENABLE);//ENABLE DISABLE		
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       SysTick_ITConfig
                  |L2.18|
;;;993      while(TimingDelay != 0)
000012  69a0              LDR      r0,[r4,#0x18]  ; TimingDelay
000014  2800              CMP      r0,#0
000016  d1fc              BNE      |L2.18|
;;;994      {;;}
;;;995      SysTick_ITConfig(DISABLE);//ENABLE DISABLE 
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      SysTick_ITConfig
;;;996    }
;;;997    
                          ENDP

                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.DelayKEY||, CODE, READONLY, ALIGN=2

                  DelayKEY PROC
;;;1066   
;;;1067   void DelayKEY (u32 k)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1068   { 
000002  b083              SUB      sp,sp,#0xc
000004  0006              MOVS     r6,r0
;;;1069       volatile u16 m=1;
000006  f04f0001          MOV      r0,#1
00000a  f8ad0000          STRH     r0,[sp,#0]
;;;1070   	volatile u32 j;
;;;1071   
;;;1072         for (j=0; j<k; j++)
00000e  f04f0000          MOV      r0,#0
000012  9001              STR      r0,[sp,#4]            ;1068
;;;1073            {  
;;;1074   		 	m=KEYC6;	
;;;1075   			Delay(2);
;;;1076               while(m==0)
;;;1077                 {
;;;1078   			  	m=KEYC6; 
;;;1079   			  	Delay(2);
;;;1080   
;;;1081   			  }            
;;;1082            }	
;;;1083   
;;;1084   }
000014  bf04              ITT      EQ
000016  b003              ADDEQ    sp,sp,#0xc
000018  bdf0              POPEQ    {r4-r7,pc}
00001a  4f14              LDR      r7,|L3.108|
00001c  4c14              LDR      r4,|L3.112|
00001e  2514              MOVS     r5,#0x14              ;1074
                  |L3.32|
000020  68b8              LDR      r0,[r7,#8]            ;1074
000022  f0000040          AND      r0,r0,#0x40           ;1074
000026  f8ad0000          STRH     r0,[sp,#0]            ;1074
00002a  2002              MOVS     r0,#2                 ;1075
00002c  f7fffffe          BL       Delay
000030  f8bd0000          LDRH     r0,[sp,#0]            ;1076
000034  b990              CBNZ     r0,|L3.92|
                  |L3.54|
000036  68b8              LDR      r0,[r7,#8]            ;1078
000038  f0000040          AND      r0,r0,#0x40           ;1078
00003c  f8ad0000          STRH     r0,[sp,#0]            ;1078
000040  61a5              STR      r5,[r4,#0x18]         ;1078  ; TimingDelay
000042  2001              MOVS     r0,#1                 ;1078
000044  f7fffffe          BL       SysTick_ITConfig
                  |L3.72|
000048  69a1              LDR      r1,[r4,#0x18]         ;1078  ; TimingDelay
00004a  2900              CMP      r1,#0                 ;1078
00004c  d1fc              BNE      |L3.72|
00004e  2000              MOVS     r0,#0                 ;1078
000050  f7fffffe          BL       SysTick_ITConfig
000054  f8bd0000          LDRH     r0,[sp,#0]            ;1076
000058  2800              CMP      r0,#0                 ;1076
00005a  d0ec              BEQ      |L3.54|
                  |L3.92|
00005c  9801              LDR      r0,[sp,#4]            ;1072
00005e  1c40              ADDS     r0,r0,#1              ;1072
000060  9001              STR      r0,[sp,#4]            ;1072
000062  42b0              CMP      r0,r6                 ;1072
000064  d3dc              BCC      |L3.32|
000066  b003              ADD      sp,sp,#0xc
000068  bdf0              POP      {r4-r7,pc}
;;;1085   
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      0x40011000
                  |L3.112|
                          DCD      ||.data||

                          AREA ||i.I2C_DATAL_COMPARE||, CODE, READONLY, ALIGN=2

                  I2C_DATAL_COMPARE PROC
;;;1389   }
;;;1390   void I2C_DATAL_COMPARE(void)
000000  f8dfc030          LDR      r12,|L4.52|
;;;1391   {
000004  b430              PUSH     {r4,r5}
;;;1392   		int yy=1,zz=0;
000006  2101              MOVS     r1,#1
;;;1393   	while(yy<count1 && zz<count1)
000008  f8bc200e          LDRH     r2,[r12,#0xe]
;;;1394   	{
;;;1395   		if(	DATA_SUM1[zz]>DATA_SUM1[yy])
00000c  4b0a              LDR      r3,|L4.56|
00000e  2000              MOVS     r0,#0                 ;1392
                  |L4.16|
000010  4291              CMP      r1,r2                 ;1393
000012  bfb2              ITEE     LT                    ;1393
000014  4290              CMPLT    r0,r2                 ;1393
;;;1396   		{
;;;1397   			count2=yy;zz=zz+1;	
;;;1398   		}
;;;1399   		else
;;;1400   		{
;;;1401   			count2=zz;yy=yy+1;
;;;1402   		}
;;;1403   	}	
;;;1404   }
000016  bc30              POPGE    {r4,r5}
000018  4770              BXGE     lr
00001a  f8334010          LDRH     r4,[r3,r0,LSL #1]     ;1395
00001e  f8335011          LDRH     r5,[r3,r1,LSL #1]     ;1395
000022  42ac              CMP      r4,r5                 ;1395
000024  bf87              ITTEE    HI                    ;1397
000026  f8ac1010          STRHHI   r1,[r12,#0x10]        ;1397
00002a  1c40              ADDHI    r0,r0,#1              ;1397
00002c  f8ac0010          STRHLS   r0,[r12,#0x10]        ;1401
000030  1c49              ADDLS    r1,r1,#1              ;1401
000032  e7ed              B        |L4.16|
;;;1405   
                          ENDP

                  |L4.52|
                          DCD      ||.data||
                  |L4.56|
                          DCD      ||.bss||+0x5c

                          AREA ||i.I2C_DATAL_COMPAREX||, CODE, READONLY, ALIGN=2

                  I2C_DATAL_COMPAREX PROC
;;;1351   }
;;;1352   void I2C_DATAL_COMPAREX(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1353   {
000002  b083              SUB      sp,sp,#0xc
;;;1354   
;;;1355   //	TSL2583_init();			////must initial TSL2583,,,for AUTO OTP use..
;;;1356   //	while(1)
;;;1357   //	{
;;;1358   	GET_FLICKER();
000004  f7fffffe          BL       GET_FLICKER
;;;1359   	I2C_MEMSURE1(STEP , VCOMDC);   //最大找寻 20次，调整的阶数值保存于SURE数组中
000008  4c18              LDR      r4,|L5.108|
00000a  7921              LDRB     r1,[r4,#4]  ; VCOMDC
00000c  7960              LDRB     r0,[r4,#5]  ; STEP
00000e  f7fffffe          BL       I2C_MEMSURE1
000012  2101              MOVS     r1,#1
000014  4b16              LDR      r3,|L5.112|
000016  89e2              LDRH     r2,[r4,#0xe]
000018  2000              MOVS     r0,#0
                  |L5.26|
00001a  4291              CMP      r1,r2
00001c  bfb8              IT       LT
00001e  4290              CMPLT    r0,r2
000020  da0a              BGE      |L5.56|
000022  f833c010          LDRH     r12,[r3,r0,LSL #1]
000026  f8335011          LDRH     r5,[r3,r1,LSL #1]
00002a  45ac              CMP      r12,r5
00002c  bf87              ITTEE    HI
00002e  8221              STRHHI   r1,[r4,#0x10]
000030  1c40              ADDHI    r0,r0,#1
000032  8220              STRHLS   r0,[r4,#0x10]
000034  1c49              ADDLS    r1,r1,#1
000036  e7f0              B        |L5.26|
                  |L5.56|
;;;1360   	I2C_DATAL_COMPARE();      //  
;;;1361       count1=0;
000038  2000              MOVS     r0,#0
00003a  81e0              STRH     r0,[r4,#0xe]
;;;1362   
;;;1363   	
;;;1364   /*在最小值附近停下来。。。后续开启OTP功能即可。。*/
;;;1365   //		VCOMDC1 = SURE[count2];				 //挑选出最好的VCOM的值，下CODE，看效果。
;;;1366   //		SHOW_value(3,50,count2);
;;;1367   //		SHOW_value(3,50,VCOMDC1);
;;;1368   
;;;1369   
;;;1370   
;;;1371   //		VCOMDC1 = SURE[count2 ] + 7;
;;;1372   //		VCOMDC1 = SURE[count2];					///////////////2013-12-05
;;;1373   		VCOMDC1 = SURE[count2];					///////////////2013-12-15
00003c  480d              LDR      r0,|L5.116|
00003e  8a21              LDRH     r1,[r4,#0x10]  ; count2
;;;1374   //	  VCOMDC1 = SURE[count2]+0;  //2014.1.27 count2为最优vcom所在的序号，根据序号在SURE数组找到对应阶数
;;;1375   //		HX8369_cmd_4(0xb6,VCOMDC1,VCOMDC1,0X00);	   ////write the perfect    vcom value
;;;1376   
;;;1377   //			ENTER_LP_mode();
;;;1378   			MIPI_SPI_Write(0x05,0x39,0xB9,0xff,0x83,0x69); 
000040  23ff              MOVS     r3,#0xff
000042  22b9              MOVS     r2,#0xb9
000044  f8300011          LDRH     r0,[r0,r1,LSL #1]     ;1373
000048  82e0              STRH     r0,[r4,#0x16]         ;1373
00004a  2169              MOVS     r1,#0x69
00004c  2083              MOVS     r0,#0x83
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
000052  2139              MOVS     r1,#0x39
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       MIPI_SPI_Write
;;;1379   //				MIPI_SPI_Write(0x04,0x39,0xB6,VCOMDC1,0x28);
;;;1380   				MIPI_SPI_Write(0x04,0x39,0xB6,VCOMDC1,VCOMDC1);
00005a  8ae3              LDRH     r3,[r4,#0x16]  ; VCOMDC1
00005c  22b6              MOVS     r2,#0xb6
00005e  2139              MOVS     r1,#0x39
000060  2004              MOVS     r0,#4
000062  9300              STR      r3,[sp,#0]
000064  f7fffffe          BL       MIPI_SPI_Write
;;;1381   //				
;;;1382   //			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;1383   //        	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC1);
;;;1384   //			VIDEO_ON();
;;;1385   //	}
;;;1386   //		VCOMDC1 = DATA_SUM1[count2];		////挑选出最小的FLICKER值，显示出来。
;;;1387   //		SHOW_value(3,125,VCOMDC1);
;;;1388   
;;;1389   }
000068  b003              ADD      sp,sp,#0xc
00006a  bd30              POP      {r4,r5,pc}
;;;1390   void I2C_DATAL_COMPARE(void)
                          ENDP

                  |L5.108|
                          DCD      ||.data||
                  |L5.112|
                          DCD      ||.bss||+0x5c
                  |L5.116|
                          DCD      ||.bss||+0x98

                          AREA ||i.I2C_MEMSURE||, CODE, READONLY, ALIGN=2

                  I2C_MEMSURE PROC
;;;1305   }
;;;1306   void I2C_MEMSURE(void)
000000  252a              MOVS     r5,#0x2a
;;;1307   { 
;;;1308   		u16 mm_KEYA7 = 1;
;;;1309   	int temp;	  //temp 为加的阶数
;;;1310       u16 a=0x2A,b;
;;;1311   		SENSOR_Check(0x52);			/////S3		
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       SENSOR_Check
;;;1312   	SENSOR_Check(0x72);			/////S2
000008  2072              MOVS     r0,#0x72
00000a  f7fffffe          BL       SENSOR_Check
;;;1313      while(1)
;;;1314      {
;;;1315           	Delay(4);	
;;;1316      	  	mm_KEYA7 =  KEYA7;
00000e  4c14              LDR      r4,|L6.96|
                  |L6.16|
000010  2004              MOVS     r0,#4                 ;1315
000012  f7fffffe          BL       Delay
000016  6820              LDR      r0,[r4,#0]
000018  f0100f80          TST      r0,#0x80
;;;1317      if(mm_KEYA7 == 0)
00001c  d1f8              BNE      |L6.16|
                  |L6.30|
;;;1318   		{
;;;1319   	
;;;1320   			 while(!mm_KEYA7)
;;;1321   			 {		mm_KEYA7 =  KEYA7;}
00001e  6820              LDR      r0,[r4,#0]
000020  f0100f80          TST      r0,#0x80
000024  d0fb              BEQ      |L6.30|
;;;1322   
;;;1323   
;;;1324      
;;;1325   //	HX8369_cmd_4(0xb6,SURE[sss],SURE[sss],0X00);		  ////set vcom
;;;1326   	       MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  2139              MOVS     r1,#0x39
00002c  2003              MOVS     r0,#3
00002e  f7fffffe          BL       MIPI_SPI_Write
;;;1327           	MIPI_SPI_Write(0x03,0x39,0xD9,a);
000032  462b              MOV      r3,r5
000034  22d9              MOVS     r2,#0xd9
000036  2139              MOVS     r1,#0x39
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       MIPI_SPI_Write
;;;1328   		  Delay(5);
00003e  2005              MOVS     r0,#5
000040  f7fffffe          BL       Delay
;;;1329   //	 	 READ_IC_A(0XD9,0x00);
;;;1330   
;;;1331    //   LCD_DisplayStringLine(100,600,"VCOM");
;;;1332    SHOW_IC_VALUE_A(300,600,a);
000044  f44f7116          MOV      r1,#0x258
000048  b2ea              UXTB     r2,r5
00004a  1048              ASRS     r0,r1,#1
00004c  f7fffffe          BL       SHOW_IC_VALUE_A
;;;1333    	
;;;1334   //	SENSOR_Check(0x92);			/////S1
;;;1335   
;;;1336   	Delay(5);
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       Delay
;;;1337           b=	GET_FLICKER();	 ///get flicker value
000056  f7fffffe          BL       GET_FLICKER
;;;1338   //	  SHOW_IC_VALUE_A(300,600,b);
;;;1339   	if(b <= 180)
;;;1340   	{temp=1;  }
;;;1341   	else if((b>180)&&(b< 180*2))
;;;1342   	{temp=2; }
;;;1343   	else
;;;1344   	{ temp=3;}
;;;1345   	a=a+1;
00005a  1c68              ADDS     r0,r5,#1
00005c  b285              UXTH     r5,r0
00005e  e7d7              B        |L6.16|
;;;1346   			
;;;1347   	}
;;;1348   	
;;;1349   
;;;1350      }
;;;1351   }
;;;1352   void I2C_DATAL_COMPAREX(void)
                          ENDP

                  |L6.96|
                          DCD      0x40010808

                          AREA ||i.I2C_MEMSURE1||, CODE, READONLY, ALIGN=2

                  I2C_MEMSURE1 PROC
;;;1235   
;;;1236   void I2C_MEMSURE1(int kk  , int vcomdcdata)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1237   { int i=0,tep1=0,tep2=0,flag=0; //2014.1.27  HFZ
000004  f04f0500          MOV      r5,#0
000008  b083              SUB      sp,sp,#0xc
00000a  4689              MOV      r9,r1
00000c  f1b00800          SUBS     r8,r0,#0
000010  462c              MOV      r4,r5
;;;1238   	int sss=0,yyy=0,aaa=0,temp;	  //temp 为加的阶数
000012  462e              MOV      r6,r5
000014  46aa              MOV      r10,r5
000016  462f              MOV      r7,r5
;;;1239   	for (yyy=0;yyy<kk;yyy++)	 //Ω?
;;;1240   	{SURE[sss]=vcomdcdata+aaa;
;;;1241   
;;;1242   //	HX8369_cmd_4(0xb6,SURE[sss],SURE[sss],0X00);		  ////set vcom
;;;1243   	MIPI_SPI_Write(0x05,0x39,0xB9,0xff,0x83,0x69); 
;;;1244   //				MIPI_SPI_Write(0x04,0x39,0xB6,SURE[sss],0x28);
;;;1245   		MIPI_SPI_Write(0x04,0x39,0xB6,SURE[sss],SURE[sss]);
;;;1246   		
;;;1247   //		MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;1248   //        	MIPI_SPI_Write(0x03,0x39,0xD9,SURE[sss]);
;;;1249   //	 SHOW_IC_VALUE_A(300,600,SURE[sss]);
;;;1250   		
;;;1251   	SENSOR_Check(0x52);			/////S3		
;;;1252   	SENSOR_Check(0x72);			/////S2
;;;1253   
;;;1254   	
;;;1255   //	SENSOR_Check(0x92);			/////S1
;;;1256   
;;;1257   	Delay(5);
;;;1258   	DATA_SUM1[count1] =	GET_FLICKER();	 ///get flicker value
;;;1259   ///////////////*------新增一部分光感ID检验功能，一旦光感失效，即停止在此处。-----*/
;;;1260     //------2014.1.27--HFZ-START-------
;;;1261   		if (flag==0)                             //判断是否找到了最低点
;;;1262   			{
;;;1263   				tep2=tep1=DATA_SUM1[count1];
;;;1264   				flag=1;
;;;1265   			}
;;;1266   		else
;;;1267   			{ 
;;;1268   				tep1=DATA_SUM1[count1];
;;;1269   					if(tep1<tep2)
;;;1270   					{
;;;1271   							tep2=tep1;
;;;1272   							 flag=1;  //此处flag再次赋值是为了在一旦再次出现更小值的情况，清除flag计数 令后续可以找到真正的最小值
;;;1273   					}
;;;1274   					else   // if (tep1>tep2)       //如果找到了最低点，则继续寻找两次(flag=1~3)
;;;1275   					  	flag++;
;;;1276   					
;;;1277   					if ((flag==3) & (tep2<300))    //判断是否是真的最低点，再确认是否小于预定值，如果是则停止寻找以节约时间。
;;;1278   					{
;;;1279   						for(i=(count1+1);i<STEP;i++)
;;;1280   							DATA_SUM1[i]=500;                     //填充剩下的数组，否则后续处理会出错
;;;1281   					
;;;1282   							yyy=kk;     //改变判断条件，使本函数提前结束
;;;1283   					}
;;;1284   			}
;;;1285   		  //
;;;1286   	 //------2014.1.27----HFZ--END------	
;;;1287   				
;;;1288   //	temp=1;			
;;;1289   	if(DATA_SUM1[count1] <180)
;;;1290   	{temp=1;  }
;;;1291   	else if((DATA_SUM1[count1]>=180)&&(DATA_SUM1[count1] < 200*2))
;;;1292   	{temp=2; }
;;;1293   	else if((DATA_SUM1[count1]>=400)&&(DATA_SUM1[count1] < 400*2))
;;;1294   	{ temp=4;}
;;;1295   	else
;;;1296   	{ temp=8;}
;;;1297   //	SHOW_value(3,125,DATA_SUM1[coufnt1]);
;;;1298   	count1=count1+1;
;;;1299   //	SHOW_value(3,90,sss);
;;;1300   //	SHOW_value(3,50,vcomdcdata+aaa); //DelayKEY(1);
;;;1301   
;;;1302   	aaa=aaa+temp;
;;;1303   	sss=sss+1;
;;;1304   	}
;;;1305   }
000018  bfdc              ITT      LE
00001a  b003              ADDLE    sp,sp,#0xc
00001c  e8bd8ff0          POPLE    {r4-r11,pc}
                  |L7.32|
000020  eb090007          ADD      r0,r9,r7              ;1240
000024  f8dfb0f4          LDR      r11,|L7.284|
000028  2169              MOVS     r1,#0x69              ;1243
00002a  23ff              MOVS     r3,#0xff              ;1243
00002c  f82b0016          STRH     r0,[r11,r6,LSL #1]    ;1240
000030  2083              MOVS     r0,#0x83              ;1243
000032  e9cd0100          STRD     r0,r1,[sp,#0]         ;1243
000036  22b9              MOVS     r2,#0xb9              ;1243
000038  2139              MOVS     r1,#0x39              ;1243
00003a  2005              MOVS     r0,#5                 ;1243
00003c  f7fffffe          BL       MIPI_SPI_Write
000040  f83b3016          LDRH     r3,[r11,r6,LSL #1]    ;1245
000044  22b6              MOVS     r2,#0xb6              ;1245
000046  2139              MOVS     r1,#0x39              ;1245
000048  2004              MOVS     r0,#4                 ;1245
00004a  9300              STR      r3,[sp,#0]            ;1245
00004c  f7fffffe          BL       MIPI_SPI_Write
000050  2052              MOVS     r0,#0x52              ;1251
000052  f7fffffe          BL       sensor_check
000056  b150              CBZ      r0,|L7.110|
000058  4a31              LDR      r2,|L7.288|
00005a  2150              MOVS     r1,#0x50              ;1251
00005c  2064              MOVS     r0,#0x64              ;1251
00005e  f7fffffe          BL       LCD_DisplayStringLine
000062  4a30              LDR      r2,|L7.292|
000064  2132              MOVS     r1,#0x32              ;1251
000066  2014              MOVS     r0,#0x14              ;1251
000068  f7fffffe          BL       LCD_DisplayStringLine
                  |L7.108|
00006c  e7fe              B        |L7.108|
                  |L7.110|
00006e  2072              MOVS     r0,#0x72              ;1252
000070  f7fffffe          BL       sensor_check
000074  b150              CBZ      r0,|L7.140|
000076  4a2c              LDR      r2,|L7.296|
000078  2150              MOVS     r1,#0x50              ;1252
00007a  208c              MOVS     r0,#0x8c              ;1252
00007c  f7fffffe          BL       LCD_DisplayStringLine
000080  4a28              LDR      r2,|L7.292|
000082  2132              MOVS     r1,#0x32              ;1252
000084  2014              MOVS     r0,#0x14              ;1252
000086  f7fffffe          BL       LCD_DisplayStringLine
                  |L7.138|
00008a  e7fe              B        |L7.138|
                  |L7.140|
00008c  2005              MOVS     r0,#5                 ;1257
00008e  f7fffffe          BL       Delay
000092  f7fffffe          BL       GET_FLICKER
000096  f8dfc098          LDR      r12,|L7.304|
00009a  4601              MOV      r1,r0                 ;1258
00009c  f8dfb08c          LDR      r11,|L7.300|
0000a0  f8bc000e          LDRH     r0,[r12,#0xe]         ;1258  ; count1
0000a4  f82b1010          STRH     r1,[r11,r0,LSL #1]    ;1258
0000a8  b10c              CBZ      r4,|L7.174|
0000aa  42a9              CMP      r1,r5                 ;1269
0000ac  da02              BGE      |L7.180|
                  |L7.174|
0000ae  460d              MOV      r5,r1                 ;1271
0000b0  2401              MOVS     r4,#1                 ;1272
0000b2  e013              B        |L7.220|
                  |L7.180|
0000b4  1c64              ADDS     r4,r4,#1              ;1272
0000b6  2c03              CMP      r4,#3                 ;1277
0000b8  d110              BNE      |L7.220|
0000ba  f5b57f96          CMP      r5,#0x12c             ;1277
0000be  da0d              BGE      |L7.220|
0000c0  f89c3005          LDRB     r3,[r12,#5]           ;1279  ; STEP
0000c4  1c42              ADDS     r2,r0,#1              ;1279
0000c6  429a              CMP      r2,r3                 ;1279
0000c8  bfb8              IT       LT                    ;1280
0000ca  f44f71fa          MOVLT    r1,#0x1f4             ;1280
0000ce  da04              BGE      |L7.218|
                  |L7.208|
0000d0  f82b1012          STRH     r1,[r11,r2,LSL #1]    ;1280
0000d4  1c52              ADDS     r2,r2,#1              ;1280
0000d6  429a              CMP      r2,r3                 ;1279
0000d8  dbfa              BLT      |L7.208|
                  |L7.218|
0000da  46c2              MOV      r10,r8                ;1282
                  |L7.220|
0000dc  f83b1010          LDRH     r1,[r11,r0,LSL #1]    ;1289
0000e0  29b4              CMP      r1,#0xb4              ;1289
0000e2  bf38              IT       CC                    ;1290
0000e4  2201              MOVCC    r2,#1                 ;1290
0000e6  d30c              BCC      |L7.258|
0000e8  f1a102b4          SUB      r2,r1,#0xb4           ;1291
0000ec  2adc              CMP      r2,#0xdc              ;1291
0000ee  bf38              IT       CC                    ;1292
0000f0  2202              MOVCC    r2,#2                 ;1292
0000f2  d306              BCC      |L7.258|
0000f4  f5a171c8          SUB      r1,r1,#0x190          ;1291
0000f8  f5b17fc8          CMP      r1,#0x190             ;1293
0000fc  bf34              ITE      CC                    ;1294
0000fe  2204              MOVCC    r2,#4                 ;1294
000100  2208              MOVCS    r2,#8                 ;1296
                  |L7.258|
000102  1c40              ADDS     r0,r0,#1              ;1296
000104  1c76              ADDS     r6,r6,#1              ;1302
000106  f10a0a01          ADD      r10,r10,#1            ;1302
00010a  f8ac000e          STRH     r0,[r12,#0xe]         ;1298
00010e  4417              ADD      r7,r7,r2              ;1302
000110  45c2              CMP      r10,r8                ;1239
000112  db85              BLT      |L7.32|
000114  b003              ADD      sp,sp,#0xc
000116  e8bd8ff0          POP      {r4-r11,pc}
;;;1306   void I2C_MEMSURE(void)
                          ENDP

00011a  0000              DCW      0x0000
                  |L7.284|
                          DCD      ||.bss||+0x98
                  |L7.288|
                          DCD      ||i.SENSOR_Check||+0x48
                  |L7.292|
                          DCD      ||i.SENSOR_Check||+0x54
                  |L7.296|
                          DCD      ||i.SENSOR_Check||+0x4c
                  |L7.300|
                          DCD      ||.bss||+0x5c
                  |L7.304|
                          DCD      ||.data||

                          AREA ||i.ID_CHECK||, CODE, READONLY, ALIGN=2

                  ID_CHECK PROC
;;;648    
;;;649    u8 ID_CHECK(u16 adx,u16 ady)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;650    {
;;;651    //	READ_IC(0XB6,0x00);
;;;652    FontR = 0; FontG = 0; FontB = 0;
000004  4e34              LDR      r6,|L8.216|
000006  2500              MOVS     r5,#0
000008  4f34              LDR      r7,|L8.220|
00000a  f8df80d4          LDR      r8,|L8.224|
00000e  7035              STRB     r5,[r6,#0]
000010  703d              STRB     r5,[r7,#0]
000012  f8885000          STRB     r5,[r8,#0]
;;;653    	READ_IC(0XDA,0x00);
000016  4629              MOV      r1,r5
000018  20da              MOVS     r0,#0xda
00001a  f7fffffe          BL       READ_IC
;;;654    	OTP_VALUE1 =   MIPI_READ_DATA[0];
00001e  f8df90c4          LDR      r9,|L8.228|
000022  4c31              LDR      r4,|L8.232|
;;;655    	READ_IC(0XDB,0x00);
000024  2100              MOVS     r1,#0
000026  f8990000          LDRB     r0,[r9,#0]            ;654  ; MIPI_READ_DATA
00002a  71a0              STRB     r0,[r4,#6]            ;654
00002c  20db              MOVS     r0,#0xdb
00002e  f7fffffe          BL       READ_IC
;;;656    	OTP_VALUE2 =   MIPI_READ_DATA[0];
000032  f8990000          LDRB     r0,[r9,#0]  ; MIPI_READ_DATA
000036  71e0              STRB     r0,[r4,#7]
;;;657    	READ_IC(0XDC,0x00);
000038  2100              MOVS     r1,#0
00003a  20dc              MOVS     r0,#0xdc
00003c  f7fffffe          BL       READ_IC
;;;658    	OTP_TIMES =   MIPI_READ_DATA[0];
000040  f8990000          LDRB     r0,[r9,#0]  ; MIPI_READ_DATA
000044  7220              STRB     r0,[r4,#8]
;;;659    //	READ_IC(0X04,0x00);
;;;660    
;;;661    	LCD_DisplayStringLine(100,100, "ID1");
000046  2164              MOVS     r1,#0x64
000048  a228              ADR      r2,|L8.236|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       LCD_DisplayStringLine
;;;662    	SHOW_IC_VALUE_A(200,100, OTP_VALUE1);
000050  79a2              LDRB     r2,[r4,#6]  ; OTP_VALUE1
000052  2164              MOVS     r1,#0x64
000054  20c8              MOVS     r0,#0xc8
000056  f7fffffe          BL       SHOW_IC_VALUE_A
;;;663    	 LCD_DisplayStringLine(100,200, "ID2");
00005a  a225              ADR      r2,|L8.240|
00005c  21c8              MOVS     r1,#0xc8
00005e  2064              MOVS     r0,#0x64
000060  f7fffffe          BL       LCD_DisplayStringLine
;;;664    	SHOW_IC_VALUE_A(200,200, OTP_VALUE2);
000064  21c8              MOVS     r1,#0xc8
000066  79e2              LDRB     r2,[r4,#7]  ; OTP_VALUE2
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       SHOW_IC_VALUE_A
;;;665    	 LCD_DisplayStringLine(100,300, "ID3");
00006e  a221              ADR      r2,|L8.244|
000070  f44f7196          MOV      r1,#0x12c
000074  2064              MOVS     r0,#0x64
000076  f7fffffe          BL       LCD_DisplayStringLine
;;;666    	SHOW_IC_VALUE_A(200,300, OTP_TIMES);
00007a  7a22              LDRB     r2,[r4,#8]  ; OTP_TIMES
00007c  f44f7196          MOV      r1,#0x12c
000080  20c8              MOVS     r0,#0xc8
000082  f7fffffe          BL       SHOW_IC_VALUE_A
;;;667    //	LCD_DisplayStringLine_A(adx,ady,"ID=");
;;;668    
;;;669    	if((OTP_VALUE1 == 0xD5)&&(OTP_VALUE2 == 0x97)&&(OTP_TIMES == 0xCA))
000086  79a1              LDRB     r1,[r4,#6]  ; OTP_VALUE1
;;;670    	{
;;;671    		ID_OK = 0;
;;;672    		FontR = 0; FontG = 255; FontB = 0;
000088  20ff              MOVS     r0,#0xff
00008a  29d5              CMP      r1,#0xd5              ;669
00008c  bf01              ITTTT    EQ                    ;669
00008e  79e1              LDRBEQ   r1,[r4,#7]            ;669  ; OTP_VALUE2
000090  2997              CMPEQ    r1,#0x97              ;669
000092  7a21              LDRBEQ   r1,[r4,#8]            ;669  ; OTP_TIMES
000094  29ca              CMPEQ    r1,#0xca              ;669
000096  d012              BEQ      |L8.190|
;;;673    //		LCD_DisplayStringLine_A(adx+150,ady,"OK");
;;;674    		LCD_DisplayStringLine_A(50,400,"ID CODE PASS");
;;;675    	}
;;;676    	else
;;;677    	{
;;;678    		ID_OK = 1;
000098  2101              MOVS     r1,#1
00009a  72a1              STRB     r1,[r4,#0xa]
;;;679    		FontR = 255; FontG = 0; FontB = 0;
00009c  7030              STRB     r0,[r6,#0]
00009e  703d              STRB     r5,[r7,#0]
0000a0  f8885000          STRB     r5,[r8,#0]
;;;680    //		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;681    		LCD_DisplayStringLine_A( 50 ,400,"ID CODE NG");
0000a4  a214              ADR      r2,|L8.248|
0000a6  f44f71c8          MOV      r1,#0x190
0000aa  2032              MOVS     r0,#0x32
0000ac  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L8.176|
;;;682    	}
;;;683    	FontR = 0; FontG = 0; FontB = 0;
0000b0  7035              STRB     r5,[r6,#0]
0000b2  703d              STRB     r5,[r7,#0]
0000b4  f8885000          STRB     r5,[r8,#0]
;;;684    //	DelayKEY(15);
;;;685    
;;;686    	return ID_OK;
0000b8  7aa0              LDRB     r0,[r4,#0xa]  ; ID_OK
;;;687    }
0000ba  e8bd87f0          POP      {r4-r10,pc}
                  |L8.190|
0000be  72a5              STRB     r5,[r4,#0xa]          ;671
0000c0  7035              STRB     r5,[r6,#0]            ;672
0000c2  7038              STRB     r0,[r7,#0]            ;672
0000c4  f8885000          STRB     r5,[r8,#0]            ;672
0000c8  a20e              ADR      r2,|L8.260|
0000ca  f44f71c8          MOV      r1,#0x190             ;674
0000ce  2032              MOVS     r0,#0x32              ;674
0000d0  f7fffffe          BL       LCD_DisplayStringLine_A
0000d4  e7ec              B        |L8.176|
;;;688    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L8.216|
                          DCD      FontR
                  |L8.220|
                          DCD      FontG
                  |L8.224|
                          DCD      FontB
                  |L8.228|
                          DCD      ||.bss||
                  |L8.232|
                          DCD      ||.data||
                  |L8.236|
0000ec  49443100          DCB      "ID1",0
                  |L8.240|
0000f0  49443200          DCB      "ID2",0
                  |L8.244|
0000f4  49443300          DCB      "ID3",0
                  |L8.248|
0000f8  49442043          DCB      "ID CODE NG",0
0000fc  4f444520
000100  4e4700  
000103  00                DCB      0
                  |L8.260|
000104  49442043          DCB      "ID CODE PASS",0
000108  4f444520
00010c  50415353
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.ID_CHECK_A||, CODE, READONLY, ALIGN=2

                  ID_CHECK_A PROC
;;;688    
;;;689    u8 ID_CHECK_A(u16 adx,u16 ady)
000000  b570              PUSH     {r4-r6,lr}
;;;690    {
;;;691        READ_IC(0X5F,0x00);
000002  2100              MOVS     r1,#0
000004  205f              MOVS     r0,#0x5f
000006  f7fffffe          BL       READ_IC
;;;692    	OTP_TIMES =   MIPI_READ_DATA[0];
00000a  4d1b              LDR      r5,|L9.120|
00000c  4c1b              LDR      r4,|L9.124|
;;;693    	
;;;694    	READ_IC(0XDA,0x00);
00000e  2100              MOVS     r1,#0
000010  7828              LDRB     r0,[r5,#0]            ;692  ; MIPI_READ_DATA
000012  7220              STRB     r0,[r4,#8]            ;692
000014  20da              MOVS     r0,#0xda
000016  f7fffffe          BL       READ_IC
;;;695    	OTP_VALUE1 =   MIPI_READ_DATA[0];
00001a  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
00001c  71a0              STRB     r0,[r4,#6]
;;;696    	READ_IC(0XDB,0x00);
00001e  2100              MOVS     r1,#0
000020  20db              MOVS     r0,#0xdb
000022  f7fffffe          BL       READ_IC
;;;697    	OTP_VALUE2 =   MIPI_READ_DATA[0];
000026  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
000028  71e0              STRB     r0,[r4,#7]
;;;698    	READ_IC(0XDC,0x00);
00002a  2100              MOVS     r1,#0
00002c  20dc              MOVS     r0,#0xdc
00002e  f7fffffe          BL       READ_IC
;;;699    	OTP_TIMES =   MIPI_READ_DATA[0];
000032  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
000034  7220              STRB     r0,[r4,#8]
;;;700    
;;;701    //	LCD_DisplayStringLine_A(adx,ady,"ID=");
;;;702    
;;;703    	if((OTP_VALUE1 == 0xD5)&&(OTP_VALUE2 == 0x97)&&(OTP_TIMES == 0xCA))
000036  79a6              LDRB     r6,[r4,#6]  ; OTP_VALUE1
000038  2100              MOVS     r1,#0
;;;704    	{
;;;705    		ID_OK = 0;
;;;706    		FontR = 0; FontG = 255; FontB = 0;
00003a  4a11              LDR      r2,|L9.128|
00003c  23ff              MOVS     r3,#0xff
00003e  f8dfc044          LDR      r12,|L9.132|
000042  4d11              LDR      r5,|L9.136|
000044  2ed5              CMP      r6,#0xd5              ;703
000046  bf02              ITTT     EQ                    ;703
000048  79e6              LDRBEQ   r6,[r4,#7]            ;703  ; OTP_VALUE2
00004a  2e97              CMPEQ    r6,#0x97              ;703
00004c  28ca              CMPEQ    r0,#0xca              ;703
00004e  d00d              BEQ      |L9.108|
;;;707    //		LCD_DisplayStringLine_A(adx+150,ady,"OK");
;;;708    	}
;;;709    	else
;;;710    	{
;;;711    		ID_OK = 1;
000050  2001              MOVS     r0,#1
000052  72a0              STRB     r0,[r4,#0xa]
;;;712    		FontR = 255; FontG = 0; FontB = 0;
000054  7013              STRB     r3,[r2,#0]
000056  f88c1000          STRB     r1,[r12,#0]
00005a  7029              STRB     r1,[r5,#0]
;;;713    		LCD_DisplayStringLine_A( 50 ,400,"ID CODE NG");
00005c  a20b              ADR      r2,|L9.140|
00005e  f44f71c8          MOV      r1,#0x190
000062  2032              MOVS     r0,#0x32
000064  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L9.104|
;;;714    //		while(1);
;;;715    //		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;716    	}
;;;717    
;;;718    
;;;719    	return ID_OK;
000068  7aa0              LDRB     r0,[r4,#0xa]  ; ID_OK
;;;720    }
00006a  bd70              POP      {r4-r6,pc}
                  |L9.108|
00006c  72a1              STRB     r1,[r4,#0xa]          ;705
00006e  7011              STRB     r1,[r2,#0]            ;706
000070  f88c3000          STRB     r3,[r12,#0]           ;706
000074  7029              STRB     r1,[r5,#0]            ;706
000076  e7f7              B        |L9.104|
;;;721    
                          ENDP

                  |L9.120|
                          DCD      ||.bss||
                  |L9.124|
                          DCD      ||.data||
                  |L9.128|
                          DCD      FontR
                  |L9.132|
                          DCD      FontG
                  |L9.136|
                          DCD      FontB
                  |L9.140|
00008c  49442043          DCB      "ID CODE NG",0
000090  4f444520
000094  4e4700  
000097  00                DCB      0

                          AREA ||i.InterruptConfig||, CODE, READONLY, ALIGN=2

                  InterruptConfig PROC
;;;964    *******************************************************************************/
;;;965    void InterruptConfig(void)
000000  b510              PUSH     {r4,lr}
;;;966    { 
;;;967      /* Deinitializes the NVIC */
;;;968      NVIC_DeInit();
000002  f7fffffe          BL       NVIC_DeInit
;;;969    
;;;970      NVIC_Configuration();
000006  f7fffffe          BL       NVIC_Configuration
;;;971    
;;;972      /* Configure the Priority Group to 2 bits */
;;;973      //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);		
;;;974    
;;;975      /* Configure the SysTick handler priority */
;;;976      //为了使用SDIO中断，下面的中断优先级被我改低了
;;;977      NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 1, 1);
00000a  2201              MOVS     r2,#1
00000c  e8bd4010          POP      {r4,lr}
000010  4611              MOV      r1,r2
000012  4801              LDR      r0,|L10.24|
000014  f7ffbffe          B.W      NVIC_SystemHandlerPriorityConfig
;;;978    }
;;;979    
                          ENDP

                  |L10.24|
                          DCD      0x0002c39a

                          AREA ||i.KEYGPIO_Init||, CODE, READONLY, ALIGN=2

                  KEYGPIO_Init PROC
;;;1047   
;;;1048   void KEYGPIO_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1049   {
;;;1050    GPIO_InitTypeDef GPIO_InitStructure; 
;;;1051    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2015              MOVS     r0,#0x15
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1052     
;;;1053     /*[把KEYGPIO KEY7/8配置成输入模式] */
;;;1054     GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_6;
00000a  2040              MOVS     r0,#0x40
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;1055     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
000010  2448              MOVS     r4,#0x48
000012  f88d4003          STRB     r4,[sp,#3]
;;;1056     GPIO_Init(GPIOC, &GPIO_InitStructure);  
000016  4669              MOV      r1,sp
000018  480b              LDR      r0,|L11.72|
00001a  f7fffffe          BL       GPIO_Init
;;;1057   
;;;1058     GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_7 ;
00001e  2080              MOVS     r0,#0x80
000020  f8ad0000          STRH     r0,[sp,#0]
;;;1059     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
;;;1060     GPIO_Init(GPIOA, &GPIO_InitStructure); 
000024  4d09              LDR      r5,|L11.76|
000026  f88d4003          STRB     r4,[sp,#3]            ;1059
00002a  4669              MOV      r1,sp
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       GPIO_Init
;;;1061       
;;;1062       GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_8;
000032  15a9              ASRS     r1,r5,#22
000034  f8ad1000          STRH     r1,[sp,#0]
;;;1063     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
000038  f88d4003          STRB     r4,[sp,#3]
;;;1064     GPIO_Init(GPIOA, &GPIO_InitStructure); 
00003c  4669              MOV      r1,sp
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       GPIO_Init
;;;1065   }
000044  bd38              POP      {r3-r5,pc}
;;;1066   
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
                          DCD      0x40011000
                  |L11.76|
                          DCD      0x40010800

                          AREA ||i.KEY_adjust||, CODE, READONLY, ALIGN=2

                  KEY_adjust PROC
;;;443    
;;;444    void KEY_adjust(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;445    {
;;;446    	u16 mm_KEYA7 = 1 ;
;;;447    	u16 mm_KEYA8 = 1 ;
;;;448    	u16 mm_KEYC6 = 1;
;;;449    	u8 OTP_FLAG = 1;
;;;450    
;;;451    
;;;452       while(OTP_FLAG)
;;;453       {
;;;454    		mm_KEYA7 = 	KEYA7;
000004  f8df80e4          LDR      r8,|L12.236|
;;;455    		mm_KEYA8 =  KEYA8;
;;;456    		mm_KEYC6 = 	KEYC6;
000008  f8dfa0e4          LDR      r10,|L12.240|
;;;457    		
;;;458    		if(mm_KEYA7 == 0)
;;;459    		{
;;;460    		
;;;461    			 while(!mm_KEYA7)
;;;462    			{	mm_KEYA7 =  KEYA7;}
;;;463    
;;;464    			VCOMDC++;
00000c  f8df90e4          LDR      r9,|L12.244|
000010  2401              MOVS     r4,#1                 ;449
;;;465                if(VCOMDC>=0x7F){VCOMDC=0x7F;}
000012  f04f0b7f          MOV      r11,#0x7f
                  |L12.22|
000016  f8d80000          LDR      r0,[r8,#0]            ;454
00001a  f8d81000          LDR      r1,[r8,#0]            ;455
00001e  f0100f80          TST      r0,#0x80              ;454
000022  f4017680          AND      r6,r1,#0x100          ;455
000026  f8da1008          LDR      r1,[r10,#8]           ;456
00002a  f0010740          AND      r7,r1,#0x40           ;456
00002e  d11f              BNE      |L12.112|
                  |L12.48|
000030  f8d80000          LDR      r0,[r8,#0]            ;462
000034  f0100f80          TST      r0,#0x80              ;462
000038  d0fa              BEQ      |L12.48|
00003a  f8990004          LDRB     r0,[r9,#4]            ;464  ; VCOMDC
00003e  1c40              ADDS     r0,r0,#1              ;464
000040  b2c0              UXTB     r0,r0                 ;464
000042  f8890004          STRB     r0,[r9,#4]            ;464
000046  287f              CMP      r0,#0x7f
000048  bf28              IT       CS
00004a  f889b004          STRBCS   r11,[r9,#4]
;;;466                if(VCOMDC<=0x00){VCOMDC=0x00;} 
;;;467                VCOM_set(VCOMDC);
00004e  f8995004          LDRB     r5,[r9,#4]  ; VCOMDC
000052  211e              MOVS     r1,#0x1e
000054  2070              MOVS     r0,#0x70
000056  f7fffffe          BL       SPI_Send
00005a  f1050180          ADD      r1,r5,#0x80
00005e  2072              MOVS     r0,#0x72
000060  f7fffffe          BL       SPI_Send
;;;468    
;;;469    			SHOW_IC_VALUE_A(20,80, VCOMDC);
000064  f8992004          LDRB     r2,[r9,#4]  ; VCOMDC
000068  2150              MOVS     r1,#0x50
00006a  2014              MOVS     r0,#0x14
00006c  f7fffffe          BL       SHOW_IC_VALUE_A
                  |L12.112|
;;;470    
;;;471    		}
;;;472    		if(mm_KEYA8 == 0)
000070  b9fe              CBNZ     r6,|L12.178|
                  |L12.114|
;;;473    		{
;;;474    		  
;;;475    			 while(!mm_KEYA8)
;;;476    			  {	mm_KEYA8 =  KEYA8;}
000072  f8d80000          LDR      r0,[r8,#0]
000076  f4107f80          TST      r0,#0x100
00007a  d0fa              BEQ      |L12.114|
;;;477    			VCOMDC--;
00007c  f8990004          LDRB     r0,[r9,#4]  ; VCOMDC
000080  1e40              SUBS     r0,r0,#1
000082  b2c0              UXTB     r0,r0
000084  f8890004          STRB     r0,[r9,#4]
;;;478                  if(VCOMDC>=0x7F){VCOMDC=0x7F;}
000088  287f              CMP      r0,#0x7f
00008a  bf28              IT       CS
00008c  f889b004          STRBCS   r11,[r9,#4]
;;;479                if(VCOMDC<=0x00){VCOMDC=0x00;} 
;;;480                  VCOM_set(VCOMDC);
000090  f8995004          LDRB     r5,[r9,#4]  ; VCOMDC
000094  211e              MOVS     r1,#0x1e
000096  2070              MOVS     r0,#0x70
000098  f7fffffe          BL       SPI_Send
00009c  f1050180          ADD      r1,r5,#0x80
0000a0  2072              MOVS     r0,#0x72
0000a2  f7fffffe          BL       SPI_Send
;;;481    			SHOW_IC_VALUE_A(20,80, VCOMDC);
0000a6  f8992004          LDRB     r2,[r9,#4]  ; VCOMDC
0000aa  2150              MOVS     r1,#0x50
0000ac  2014              MOVS     r0,#0x14
0000ae  f7fffffe          BL       SHOW_IC_VALUE_A
                  |L12.178|
;;;482    		}
;;;483    		if(mm_KEYC6 == 0)
0000b2  b99f              CBNZ     r7,|L12.220|
                  |L12.180|
;;;484    		{
;;;485    	
;;;486    			 while(!mm_KEYC6)
;;;487    			 {		mm_KEYC6 =  KEYC6;}
0000b4  f8da0008          LDR      r0,[r10,#8]
0000b8  f0100f40          TST      r0,#0x40
0000bc  d0fa              BEQ      |L12.180|
;;;488    			aat = 1;
0000be  2001              MOVS     r0,#1
0000c0  f8a90012          STRH     r0,[r9,#0x12]
;;;489    //             MTP_VCOM();
;;;490    			FontR = FontG = FontB = 0;
0000c4  480c              LDR      r0,|L12.248|
0000c6  2500              MOVS     r5,#0
0000c8  7005              STRB     r5,[r0,#0]
0000ca  480c              LDR      r0,|L12.252|
0000cc  7005              STRB     r5,[r0,#0]
0000ce  480c              LDR      r0,|L12.256|
0000d0  7005              STRB     r5,[r0,#0]
;;;491    
;;;492    			Soft_reset();
0000d2  f7fffffe          BL       Soft_reset
;;;493    			OTP_FLAG = 0;
0000d6  2400              MOVS     r4,#0
;;;494    			aat = 0;
0000d8  f8a95012          STRH     r5,[r9,#0x12]
                  |L12.220|
;;;495    		}
;;;496    		Delay(25);	
0000dc  2019              MOVS     r0,#0x19
0000de  f7fffffe          BL       Delay
0000e2  2c00              CMP      r4,#0                 ;452
0000e4  d197              BNE      |L12.22|
;;;497    		
;;;498    		
;;;499    	}
;;;500    }
0000e6  e8bd9ff0          POP      {r4-r12,pc}
;;;501    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L12.236|
                          DCD      0x40010808
                  |L12.240|
                          DCD      0x40011000
                  |L12.244|
                          DCD      ||.data||
                  |L12.248|
                          DCD      FontB
                  |L12.252|
                          DCD      FontG
                  |L12.256|
                          DCD      FontR

                          AREA ||i.MDelay||, CODE, READONLY, ALIGN=2

                  MDelay PROC
;;;999    
;;;1000   void MDelay(u32 nCount)						 ////delay 1ms		for auto OTP use
000000  b510              PUSH     {r4,lr}
;;;1001   {
;;;1002     TimingDelay = nCount;
000002  4c06              LDR      r4,|L13.28|
000004  61a0              STR      r0,[r4,#0x18]  ; TimingDelay
;;;1003     /* Enable the SysTick Counter */
;;;1004     //SysTick_CounterCmd(SysTick_Counter_Enable);	
;;;1005     SysTick_ITConfig(ENABLE);//ENABLE DISABLE		
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       SysTick_ITConfig
                  |L13.12|
;;;1006     while(TimingDelay != 0)
00000c  69a0              LDR      r0,[r4,#0x18]  ; TimingDelay
00000e  2800              CMP      r0,#0
000010  d1fc              BNE      |L13.12|
;;;1007     {;;}
;;;1008     SysTick_ITConfig(DISABLE);//ENABLE DISABLE 
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      SysTick_ITConfig
;;;1009   }
;;;1010   /*******************************************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      ||.data||

                          AREA ||i.MTP||, CODE, READONLY, ALIGN=1

                  MTP PROC
;;;1405   
;;;1406   void MTP(void)
000000  b510              PUSH     {r4,lr}
;;;1407   {
;;;1408   	///display off
;;;1409   			SSD1963GPIOOUTCOM(0xBC);		                
000002  20bc              MOVS     r0,#0xbc
000004  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1410   	SSD1963GPIOOUTDATA_16(0x0001);					
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1411   			SSD1963GPIOOUTCOM(0xbf);
00000e  20bf              MOVS     r0,#0xbf
000010  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1412   	SSD1963GPIOOUTDATA_18(0x28);	  //
000014  2028              MOVS     r0,#0x28
000016  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1413   	Delay(5);			 //delay 40ms
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       Delay
;;;1414   
;;;1415   			SSD1963GPIOOUTCOM(0xBC);		                
000020  20bc              MOVS     r0,#0xbc
000022  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1416   	SSD1963GPIOOUTDATA_16(0x0002);					
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1417   			SSD1963GPIOOUTCOM(0xbf);
00002c  20bf              MOVS     r0,#0xbf
00002e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1418   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000032  20b7              MOVS     r0,#0xb7
000034  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1419   	SSD1963GPIOOUTDATA_18(0x5a);
000038  205a              MOVS     r0,#0x5a
00003a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1420   	MDelay(20);			   ////delay 1ms
00003e  2014              MOVS     r0,#0x14
000040  f7fffffe          BL       MDelay
;;;1421   
;;;1422   	//////////set otp_index[8:0]
;;;1423   			SSD1963GPIOOUTCOM(0xBC);		                
000044  20bc              MOVS     r0,#0xbc
000046  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1424   	SSD1963GPIOOUTDATA_16(0x0006);					
00004a  2006              MOVS     r0,#6
00004c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1425   			SSD1963GPIOOUTCOM(0xbf);
000050  20bf              MOVS     r0,#0xbf
000052  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1426   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000056  20b7              MOVS     r0,#0xb7
000058  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1427   	SSD1963GPIOOUTDATA_18(0x5a);
00005c  205a              MOVS     r0,#0x5a
00005e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1428   	SSD1963GPIOOUTDATA_18(0x00);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1429   	SSD1963GPIOOUTDATA_18(0x00);
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1430   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
00006e  200d              MOVS     r0,#0xd
000070  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1431   	SSD1963GPIOOUTDATA_18(0x00);
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1432   	MDelay(10);	
00007a  200a              MOVS     r0,#0xa
00007c  f7fffffe          BL       MDelay
;;;1433   	
;;;1434   	///////////////set otp_mask[7:0]
;;;1435   			SSD1963GPIOOUTCOM(0xBC);		               
000080  20bc              MOVS     r0,#0xbc
000082  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1436   	SSD1963GPIOOUTDATA_16(0x0006);						 
000086  2006              MOVS     r0,#6
000088  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1437   			SSD1963GPIOOUTCOM(0xbf);
00008c  20bf              MOVS     r0,#0xbf
00008e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1438   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000092  20b7              MOVS     r0,#0xb7
000094  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1439   	SSD1963GPIOOUTDATA_18(0x5a);
000098  205a              MOVS     r0,#0x5a
00009a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1440   	SSD1963GPIOOUTDATA_18(0x00);
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1441   	SSD1963GPIOOUTDATA_18(0x00);
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1442   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
0000aa  200d              MOVS     r0,#0xd
0000ac  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1443   	SSD1963GPIOOUTDATA_18(0x00);
0000b0  2000              MOVS     r0,#0
0000b2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1444   	MDelay(10);		
0000b6  200a              MOVS     r0,#0xa
0000b8  f7fffffe          BL       MDelay
;;;1445   
;;;1446   	/////////////set otp address
;;;1447   			SSD1963GPIOOUTCOM(0xBC);		              
0000bc  20bc              MOVS     r0,#0xbc
0000be  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1448   	SSD1963GPIOOUTDATA_16(0x0006);						 
0000c2  2006              MOVS     r0,#6
0000c4  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1449   			SSD1963GPIOOUTCOM(0xbf);
0000c8  20bf              MOVS     r0,#0xbf
0000ca  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1450   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0000ce  20b7              MOVS     r0,#0xb7
0000d0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1451   	SSD1963GPIOOUTDATA_18(0x5a);
0000d4  205a              MOVS     r0,#0x5a
0000d6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1452   	SSD1963GPIOOUTDATA_18(0x00);
0000da  2000              MOVS     r0,#0
0000dc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1453   	SSD1963GPIOOUTDATA_18(0x00);
0000e0  2000              MOVS     r0,#0
0000e2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1454   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
0000e6  200d              MOVS     r0,#0xd
0000e8  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1455   	SSD1963GPIOOUTDATA_18(0x00);
0000ec  2000              MOVS     r0,#0
0000ee  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1456   	MDelay(10);
0000f2  200a              MOVS     r0,#0xa
0000f4  f7fffffe          BL       MDelay
;;;1457   
;;;1458   	/////////////set otp_prog = 1;
;;;1459   			SSD1963GPIOOUTCOM(0xBC);		             
0000f8  20bc              MOVS     r0,#0xbc
0000fa  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1460   	SSD1963GPIOOUTDATA_16(0x0006);						 
0000fe  2006              MOVS     r0,#6
000100  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1461   			SSD1963GPIOOUTCOM(0xbf);
000104  20bf              MOVS     r0,#0xbf
000106  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1462   	SSD1963GPIOOUTDATA_18(0xb7);	  //
00010a  20b7              MOVS     r0,#0xb7
00010c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1463   	SSD1963GPIOOUTDATA_18(0x5a);
000110  205a              MOVS     r0,#0x5a
000112  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1464   	SSD1963GPIOOUTDATA_18(0x00);
000116  2000              MOVS     r0,#0
000118  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1465   	SSD1963GPIOOUTDATA_18(0x00);
00011c  2000              MOVS     r0,#0
00011e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1466   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
000122  200d              MOVS     r0,#0xd
000124  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1467   	SSD1963GPIOOUTDATA_18(0x01);
000128  2001              MOVS     r0,#1
00012a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1468   	MDelay(45);		 		///DELAY 11ms
00012e  202d              MOVS     r0,#0x2d
000130  f7fffffe          BL       MDelay
;;;1469   
;;;1470   	/////////////set otp_index[8:0]
;;;1471   			SSD1963GPIOOUTCOM(0xBC);		              
000134  20bc              MOVS     r0,#0xbc
000136  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1472   	SSD1963GPIOOUTDATA_16(0x0006);						 
00013a  2006              MOVS     r0,#6
00013c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1473   			SSD1963GPIOOUTCOM(0xbf);
000140  20bf              MOVS     r0,#0xbf
000142  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1474   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000146  20b7              MOVS     r0,#0xb7
000148  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1475   	SSD1963GPIOOUTDATA_18(0x5a);
00014c  205a              MOVS     r0,#0x5a
00014e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1476   	SSD1963GPIOOUTDATA_18(0x00);
000152  2000              MOVS     r0,#0
000154  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1477   	SSD1963GPIOOUTDATA_18(0x00);
000158  2000              MOVS     r0,#0
00015a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1478   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
00015e  200e              MOVS     r0,#0xe
000160  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1479   	SSD1963GPIOOUTDATA_18(0x00);
000164  2000              MOVS     r0,#0
000166  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1480   	MDelay(10);
00016a  200a              MOVS     r0,#0xa
00016c  f7fffffe          BL       MDelay
;;;1481   
;;;1482   	/////////////set otp_mask[7:0]
;;;1483   			SSD1963GPIOOUTCOM(0xBC);		                
000170  20bc              MOVS     r0,#0xbc
000172  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1484   	SSD1963GPIOOUTDATA_16(0x0006);						
000176  2006              MOVS     r0,#6
000178  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1485   			SSD1963GPIOOUTCOM(0xbf);
00017c  20bf              MOVS     r0,#0xbf
00017e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1486   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000182  20b7              MOVS     r0,#0xb7
000184  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1487   	SSD1963GPIOOUTDATA_18(0x5a);
000188  205a              MOVS     r0,#0x5a
00018a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1488   	SSD1963GPIOOUTDATA_18(0x00);
00018e  2000              MOVS     r0,#0
000190  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1489   	SSD1963GPIOOUTDATA_18(0x00);
000194  2000              MOVS     r0,#0
000196  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1490   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
00019a  200e              MOVS     r0,#0xe
00019c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1491   	SSD1963GPIOOUTDATA_18(0x00);
0001a0  2000              MOVS     r0,#0
0001a2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1492   	MDelay(10);
0001a6  200a              MOVS     r0,#0xa
0001a8  f7fffffe          BL       MDelay
;;;1493   
;;;1494   	/////////////set otp address
;;;1495   			SSD1963GPIOOUTCOM(0xBC);		                 
0001ac  20bc              MOVS     r0,#0xbc
0001ae  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1496   	SSD1963GPIOOUTDATA_16(0x0006);					
0001b2  2006              MOVS     r0,#6
0001b4  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1497   			SSD1963GPIOOUTCOM(0xbf);
0001b8  20bf              MOVS     r0,#0xbf
0001ba  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1498   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0001be  20b7              MOVS     r0,#0xb7
0001c0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1499   	SSD1963GPIOOUTDATA_18(0x5a);
0001c4  205a              MOVS     r0,#0x5a
0001c6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1500   	SSD1963GPIOOUTDATA_18(0x00);
0001ca  2000              MOVS     r0,#0
0001cc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1501   	SSD1963GPIOOUTDATA_18(0x00);
0001d0  2000              MOVS     r0,#0
0001d2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1502   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
0001d6  200e              MOVS     r0,#0xe
0001d8  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1503   	SSD1963GPIOOUTDATA_18(0x00);
0001dc  2000              MOVS     r0,#0
0001de  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1504   	MDelay(10);
0001e2  200a              MOVS     r0,#0xa
0001e4  f7fffffe          BL       MDelay
;;;1505   
;;;1506   	/////////////set otp_prog = 1;
;;;1507   			SSD1963GPIOOUTCOM(0xBC);		                 
0001e8  20bc              MOVS     r0,#0xbc
0001ea  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1508   	SSD1963GPIOOUTDATA_16(0x0006);						  
0001ee  2006              MOVS     r0,#6
0001f0  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1509   			SSD1963GPIOOUTCOM(0xbf);
0001f4  20bf              MOVS     r0,#0xbf
0001f6  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1510   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0001fa  20b7              MOVS     r0,#0xb7
0001fc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1511   	SSD1963GPIOOUTDATA_18(0x5a);
000200  205a              MOVS     r0,#0x5a
000202  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1512   	SSD1963GPIOOUTDATA_18(0x00);
000206  2000              MOVS     r0,#0
000208  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1513   	SSD1963GPIOOUTDATA_18(0x00);
00020c  2000              MOVS     r0,#0
00020e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1514   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
000212  200e              MOVS     r0,#0xe
000214  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1515   	SSD1963GPIOOUTDATA_18(0x01);
000218  2001              MOVS     r0,#1
00021a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1516   	MDelay(45);		 		///DELAY 11ms
00021e  202d              MOVS     r0,#0x2d
000220  f7fffffe          BL       MDelay
;;;1517   
;;;1518      	//////MTP   OVER ,,,OTP  Disable
;;;1519   			SSD1963GPIOOUTCOM(0xBC);		                 
000224  20bc              MOVS     r0,#0xbc
000226  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1520   	SSD1963GPIOOUTDATA_16(0x0002);						  
00022a  2002              MOVS     r0,#2
00022c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1521   			SSD1963GPIOOUTCOM(0xbf);
000230  20bf              MOVS     r0,#0xbf
000232  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1522   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000236  20b7              MOVS     r0,#0xb7
000238  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1523   	SSD1963GPIOOUTDATA_18(0xff);
00023c  20ff              MOVS     r0,#0xff
00023e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1524   	MDelay(10);
000242  200a              MOVS     r0,#0xa
000244  f7fffffe          BL       MDelay
;;;1525   
;;;1526   	///display on
;;;1527   			SSD1963GPIOOUTCOM(0xBC);		                
000248  20bc              MOVS     r0,#0xbc
00024a  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1528   	SSD1963GPIOOUTDATA_16(0x0001);					
00024e  2001              MOVS     r0,#1
000250  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1529   			SSD1963GPIOOUTCOM(0xbf);
000254  20bf              MOVS     r0,#0xbf
000256  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1530   	SSD1963GPIOOUTDATA_18(0x29);	  //
00025a  2029              MOVS     r0,#0x29
00025c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1531   	Delay(5);			 //delay 40ms
000260  e8bd4010          POP      {r4,lr}
000264  2005              MOVS     r0,#5
000266  f7ffbffe          B.W      Delay
;;;1532   }
;;;1533   
                          ENDP


                          AREA ||i.MTP_ID||, CODE, READONLY, ALIGN=2

                  MTP_ID PROC
;;;1718       
;;;1719   void MTP_ID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1720   {
000002  b084              SUB      sp,sp,#0x10
;;;1721   	MIPI_SPI_Write(0x05,0x39, 0xB9,0xFF,0x83,0x69);//EXTC Command Set enable register
000004  2169              MOVS     r1,#0x69
000006  2083              MOVS     r0,#0x83
000008  e9cd0100          STRD     r0,r1,[sp,#0]
00000c  23ff              MOVS     r3,#0xff
00000e  22b9              MOVS     r2,#0xb9
000010  2139              MOVS     r1,#0x39
000012  2005              MOVS     r0,#5
000014  f7fffffe          BL       MIPI_SPI_Write
;;;1722   
;;;1723   //	MIPI_SPI_Write(0x05,0x39, 0xBF,0xE0,0x00,0x00);
;;;1724   	
;;;1725   //	OPEN_OTP_Voltage;//Open 7.5V
;;;1726   	Delay(50);//Wait 500ms for PVSS stable	8369 no delay time
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       Delay
;;;1727   	
;;;1728   //	MIPI_SPI_Write(0x05,0x39, 0xB6,VCOMDC,0x28);//This command is used to set VCOM Voltage include VCOM Low and VCOM High Voltage.
;;;1729   	MIPI_SPI_Write(0x04,0x39, 0xB6,VCOMDC1,VCOMDC1);
00001e  4833              LDR      r0,|L15.236|
000020  22b6              MOVS     r2,#0xb6
000022  2139              MOVS     r1,#0x39
000024  8ac3              LDRH     r3,[r0,#0x16]  ; VCOMDC1
000026  2004              MOVS     r0,#4
000028  9300              STR      r3,[sp,#0]
00002a  f7fffffe          BL       MIPI_SPI_Write
;;;1730   	
;;;1731   	MIPI_SPI_Write(0x05,0x39, 0xE9,0xAA,0x55);// This command is used to set OTP key to enter or leave OTP program mode.
00002e  2055              MOVS     r0,#0x55
000030  9000              STR      r0,[sp,#0]
000032  23aa              MOVS     r3,#0xaa
000034  22e9              MOVS     r2,#0xe9
000036  2139              MOVS     r1,#0x39
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       MIPI_SPI_Write
;;;1732   	Delay(50);//Wait 500ms for PVSS stable 8369 no delay time
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       Delay
;;;1733   
;;;1734   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x00);
000044  2400              MOVS     r4,#0
000046  251c              MOVS     r5,#0x1c
000048  e9cd4500          STRD     r4,r5,[sp,#0]
00004c  4623              MOV      r3,r4
00004e  22bb              MOVS     r2,#0xbb
000050  2139              MOVS     r1,#0x39
000052  2006              MOVS     r0,#6
000054  9402              STR      r4,[sp,#8]
000056  f7fffffe          BL       MIPI_SPI_Write
;;;1735   
;;;1736   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x01);
00005a  2601              MOVS     r6,#1
00005c  2300              MOVS     r3,#0
00005e  22bb              MOVS     r2,#0xbb
000060  2139              MOVS     r1,#0x39
000062  2006              MOVS     r0,#6
000064  9602              STR      r6,[sp,#8]
000066  e9cd4500          STRD     r4,r5,[sp,#0]
00006a  f7fffffe          BL       MIPI_SPI_Write
;;;1737   	Delay(5);
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       Delay
000074  e9cd4500          STRD     r4,r5,[sp,#0]
;;;1738   
;;;1739   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x00);
000078  2300              MOVS     r3,#0
00007a  22bb              MOVS     r2,#0xbb
00007c  2139              MOVS     r1,#0x39
00007e  2006              MOVS     r0,#6
000080  9402              STR      r4,[sp,#8]
000082  f7fffffe          BL       MIPI_SPI_Write
;;;1740   	Delay(5);
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       Delay
;;;1741   
;;;1742   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x00);
00008c  251d              MOVS     r5,#0x1d
00008e  e9cd4500          STRD     r4,r5,[sp,#0]
000092  2300              MOVS     r3,#0
000094  22bb              MOVS     r2,#0xbb
000096  2139              MOVS     r1,#0x39
000098  2006              MOVS     r0,#6
00009a  9402              STR      r4,[sp,#8]
00009c  f7fffffe          BL       MIPI_SPI_Write
;;;1743   	Delay(5);
0000a0  2005              MOVS     r0,#5
0000a2  f7fffffe          BL       Delay
;;;1744   
;;;1745   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x01);
0000a6  2300              MOVS     r3,#0
0000a8  22bb              MOVS     r2,#0xbb
0000aa  2139              MOVS     r1,#0x39
0000ac  2006              MOVS     r0,#6
0000ae  9602              STR      r6,[sp,#8]
0000b0  e9cd4500          STRD     r4,r5,[sp,#0]
0000b4  f7fffffe          BL       MIPI_SPI_Write
;;;1746   	Delay(5);
0000b8  2005              MOVS     r0,#5
0000ba  f7fffffe          BL       Delay
0000be  e9cd4500          STRD     r4,r5,[sp,#0]
;;;1747   
;;;1748   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x00);
0000c2  2300              MOVS     r3,#0
0000c4  22bb              MOVS     r2,#0xbb
0000c6  2139              MOVS     r1,#0x39
0000c8  2006              MOVS     r0,#6
0000ca  9402              STR      r4,[sp,#8]
0000cc  f7fffffe          BL       MIPI_SPI_Write
;;;1749   	Delay(5);
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       Delay
;;;1750   
;;;1751   	initial_OTP();
0000d6  f7fffffe          BL       initial_OTP
;;;1752   
;;;1753   	MIPI_SPI_Write(0x06,0x39, 0xE9,0x00,0x00);//set OTP off
0000da  2300              MOVS     r3,#0
0000dc  22e9              MOVS     r2,#0xe9
0000de  2139              MOVS     r1,#0x39
0000e0  2006              MOVS     r0,#6
0000e2  9400              STR      r4,[sp,#0]
0000e4  f7fffffe          BL       MIPI_SPI_Write
;;;1754   
;;;1755   //	CLOSE_OTP_Voltage;//Close 7.5V 
;;;1756   //	Delay(10);//Wait 10ms	8369 no delay time
;;;1757   //	
;;;1758   //	SSD1963Command_8(0xBa); 
;;;1759   //	SSD1963Data_8(0x0E);   //RESET=0
;;;1760   //	Delay(12);
;;;1761   //	SSD1963Command_8(0xBa); 
;;;1762   //	SSD1963Data_8(0x0F);   //RESET=1 
;;;1763   //	Delay(12);
;;;1764   //	
;;;1765   //	SSD1963INITSSD2825();
;;;1766   //	OTP_initial();//GPI009A0 (HX8369-A01) initial code
;;;1767   	
;;;1768   	
;;;1769   }
0000e8  b004              ADD      sp,sp,#0x10
0000ea  bd70              POP      {r4-r6,pc}
;;;1770   
                          ENDP

                  |L15.236|
                          DCD      ||.data||

                          AREA ||i.MTP_VCOM||, CODE, READONLY, ALIGN=1

                  MTP_VCOM PROC
;;;1681   
;;;1682   void MTP_VCOM(void)
000000  b510              PUSH     {r4,lr}
;;;1683   {
;;;1684       SPI_Send(0x70,0x0006);
000002  2106              MOVS     r1,#6
000004  2070              MOVS     r0,#0x70
000006  f7fffffe          BL       SPI_Send
;;;1685   	SPI_Send(0x72,0x2820);
00000a  f6420120          MOV      r1,#0x2820
00000e  2072              MOVS     r0,#0x72
000010  f7fffffe          BL       SPI_Send
;;;1686       Delay(500);////wait 0.5s
000014  f44f70fa          MOV      r0,#0x1f4
000018  f7fffffe          BL       Delay
;;;1687       
;;;1688       SPI_Send(0x70,0x0060);
00001c  2160              MOVS     r1,#0x60
00001e  2070              MOVS     r0,#0x70
000020  f7fffffe          BL       SPI_Send
;;;1689   	SPI_Send(0x72,0x8000);
000024  f44f4100          MOV      r1,#0x8000
000028  2072              MOVS     r0,#0x72
00002a  f7fffffe          BL       SPI_Send
;;;1690       
;;;1691       SPI_Send(0x70,0x0060);
00002e  2160              MOVS     r1,#0x60
000030  2070              MOVS     r0,#0x70
000032  f7fffffe          BL       SPI_Send
;;;1692   	SPI_Send(0x72,0xC000);
000036  f44f4140          MOV      r1,#0xc000
00003a  2072              MOVS     r0,#0x72
00003c  f7fffffe          BL       SPI_Send
;;;1693       
;;;1694       /////connect 7.3v to VGH  and 0V to VGL
;;;1695       SPI_Send(0x70,0x0060);
000040  2160              MOVS     r1,#0x60
000042  2070              MOVS     r0,#0x70
000044  f7fffffe          BL       SPI_Send
;;;1696   	SPI_Send(0x72,0xC200);
000048  f44f4142          MOV      r1,#0xc200
00004c  2072              MOVS     r0,#0x72
00004e  f7fffffe          BL       SPI_Send
;;;1697       
;;;1698       SPI_Send(0x70,0x0060);
000052  2160              MOVS     r1,#0x60
000054  2070              MOVS     r0,#0x70
000056  f7fffffe          BL       SPI_Send
;;;1699   	SPI_Send(0x72,0xC280);
00005a  f24c2180          MOV      r1,#0xc280
00005e  2072              MOVS     r0,#0x72
000060  f7fffffe          BL       SPI_Send
;;;1700       Delay(1);////wait 10ms   spec say wait 200us
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       Delay
;;;1701       
;;;1702       SPI_Send(0x70,0x0060);
00006a  2160              MOVS     r1,#0x60
00006c  2070              MOVS     r0,#0x70
00006e  f7fffffe          BL       SPI_Send
;;;1703   	SPI_Send(0x72,0xC200);
000072  f44f4142          MOV      r1,#0xc200
000076  2072              MOVS     r0,#0x72
000078  f7fffffe          BL       SPI_Send
;;;1704       
;;;1705       ///remove 7.3V from VGH and 0V from VGL
;;;1706       SPI_Send(0x70,0x0060);
00007c  2160              MOVS     r1,#0x60
00007e  2070              MOVS     r0,#0x70
000080  f7fffffe          BL       SPI_Send
;;;1707   	SPI_Send(0x72,0x8200);
000084  f44f4102          MOV      r1,#0x8200
000088  2072              MOVS     r0,#0x72
00008a  f7fffffe          BL       SPI_Send
;;;1708       
;;;1709       SPI_Send(0x70,0x0060);
00008e  2160              MOVS     r1,#0x60
000090  2070              MOVS     r0,#0x70
000092  f7fffffe          BL       SPI_Send
;;;1710   	SPI_Send(0x72,0x0200);
000096  f44f7100          MOV      r1,#0x200
00009a  2072              MOVS     r0,#0x72
00009c  f7fffffe          BL       SPI_Send
;;;1711       
;;;1712       SPI_Send(0x70,0x0060);
0000a0  2160              MOVS     r1,#0x60
0000a2  2070              MOVS     r0,#0x70
0000a4  f7fffffe          BL       SPI_Send
;;;1713   	SPI_Send(0x72,0x0040);
0000a8  2140              MOVS     r1,#0x40
0000aa  2072              MOVS     r0,#0x72
0000ac  f7fffffe          BL       SPI_Send
;;;1714       
;;;1715       SPI_Send(0x70,0x0060);
0000b0  2160              MOVS     r1,#0x60
0000b2  2070              MOVS     r0,#0x70
0000b4  f7fffffe          BL       SPI_Send
;;;1716   	SPI_Send(0x72,0x0000);
0000b8  2100              MOVS     r1,#0
0000ba  e8bd4010          POP      {r4,lr}
0000be  2072              MOVS     r0,#0x72
0000c0  f7ffbffe          B.W      SPI_Send
;;;1717   }
;;;1718       
                          ENDP


                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;926    *******************************************************************************/
;;;927    void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;928    {
;;;929    //------------zp2000--------------------------------
;;;930      NVIC_InitTypeDef NVIC_InitStructure;
;;;931    
;;;932      /* Configure the NVIC Preemption Priority Bits */
;;;933      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);//该函数调用了两次
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;934    
;;;935      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQChannel;
00000a  2031              MOVS     r0,#0x31
00000c  f88d0000          STRB     r0,[sp,#0]
;;;936      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2400              MOVS     r4,#0
000012  f88d4001          STRB     r4,[sp,#1]
;;;937      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  f88d4002          STRB     r4,[sp,#2]
;;;938      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2501              MOVS     r5,#1
00001c  f88d5003          STRB     r5,[sp,#3]
;;;939      NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;940    
;;;941      /* Enable the RTC Interrupt */
;;;942      NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
000026  2003              MOVS     r0,#3
000028  f88d0000          STRB     r0,[sp,#0]
;;;943      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002c  f88d5001          STRB     r5,[sp,#1]
;;;944      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000030  f88d4002          STRB     r4,[sp,#2]
;;;945      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000034  f88d5003          STRB     r5,[sp,#3]
;;;946      NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;947    
;;;948    #ifdef  VECT_TAB_RAM  
;;;949      /* Set the Vector Table base location at 0x20000000 */ 
;;;950      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;951    #else  /* VECT_TAB_FLASH  */
;;;952      /* Set the Vector Table base location at 0x08000000 */ 
;;;953      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
00003e  2100              MOVS     r1,#0
000040  06e8              LSLS     r0,r5,#27
000042  f7fffffe          BL       NVIC_SetVectorTable
;;;954    #endif
;;;955    
;;;956    }
000046  bd38              POP      {r3-r5,pc}
;;;957    
                          ENDP


                          AREA ||i.OTP_ERROR||, CODE, READONLY, ALIGN=2

                  OTP_ERROR PROC
;;;503    
;;;504    void OTP_ERROR(void)
000000  4c0b              LDR      r4,|L18.48|
;;;505    {
;;;506    		
;;;507    	FontR = 50; FontG = 255; FontB = 50;
000002  4e0c              LDR      r6,|L18.52|
000004  2032              MOVS     r0,#0x32
000006  4f0c              LDR      r7,|L18.56|
000008  7020              STRB     r0,[r4,#0]
00000a  25ff              MOVS     r5,#0xff
00000c  7035              STRB     r5,[r6,#0]
00000e  7038              STRB     r0,[r7,#0]
;;;508    	LCD_DisplayStringLine(20,100,"Flicker OTP NG");		
000010  a20a              ADR      r2,|L18.60|
000012  2164              MOVS     r1,#0x64
000014  2014              MOVS     r0,#0x14
000016  f7fffffe          BL       LCD_DisplayStringLine
;;;509    	FontR = 255; FontG = 0; FontB = 0;
00001a  7025              STRB     r5,[r4,#0]
00001c  2000              MOVS     r0,#0
00001e  7030              STRB     r0,[r6,#0]
000020  7038              STRB     r0,[r7,#0]
;;;510    	LCD_DisplayStringLine(20,130,"Reset do flicker OTP again!"); //	DelayKEY(100);
000022  a20a              ADR      r2,|L18.76|
000024  2182              MOVS     r1,#0x82
000026  2014              MOVS     r0,#0x14
000028  f7fffffe          BL       LCD_DisplayStringLine
                  |L18.44|
;;;511    	while(1);
00002c  e7fe              B        |L18.44|
;;;512    }
;;;513    
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      FontR
                  |L18.52|
                          DCD      FontG
                  |L18.56|
                          DCD      FontB
                  |L18.60|
00003c  466c6963          DCB      "Flicker OTP NG",0
000040  6b657220
000044  4f545020
000048  4e4700  
00004b  00                DCB      0
                  |L18.76|
00004c  52657365          DCB      "Reset do flicker OTP again!",0
000050  7420646f
000054  20666c69
000058  636b6572
00005c  204f5450
000060  20616761
000064  696e2100

                          AREA ||i.OTP_NO||, CODE, READONLY, ALIGN=2

                  OTP_NO PROC
;;;513    
;;;514    void OTP_NO(void)
000000  4e0e              LDR      r6,|L19.60|
;;;515    {
;;;516    	while(1)
;;;517    	{
;;;518    		
;;;519    		LCD_DisplayStringLine_A(10,700,"OTP");
;;;520    		FontR = 255; FontG = FontB = 0;
000002  4d0f              LDR      r5,|L19.64|
000004  4f0f              LDR      r7,|L19.68|
000006  2400              MOVS     r4,#0                 ;515
000008  f04f08ff          MOV      r8,#0xff
                  |L19.12|
00000c  a20e              ADR      r2,|L19.72|
00000e  f44f712f          MOV      r1,#0x2bc             ;519
000012  200a              MOVS     r0,#0xa               ;519
000014  f7fffffe          BL       LCD_DisplayStringLine_A
000018  f8868000          STRB     r8,[r6,#0]
00001c  702c              STRB     r4,[r5,#0]
00001e  703c              STRB     r4,[r7,#0]
;;;521    		LCD_DisplayStringLine_A(160,700,"NO");
000020  a20a              ADR      r2,|L19.76|
000022  f44f712f          MOV      r1,#0x2bc
000026  20a0              MOVS     r0,#0xa0
000028  f7fffffe          BL       LCD_DisplayStringLine_A
;;;522    		Delay(100);
00002c  2064              MOVS     r0,#0x64
00002e  f7fffffe          BL       Delay
;;;523    		FontR = FontG = FontB = 0;	
000032  702c              STRB     r4,[r5,#0]
000034  703c              STRB     r4,[r7,#0]
000036  7034              STRB     r4,[r6,#0]
000038  e7e8              B        |L19.12|
;;;524    	}
;;;525    }
;;;526    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      FontR
                  |L19.64|
                          DCD      FontB
                  |L19.68|
                          DCD      FontG
                  |L19.72|
000048  4f545000          DCB      "OTP",0
                  |L19.76|
00004c  4e4f00            DCB      "NO",0
00004f  00                DCB      0

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;868    *******************************************************************************/
;;;869    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;870    {   
;;;871      /* RCC system reset(for debug purpose) */
;;;872      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;873    
;;;874      /* Enable HSE */
;;;875      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;876    
;;;877      /* Wait till HSE is ready */
;;;878      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4918              LDR      r1,|L20.116|
;;;879    
;;;880      if(HSEStartUpStatus == SUCCESS)
000014  2801              CMP      r0,#1
000016  7348              STRB     r0,[r1,#0xd]          ;878
000018  d124              BNE      |L20.100|
;;;881      {
;;;882        /* Enable Prefetch Buffer */
;;;883        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;884    
;;;885        /* Flash 2 wait state */
;;;886        FLASH_SetLatency(FLASH_Latency_2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
;;;887     	
;;;888        /* HCLK = SYSCLK */
;;;889        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
;;;890      
;;;891        /* PCLK2 = HCLK */
;;;892        RCC_PCLK2Config(RCC_HCLK_Div1); 
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
;;;893    
;;;894        /* PCLK1 = HCLK/2 */
;;;895        RCC_PCLK1Config(RCC_HCLK_Div2);
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
;;;896    
;;;897        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;898        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
;;;899    
;;;900        /* Enable PLL */ 
;;;901        RCC_PLLCmd(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L20.76|
;;;902    
;;;903        /* Wait till PLL is ready */
;;;904        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L20.76|
;;;905        {
;;;906        }
;;;907    
;;;908        /* Select PLL as system clock source */
;;;909        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L20.92|
;;;910    
;;;911        /* Wait till PLL is used as system clock source */
;;;912        while(RCC_GetSYSCLKSource() != 0x08)
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L20.92|
                  |L20.100|
;;;913        {
;;;914        }
;;;915      }
;;;916      /* Enable USART1 and GPIOA clock */
;;;917      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
000064  e8bd4010          POP      {r4,lr}
000068  2101              MOVS     r1,#1
00006a  f2440004          MOV      r0,#0x4004
00006e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;918    }
;;;919    
                          ENDP

000072  0000              DCW      0x0000
                  |L20.116|
                          DCD      ||.data||

                          AREA ||i.READ_SSD2825||, CODE, READONLY, ALIGN=2

                  READ_SSD2825 PROC
;;;542    
;;;543    void READ_SSD2825(u8 cmd)
000000  b500              PUSH     {lr}
;;;544    {
000002  b083              SUB      sp,sp,#0xc
;;;545    	u16 R_data=0;
;;;546    	u32 sdcap=0;
;;;547    	u8 TCH[6];
;;;548    
;;;549    	R_data = SSD2825_READ(cmd);
000004  f7fffffe          BL       SSD2825_READ
;;;550    
;;;551    
;;;552    	sdcap=R_data;
;;;553    	   TCH[5]=0;
000008  2100              MOVS     r1,#0
;;;554    	   TCH[4]=(sdcap%10+0x30);sdcap/=10;
00000a  4b22              LDR      r3,|L21.148|
00000c  f88d1005          STRB     r1,[sp,#5]            ;553
000010  fba32100          UMULL    r2,r1,r3,r0
000014  08c9              LSRS     r1,r1,#3
000016  424a              RSBS     r2,r1,#0
000018  eb020282          ADD      r2,r2,r2,LSL #2
00001c  eb000042          ADD      r0,r0,r2,LSL #1
000020  3030              ADDS     r0,r0,#0x30
000022  f88d0004          STRB     r0,[sp,#4]
;;;555    	   TCH[3]=(sdcap%10+0x30);sdcap/=10;
000026  fba32001          UMULL    r2,r0,r3,r1
00002a  08c2              LSRS     r2,r0,#3
00002c  4250              RSBS     r0,r2,#0
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  eb010040          ADD      r0,r1,r0,LSL #1
000036  3030              ADDS     r0,r0,#0x30
000038  f88d0003          STRB     r0,[sp,#3]
;;;556    	   TCH[2]=(sdcap%10+0x30);sdcap/=10;
00003c  fba31002          UMULL    r1,r0,r3,r2
000040  08c0              LSRS     r0,r0,#3
000042  4241              RSBS     r1,r0,#0
000044  eb010181          ADD      r1,r1,r1,LSL #2
000048  eb020141          ADD      r1,r2,r1,LSL #1
00004c  3130              ADDS     r1,r1,#0x30
00004e  f88d1002          STRB     r1,[sp,#2]
;;;557    	   TCH[1]=(sdcap%10+0x30);sdcap/=10;
000052  fba32100          UMULL    r2,r1,r3,r0
000056  08c9              LSRS     r1,r1,#3
000058  424a              RSBS     r2,r1,#0
00005a  eb020282          ADD      r2,r2,r2,LSL #2
00005e  eb000042          ADD      r0,r0,r2,LSL #1
000062  3030              ADDS     r0,r0,#0x30
000064  f88d0001          STRB     r0,[sp,#1]
;;;558    	   TCH[0]=(sdcap%10+0x30);
000068  fba32001          UMULL    r2,r0,r3,r1
00006c  08c0              LSRS     r0,r0,#3
00006e  4240              RSBS     r0,r0,#0
000070  eb000080          ADD      r0,r0,r0,LSL #2
000074  eb010040          ADD      r0,r1,r0,LSL #1
000078  3030              ADDS     r0,r0,#0x30
00007a  f88d0000          STRB     r0,[sp,#0]
;;;559    	    
;;;560    	   LCD_DisplayStringLine(95,40,TCH);
00007e  466a              MOV      r2,sp
000080  2128              MOVS     r1,#0x28
000082  205f              MOVS     r0,#0x5f
000084  f7fffffe          BL       LCD_DisplayStringLine
;;;561    	   DelayKEY(30);
000088  201e              MOVS     r0,#0x1e
00008a  f7fffffe          BL       DelayKEY
;;;562    }
00008e  b003              ADD      sp,sp,#0xc
000090  bd00              POP      {pc}
;;;563    
                          ENDP

000092  0000              DCW      0x0000
                  |L21.148|
                          DCD      0xcccccccd

                          AREA ||i.SDPicShow||, CODE, READONLY, ALIGN=2

                  SDPicShow PROC
;;;564    
;;;565    void SDPicShow(u8 pic)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;566    {
;;;567    	u8 k;
;;;568    	k = 0;
;;;569    		SDShowFlag = 1;
000004  4f0f              LDR      r7,|L22.68|
000006  4605              MOV      r5,r0                 ;566
000008  2001              MOVS     r0,#1
;;;570    		SDShowTimes = 1;
;;;571    
;;;572    		image_count = pic;
00000a  4e0f              LDR      r6,|L22.72|
00000c  70b8              STRB     r0,[r7,#2]            ;569
00000e  70f8              STRB     r0,[r7,#3]            ;570
000010  2400              MOVS     r4,#0                 ;568
000012  8035              STRH     r5,[r6,#0]
                  |L22.20|
;;;573    
;;;574    		while(SDShowFlag) 
;;;575    	{	  
;;;576    	  Disp_BMP() ;
000014  f7fffffe          BL       Disp_BMP
;;;577    	  DelayKEY(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       DelayKEY
;;;578    
;;;579       		if((image_count >= pic)&&(k <= 1))
00001e  8830              LDRH     r0,[r6,#0]  ; image_count
000020  4285              CMP      r5,r0
000022  bf98              IT       LS
000024  2c01              CMPLS    r4,#1
000026  d802              BHI      |L22.46|
;;;580    		{
;;;581    			image_count = pic;
;;;582    			k++;
000028  1c60              ADDS     r0,r4,#1
00002a  8035              STRH     r5,[r6,#0]            ;581
00002c  b2c4              UXTB     r4,r0
                  |L22.46|
;;;583    		}
;;;584    
;;;585    			  //此段为了使用SD卡的指定图片调用；；
;;;586    		if(k >= 1)
00002e  b11c              CBZ      r4,|L22.56|
;;;587    		{
;;;588    			SDShowFlag=0;	
000030  2000              MOVS     r0,#0
000032  70b8              STRB     r0,[r7,#2]
;;;589    		} 
;;;590    
;;;591    	}
;;;592    
;;;593    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L22.56|
000038  78b8              LDRB     r0,[r7,#2]            ;574  ; SDShowFlag
00003a  2800              CMP      r0,#0                 ;574
00003c  d1ea              BNE      |L22.20|
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;594    
                          ENDP

000042  0000              DCW      0x0000
                  |L22.68|
                          DCD      ||.data||
                  |L22.72|
                          DCD      image_count

                          AREA ||i.SD_InitAndConfig||, CODE, READONLY, ALIGN=2

                  SD_InitAndConfig PROC
;;;1152   /* Private functions ---------------------------------------------------------*/
;;;1153   SD_Error SD_InitAndConfig(void)
000000  b510              PUSH     {r4,lr}
;;;1154   {
;;;1155     Status = SD_Init();
000002  f7fffffe          BL       SD_Init
000006  4c10              LDR      r4,|L23.72|
;;;1156   
;;;1157     if (Status == SD_OK)
000008  282a              CMP      r0,#0x2a
00000a  7020              STRB     r0,[r4,#0]            ;1155
00000c  d119              BNE      |L23.66|
;;;1158     {
;;;1159       /*----------------- Read CSD/CID MSD registers ------------------*/
;;;1160       Status = SD_GetCardInfo(&SDCardInfo);
00000e  480f              LDR      r0,|L23.76|
000010  f7fffffe          BL       SD_GetCardInfo
000014  7020              STRB     r0,[r4,#0]
;;;1161     }
;;;1162     
;;;1163     if (Status == SD_OK)
000016  282a              CMP      r0,#0x2a
000018  d113              BNE      |L23.66|
;;;1164     {
;;;1165       /*----------------- Select Card --------------------------------*/
;;;1166       Status = SD_SelectDeselect((u32) (SDCardInfo.RCA << 16));
00001a  480c              LDR      r0,|L23.76|
00001c  f8b0004c          LDRH     r0,[r0,#0x4c]  ; SDCardInfo
000020  0400              LSLS     r0,r0,#16
000022  f7fffffe          BL       SD_SelectDeselect
000026  7020              STRB     r0,[r4,#0]
;;;1167     }
;;;1168     
;;;1169     if (Status == SD_OK)
000028  282a              CMP      r0,#0x2a
00002a  d10a              BNE      |L23.66|
;;;1170     {
;;;1171       /*----------------- Set BusWidth ------------------------------*/
;;;1172       Status = SD_EnableWideBusOperation(SDIO_BusWide_4b);
00002c  f44f6000          MOV      r0,#0x800
000030  f7fffffe          BL       SD_EnableWideBusOperation
000034  7020              STRB     r0,[r4,#0]
;;;1173     }
;;;1174     
;;;1175     /* Set Device Transfer Mode to INTERRUPT to DMA */
;;;1176     if (Status == SD_OK)
000036  282a              CMP      r0,#0x2a
000038  d103              BNE      |L23.66|
;;;1177     {  
;;;1178       Status = SD_SetDeviceMode(SD_DMA_MODE);//SD_DMA_MODE,SD_INTERRUPT_MODE
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       SD_SetDeviceMode
000040  7020              STRB     r0,[r4,#0]
                  |L23.66|
;;;1179     }
;;;1180     return Status;
000042  b2c0              UXTB     r0,r0
;;;1181   }
000044  bd10              POP      {r4,pc}
;;;1182   
                          ENDP

000046  0000              DCW      0x0000
                  |L23.72|
                          DCD      ||.data||
                  |L23.76|
                          DCD      ||.bss||+0xc

                          AREA ||i.SENSOR_Check||, CODE, READONLY, ALIGN=2

                  SENSOR_Check PROC
;;;1205   
;;;1206   void SENSOR_Check(u8 Device_N)
000000  b510              PUSH     {r4,lr}
;;;1207   {
000002  4604              MOV      r4,r0
;;;1208   	u16 temp1 =0;
;;;1209   //	temp1 = I2C_READ_BYTE(Device_N,0x9e);  /////ADC channel 0 data0low
;;;1210   	temp1 = sensor_check(Device_N);
000004  f7fffffe          BL       sensor_check
;;;1211   	if(temp1 == 0)	  
000008  2800              CMP      r0,#0
;;;1212   	{	
;;;1213   //		Delay(1);	
;;;1214   		;
;;;1215   	}
;;;1216   //	else if	(temp1 == 0)	 	
;;;1217   //	{
;;;1218   //		;	
;;;1219   ////		Delay(1);	
;;;1220   //	}
;;;1221   	else
;;;1222   	{
;;;1223   		while(1)
;;;1224   		{
;;;1225   			if(Device_N == S3_addr)	  {		LCD_DisplayStringLine(100,80,"S3");		}
;;;1226   			if(Device_N == S2_addr)	  {		LCD_DisplayStringLine(140,80,"S2");		}
;;;1227   			if(Device_N == S1_addr)	  {		LCD_DisplayStringLine(180,80,"S1");		}
;;;1228   
;;;1229   			LCD_DisplayStringLine(20,50,"sensor  error");		//红色高亮显示sensor error，警示光感失灵，暂停在此处。
;;;1230   			while(1);
;;;1231   		}
;;;1232   	}	
;;;1233   }
00000a  bf08              IT       EQ
00000c  bd10              POPEQ    {r4,pc}
00000e  2c52              CMP      r4,#0x52              ;1225
000010  d004              BEQ      |L24.28|
000012  2c72              CMP      r4,#0x72              ;1226
000014  d006              BEQ      |L24.36|
000016  2c92              CMP      r4,#0x92              ;1227
000018  d00a              BEQ      |L24.48|
00001a  e00e              B        |L24.58|
                  |L24.28|
00001c  2150              MOVS     r1,#0x50              ;1225
00001e  a20a              ADR      r2,|L24.72|
000020  2064              MOVS     r0,#0x64              ;1225
000022  e002              B        |L24.42|
                  |L24.36|
000024  a209              ADR      r2,|L24.76|
000026  2150              MOVS     r1,#0x50              ;1226
000028  208c              MOVS     r0,#0x8c              ;1226
                  |L24.42|
00002a  f7fffffe          BL       LCD_DisplayStringLine
00002e  e004              B        |L24.58|
                  |L24.48|
000030  a207              ADR      r2,|L24.80|
000032  2150              MOVS     r1,#0x50              ;1227
000034  20b4              MOVS     r0,#0xb4              ;1227
000036  f7fffffe          BL       LCD_DisplayStringLine
                  |L24.58|
00003a  a206              ADR      r2,|L24.84|
00003c  2132              MOVS     r1,#0x32              ;1229
00003e  2014              MOVS     r0,#0x14              ;1229
000040  f7fffffe          BL       LCD_DisplayStringLine
                  |L24.68|
000044  e7fe              B        |L24.68|
;;;1234   
                          ENDP

000046  0000              DCW      0x0000
                  |L24.72|
000048  533300            DCB      "S3",0
00004b  00                DCB      0
                  |L24.76|
00004c  533200            DCB      "S2",0
00004f  00                DCB      0
                  |L24.80|
000050  533100            DCB      "S1",0
000053  00                DCB      0
                  |L24.84|
000054  73656e73          DCB      "sensor  error",0
000058  6f722020
00005c  6572726f
000060  7200    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.SHOW_IC_VALUE||, CODE, READONLY, ALIGN=2

                  SHOW_IC_VALUE PROC
;;;595    
;;;596    void SHOW_IC_VALUE(u16 adx,u16 ady,u32 cmd)
000000  b510              PUSH     {r4,lr}
;;;597    {
000002  b082              SUB      sp,sp,#8
;;;598    	
;;;599    //	u16 R_data=0;
;;;600    	u32 sdcap=0;
;;;601    	u8 TCH[7];
;;;602    
;;;603    	sdcap=cmd;
;;;604    	if(sdcap == 0x55)
000004  2a55              CMP      r2,#0x55
;;;605    	{	LCD_DisplayStringLine(adx,ady,"0x55");	}	 			//ID1 = 0X55
000006  bf08              IT       EQ
000008  a227              ADREQ    r2,|L25.168|
00000a  d049              BEQ      |L25.160|
;;;606    	else if(sdcap == 0x44)
00000c  2a44              CMP      r2,#0x44
;;;607    	{	LCD_DisplayStringLine(adx,ady,"0x44");	}			    //ID2 = 0X44
00000e  bf08              IT       EQ
000010  a227              ADREQ    r2,|L25.176|
000012  d045              BEQ      |L25.160|
;;;608    	else if(sdcap == 0xF0)
000014  2af0              CMP      r2,#0xf0
;;;609    	{	LCD_DisplayStringLine(adx,ady,"0xF0");	}			    //ID3 = 0XF0
000016  bf08              IT       EQ
000018  a227              ADREQ    r2,|L25.184|
00001a  d041              BEQ      |L25.160|
;;;610    	else
;;;611    	{
;;;612    	   TCH[6]=0;
00001c  2300              MOVS     r3,#0
00001e  f88d3006          STRB     r3,[sp,#6]
;;;613    	   TCH[5]=0;
;;;614    	   TCH[4]=(sdcap%10+0x30);sdcap/=10;
000022  4c27              LDR      r4,|L25.192|
000024  f88d3005          STRB     r3,[sp,#5]            ;613
000028  fba4c302          UMULL    r12,r3,r4,r2
00002c  08db              LSRS     r3,r3,#3
00002e  f1c30c00          RSB      r12,r3,#0
000032  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000036  eb02024c          ADD      r2,r2,r12,LSL #1
00003a  3230              ADDS     r2,r2,#0x30
00003c  f88d2004          STRB     r2,[sp,#4]
;;;615    	   TCH[3]=(sdcap%10+0x30);sdcap/=10;
000040  fba4c203          UMULL    r12,r2,r4,r3
000044  ea4f0cd2          LSR      r12,r2,#3
000048  f1cc0200          RSB      r2,r12,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb030242          ADD      r2,r3,r2,LSL #1
000054  3230              ADDS     r2,r2,#0x30
000056  f88d2003          STRB     r2,[sp,#3]
;;;616    	   TCH[2]=(sdcap%10+0x30);sdcap/=10;
00005a  fba4320c          UMULL    r3,r2,r4,r12
00005e  08d2              LSRS     r2,r2,#3
000060  4253              RSBS     r3,r2,#0
000062  eb030383          ADD      r3,r3,r3,LSL #2
000066  eb0c0343          ADD      r3,r12,r3,LSL #1
00006a  3330              ADDS     r3,r3,#0x30
00006c  f88d3002          STRB     r3,[sp,#2]
;;;617    	   TCH[1]=(sdcap%10+0x30);sdcap/=10;
000070  fba4c302          UMULL    r12,r3,r4,r2
000074  08db              LSRS     r3,r3,#3
000076  f1c30c00          RSB      r12,r3,#0
00007a  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00007e  eb02024c          ADD      r2,r2,r12,LSL #1
000082  3230              ADDS     r2,r2,#0x30
000084  f88d2001          STRB     r2,[sp,#1]
;;;618    	   TCH[0]=(sdcap%10+0x30);
000088  fba4c203          UMULL    r12,r2,r4,r3
00008c  08d2              LSRS     r2,r2,#3
00008e  4252              RSBS     r2,r2,#0
000090  eb020282          ADD      r2,r2,r2,LSL #2
000094  eb030242          ADD      r2,r3,r2,LSL #1
000098  3230              ADDS     r2,r2,#0x30
00009a  f88d2000          STRB     r2,[sp,#0]
;;;619    	    
;;;620    	   LCD_DisplayStringLine(adx,ady,TCH);
00009e  466a              MOV      r2,sp
                  |L25.160|
0000a0  f7fffffe          BL       LCD_DisplayStringLine
;;;621    	}
;;;622    }
0000a4  b002              ADD      sp,sp,#8
0000a6  bd10              POP      {r4,pc}
;;;623    
                          ENDP

                  |L25.168|
0000a8  30783535          DCB      "0x55",0
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L25.176|
0000b0  30783434          DCB      "0x44",0
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L25.184|
0000b8  30784630          DCB      "0xF0",0
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L25.192|
                          DCD      0xcccccccd

                          AREA ||i.SHOW_IC_VALUE_A||, CODE, READONLY, ALIGN=2

                  SHOW_IC_VALUE_A PROC
;;;623    
;;;624    void SHOW_IC_VALUE_A(u16 adx,u16 n,u8 data)           //被调函数要在调用函数之前！
000000  b570              PUSH     {r4-r6,lr}
;;;625    {
;;;626        u8 table[17]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','\0'};
000002  a312              ADR      r3,|L26.76|
000004  b088              SUB      sp,sp,#0x20           ;625
000006  e8931070          LDM      r3,{r4-r6,r12}
00000a  e88d1070          STM      sp,{r4-r6,r12}
00000e  691b              LDR      r3,[r3,#0x10]
;;;627        u8 value[5]={0};
000010  9304              STR      r3,[sp,#0x10]
000012  2300              MOVS     r3,#0
000014  9305              STR      r3,[sp,#0x14]
;;;628        u16 temp;  
;;;629        
;;;630    //    temp=data>>12;
;;;631    //    temp=temp&0x0f;
;;;632    //    value[0]=table[temp];
;;;633    //    temp=data>>8;
;;;634    //    temp=temp&0x0f;
;;;635    //    value[1]=table[temp];			 ///屏蔽掉的代a16位字符@示
;;;636        value[0]=0x30;	//////底0
000016  9306              STR      r3,[sp,#0x18]
000018  2330              MOVS     r3,#0x30
00001a  f88d3014          STRB     r3,[sp,#0x14]
;;;637    	value[1]=0x78;	//////小x		 ///定值8位字符@示的0x
00001e  2378              MOVS     r3,#0x78
000020  f88d3015          STRB     r3,[sp,#0x15]
;;;638    	temp=data>>4;
000024  0913              LSRS     r3,r2,#4
;;;639        temp=temp&0x0f;
;;;640        value[2]=table[temp];
;;;641        temp=data;
;;;642        temp=temp&0x0f;
000026  f002020f          AND      r2,r2,#0xf
00002a  f81d3003          LDRB     r3,[sp,r3]            ;640
00002e  f88d3016          STRB     r3,[sp,#0x16]         ;640
;;;643        value[3]=table[temp];
000032  f81d2002          LDRB     r2,[sp,r2]
000036  f88d2017          STRB     r2,[sp,#0x17]
;;;644        value[4]=table[16];
00003a  f89d2010          LDRB     r2,[sp,#0x10]
00003e  f88d2018          STRB     r2,[sp,#0x18]
;;;645    
;;;646        LCD_DisplayStringLine(adx,n,value);
000042  aa05              ADD      r2,sp,#0x14
000044  f7fffffe          BL       LCD_DisplayStringLine
;;;647    }
000048  b008              ADD      sp,sp,#0x20
00004a  bd70              POP      {r4-r6,pc}
;;;648    
                          ENDP

                  |L26.76|
00004c  30313233          DCB      "0123456789ABCDEF",0
000050  34353637
000054  38394142
000058  43444546
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.SHOW_value||, CODE, READONLY, ALIGN=2

                  SHOW_value PROC
;;;526    
;;;527    void SHOW_value(u16 addx,u16 addy,u32 Data)
000000  b510              PUSH     {r4,lr}
;;;528    {
000002  b082              SUB      sp,sp,#8
;;;529    	u32 sdcap;
;;;530    	u8 TCH[7];
;;;531    
;;;532    	sdcap = Data;
;;;533    	TCH[4]=0;
000004  2300              MOVS     r3,#0
;;;534    	TCH[3]=(sdcap%10+0x30);sdcap/=10;
000006  4c1b              LDR      r4,|L27.116|
000008  f88d3004          STRB     r3,[sp,#4]            ;533
00000c  fba4c302          UMULL    r12,r3,r4,r2
000010  08db              LSRS     r3,r3,#3
000012  f1c30c00          RSB      r12,r3,#0
000016  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00001a  eb02024c          ADD      r2,r2,r12,LSL #1
00001e  3230              ADDS     r2,r2,#0x30
000020  f88d2003          STRB     r2,[sp,#3]
;;;535    	TCH[2]=(sdcap%10+0x30);sdcap/=10;
000024  fba4c203          UMULL    r12,r2,r4,r3
000028  08d2              LSRS     r2,r2,#3
00002a  f1c20c00          RSB      r12,r2,#0
00002e  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000032  eb03034c          ADD      r3,r3,r12,LSL #1
000036  3330              ADDS     r3,r3,#0x30
000038  f88d3002          STRB     r3,[sp,#2]
;;;536    	TCH[1]=(sdcap%10+0x30);sdcap/=10;
00003c  fba4c302          UMULL    r12,r3,r4,r2
000040  08db              LSRS     r3,r3,#3
000042  f1c30c00          RSB      r12,r3,#0
000046  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00004a  eb02024c          ADD      r2,r2,r12,LSL #1
00004e  3230              ADDS     r2,r2,#0x30
000050  f88d2001          STRB     r2,[sp,#1]
;;;537    	TCH[0]=(sdcap%10+0x30);
000054  fba4c203          UMULL    r12,r2,r4,r3
000058  08d2              LSRS     r2,r2,#3
00005a  4252              RSBS     r2,r2,#0
00005c  eb020282          ADD      r2,r2,r2,LSL #2
000060  eb030242          ADD      r2,r3,r2,LSL #1
000064  3230              ADDS     r2,r2,#0x30
000066  f88d2000          STRB     r2,[sp,#0]
;;;538    
;;;539    	LCD_DisplayStringLine(addx,addy,TCH);
00006a  466a              MOV      r2,sp
00006c  f7fffffe          BL       LCD_DisplayStringLine
;;;540    
;;;541    }
000070  b002              ADD      sp,sp,#8
000072  bd10              POP      {r4,pc}
;;;542    
                          ENDP

                  |L27.116|
                          DCD      0xcccccccd

                          AREA ||i.SysTick_Config||, CODE, READONLY, ALIGN=2

                  SysTick_Config PROC
;;;1031   *******************************************************************************/
;;;1032   void SysTick_Config(void)
000000  b510              PUSH     {r4,lr}
;;;1033   {
;;;1034     /* Configure HCLK clock as SysTick clock source */
;;;1035     SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;1036    
;;;1037     /* SysTick interrupt each 100 Hz with HCLK equal to 72MHz */
;;;1038     SysTick_SetReload(72000);
000008  4805              LDR      r0,|L28.32|
00000a  f7fffffe          BL       SysTick_SetReload
;;;1039   
;;;1040     /* Enable the SysTick Interrupt */
;;;1041     SysTick_ITConfig(DISABLE);//ENABLE DISABLE
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       SysTick_ITConfig
;;;1042   
;;;1043     /* Enable the SysTick Counter */
;;;1044     SysTick_CounterCmd(SysTick_Counter_Enable);
000014  e8bd4010          POP      {r4,lr}
000018  2001              MOVS     r0,#1
00001a  f7ffbffe          B.W      SysTick_CounterCmd
;;;1045   }
;;;1046   //----设定按键接口--------------
                          ENDP

00001e  0000              DCW      0x0000
                  |L28.32|
                          DCD      0x00011940

                          AREA ||i.USART1GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  USART1GPIO_Configuration PROC
;;;1134   *******************************************************************************/
;;;1135   void USART1GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1136   {
;;;1137     GPIO_InitTypeDef GPIO_InitStructure;
;;;1138   
;;;1139     /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;1140     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;1141     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;1142     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
;;;1143     GPIO_Init(GPIOA, &GPIO_InitStructure);
000012  4c09              LDR      r4,|L29.56|
000014  f88d0002          STRB     r0,[sp,#2]            ;1142
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       GPIO_Init
;;;1144       
;;;1145     /* Configure USART1 Rx (PA.10) as input floating */
;;;1146     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000020  1521              ASRS     r1,r4,#20
000022  f8ad1000          STRH     r1,[sp,#0]
;;;1147     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2104              MOVS     r1,#4
000028  f88d1003          STRB     r1,[sp,#3]
;;;1148     GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;1149   }
000034  bd38              POP      {r3-r5,pc}
;;;1150   
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
                          DCD      0x40010800

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;1085   
;;;1086   void USART_Configuration(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1087   {
000002  b087              SUB      sp,sp,#0x1c
;;;1088     USART_InitTypeDef USART_InitStructure;
;;;1089     USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;1090   
;;;1091   /* USART1 configuration ------------------------------------------------------*/
;;;1092     /* USART1 configured as follow:
;;;1093           - BaudRate = 115200 baud  
;;;1094           - Word Length = 8 Bits
;;;1095           - One Stop Bit
;;;1096           - No parity
;;;1097           - Hardware flow control disabled (RTS and CTS signals)
;;;1098           - Receive and transmit enabled
;;;1099           - USART Clock disabled
;;;1100           - USART CPOL: Clock is active low
;;;1101           - USART CPHA: Data is captured on the middle 
;;;1102           - USART LastBit: The clock pulse of the last data bit is not output to 
;;;1103                            the SCLK pin
;;;1104     */
;;;1105   USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;1106   USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;1107   USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0014          STRH     r0,[sp,#0x14]
;;;1108   USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;1109   /* Configure the USART1 synchronous paramters */
;;;1110   USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L30.84|
000010  f8ad4010          STRH     r4,[sp,#0x10]         ;1105
000014  f8ad4012          STRH     r4,[sp,#0x12]         ;1106
000018  f8ad4016          STRH     r4,[sp,#0x16]         ;1108
00001c  a904              ADD      r1,sp,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;1111   
;;;1112   USART_InitStructure.USART_BaudRate = 115200;
000024  f44f31e1          MOV      r1,#0x1c200
;;;1113   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9100              STR      r1,[sp,#0]
;;;1114   USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;1115   USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4008          STRH     r4,[sp,#8]
;;;1116   USART_InitStructure.USART_HardwareFlowControl = 
;;;1117   USART_HardwareFlowControl_None;
;;;1118   
;;;1119   USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  210c              MOVS     r1,#0xc
000030  f8ad4004          STRH     r4,[sp,#4]            ;1113
000034  f8ad100a          STRH     r1,[sp,#0xa]
000038  f8ad4006          STRH     r4,[sp,#6]            ;1114
00003c  f8ad400c          STRH     r4,[sp,#0xc]          ;1116
;;;1120   /* Configure USART1 basic and asynchronous paramters */
;;;1121   USART_Init(USART1, &USART_InitStructure);
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;1122       
;;;1123     /* Enable USART1 */
;;;1124     USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;1125     
;;;1126   }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;1127   
                          ENDP

                  |L30.84|
                          DCD      0x40013800

                          AREA ||i.VCOM_GET||, CODE, READONLY, ALIGN=2

                  VCOM_GET PROC
;;;1772   
;;;1773   u8 VCOM_GET(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1774   {
;;;1775   	READ_VCOM_OTP_TIMES_HX8369(0x1B);
000002  201b              MOVS     r0,#0x1b
000004  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
;;;1776   		DelayKEY(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DelayKEY
;;;1777   		switch(MIPI_READ_DATA[4])
00000e  4d38              LDR      r5,|L31.240|
000010  2100              MOVS     r1,#0
;;;1778   		{
;;;1779   			case 0xFF:
;;;1780   				
;;;1781   				OTP_TIMES_BEFORE = 0;
000012  4c38              LDR      r4,|L31.244|
000014  7928              LDRB     r0,[r5,#4]            ;1777  ; MIPI_READ_DATA
000016  2827              CMP      r0,#0x27              ;1777
000018  d035              BEQ      |L31.134|
00001a  dc03              BGT      |L31.36|
00001c  b130              CBZ      r0,|L31.44|
00001e  2803              CMP      r0,#3                 ;1777
000020  d04b              BEQ      |L31.186|
000022  e003              B        |L31.44|
                  |L31.36|
000024  286f              CMP      r0,#0x6f              ;1777
000026  d015              BEQ      |L31.84|
000028  28ff              CMP      r0,#0xff              ;1777
00002a  d007              BEQ      |L31.60|
                  |L31.44|
;;;1782   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1783   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1784   				break;
;;;1785   			
;;;1786   			case 0x6F:
;;;1787   				
;;;1788   				OTP_TIMES_BEFORE = 1;
;;;1789   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1790   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1791   				READ_VCOM_OTP_TIMES_HX8369(0x1C);
;;;1792   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1793   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1794   				break;
;;;1795   			
;;;1796   			case 0x27:
;;;1797   				
;;;1798   				OTP_TIMES_BEFORE = 2;
;;;1799   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1800   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1801   				READ_VCOM_OTP_TIMES_HX8369(0x1E);
;;;1802   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1803   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1804   				break;
;;;1805   			
;;;1806   			case 0x03:
;;;1807   				
;;;1808   				OTP_TIMES_BEFORE = 3;
;;;1809   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1810   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1811   				READ_VCOM_OTP_TIMES_HX8369(0x20);
;;;1812   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1813   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1814   				break;
;;;1815   			
;;;1816   			case 0x00:
;;;1817   				
;;;1818   				OTP_TIMES_BEFORE = 0;
00002c  7261              STRB     r1,[r4,#9]
;;;1819   				LCD_DisplayStringLine(20,10,"otp read error");
00002e  a232              ADR      r2,|L31.248|
000030  210a              MOVS     r1,#0xa
000032  2014              MOVS     r0,#0x14
000034  f7fffffe          BL       LCD_DisplayStringLine
                  |L31.56|
;;;1820   				break;
;;;1821   			
;;;1822   			default:
;;;1823   				
;;;1824   				OTP_TIMES_BEFORE = 0;
;;;1825   				LCD_DisplayStringLine(20,10,"otp read error");
;;;1826   				break;
;;;1827   		}
;;;1828   		
;;;1829   		return 0;
000038  2000              MOVS     r0,#0
;;;1830   }
00003a  bd70              POP      {r4-r6,pc}
                  |L31.60|
00003c  7261              STRB     r1,[r4,#9]            ;1781
00003e  a232              ADR      r2,|L31.264|
000040  210a              MOVS     r1,#0xa               ;1782
000042  2001              MOVS     r0,#1                 ;1782
000044  f7fffffe          BL       LCD_DisplayStringLine
000048  7a62              LDRB     r2,[r4,#9]            ;1783  ; OTP_TIMES_BEFORE
00004a  210a              MOVS     r1,#0xa               ;1783
00004c  20c3              MOVS     r0,#0xc3              ;1783
00004e  f7fffffe          BL       SHOW_IC_VALUE_A
000052  e7f1              B        |L31.56|
                  |L31.84|
000054  2001              MOVS     r0,#1                 ;1788
000056  7260              STRB     r0,[r4,#9]            ;1788
000058  a22b              ADR      r2,|L31.264|
00005a  210a              MOVS     r1,#0xa               ;1789
00005c  f7fffffe          BL       LCD_DisplayStringLine
000060  7a62              LDRB     r2,[r4,#9]            ;1790  ; OTP_TIMES_BEFORE
000062  210a              MOVS     r1,#0xa               ;1790
000064  20c3              MOVS     r0,#0xc3              ;1790
000066  f7fffffe          BL       SHOW_IC_VALUE_A
00006a  201c              MOVS     r0,#0x1c              ;1791
00006c  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
000070  a229              ADR      r2,|L31.280|
000072  2132              MOVS     r1,#0x32              ;1792
000074  2001              MOVS     r0,#1                 ;1792
000076  f7fffffe          BL       LCD_DisplayStringLine
00007a  792a              LDRB     r2,[r5,#4]            ;1793  ; MIPI_READ_DATA
00007c  2132              MOVS     r1,#0x32              ;1793
00007e  20c3              MOVS     r0,#0xc3              ;1793
000080  f7fffffe          BL       SHOW_IC_VALUE_A
000084  e7d8              B        |L31.56|
                  |L31.134|
000086  2002              MOVS     r0,#2                 ;1798
000088  7260              STRB     r0,[r4,#9]            ;1798
00008a  a21f              ADR      r2,|L31.264|
00008c  210a              MOVS     r1,#0xa               ;1799
00008e  2001              MOVS     r0,#1                 ;1799
000090  f7fffffe          BL       LCD_DisplayStringLine
000094  7a62              LDRB     r2,[r4,#9]            ;1800  ; OTP_TIMES_BEFORE
000096  210a              MOVS     r1,#0xa               ;1800
000098  20c3              MOVS     r0,#0xc3              ;1800
00009a  f7fffffe          BL       SHOW_IC_VALUE_A
00009e  201e              MOVS     r0,#0x1e              ;1801
0000a0  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
0000a4  a21c              ADR      r2,|L31.280|
0000a6  2132              MOVS     r1,#0x32              ;1802
0000a8  2001              MOVS     r0,#1                 ;1802
0000aa  f7fffffe          BL       LCD_DisplayStringLine
0000ae  792a              LDRB     r2,[r5,#4]            ;1803  ; MIPI_READ_DATA
0000b0  2132              MOVS     r1,#0x32              ;1803
0000b2  20c3              MOVS     r0,#0xc3              ;1803
0000b4  f7fffffe          BL       SHOW_IC_VALUE_A
0000b8  e7be              B        |L31.56|
                  |L31.186|
0000ba  2003              MOVS     r0,#3                 ;1808
0000bc  7260              STRB     r0,[r4,#9]            ;1808
0000be  a212              ADR      r2,|L31.264|
0000c0  210a              MOVS     r1,#0xa               ;1809
0000c2  2001              MOVS     r0,#1                 ;1809
0000c4  f7fffffe          BL       LCD_DisplayStringLine
0000c8  7a62              LDRB     r2,[r4,#9]            ;1810  ; OTP_TIMES_BEFORE
0000ca  210a              MOVS     r1,#0xa               ;1810
0000cc  20c3              MOVS     r0,#0xc3              ;1810
0000ce  f7fffffe          BL       SHOW_IC_VALUE_A
0000d2  2020              MOVS     r0,#0x20              ;1811
0000d4  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
0000d8  a20f              ADR      r2,|L31.280|
0000da  2132              MOVS     r1,#0x32              ;1812
0000dc  2001              MOVS     r0,#1                 ;1812
0000de  f7fffffe          BL       LCD_DisplayStringLine
0000e2  792a              LDRB     r2,[r5,#4]            ;1813  ; MIPI_READ_DATA
0000e4  2132              MOVS     r1,#0x32              ;1813
0000e6  20c3              MOVS     r0,#0xc3              ;1813
0000e8  f7fffffe          BL       SHOW_IC_VALUE_A
0000ec  e7a4              B        |L31.56|
;;;1831   /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
                          ENDP

0000ee  0000              DCW      0x0000
                  |L31.240|
                          DCD      ||.bss||
                  |L31.244|
                          DCD      ||.data||
                  |L31.248|
0000f8  6f747020          DCB      "otp read error",0
0000fc  72656164
000100  20657272
000104  6f7200  
000107  00                DCB      0
                  |L31.264|
000108  6f747020          DCB      "otp times = ",0
00010c  74696d65
000110  73203d20
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L31.280|
000118  76636f6d          DCB      "vcom value = ",0
00011c  2076616c
000120  7565203d
000124  2000    
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.VCOM_set||, CODE, READONLY, ALIGN=1

                  VCOM_set PROC
;;;430    
;;;431    void VCOM_set(u8 vcom)
000000  b510              PUSH     {r4,lr}
;;;432    {
000002  4604              MOV      r4,r0
;;;433           
;;;434        
;;;435        SPI_Send(0x70,0x001e);
000004  211e              MOVS     r1,#0x1e
000006  2070              MOVS     r0,#0x70
000008  f7fffffe          BL       SPI_Send
;;;436    	SPI_Send(0x72,0x0080+vcom);
00000c  f1040180          ADD      r1,r4,#0x80
000010  e8bd4010          POP      {r4,lr}
000014  2072              MOVS     r0,#0x72
000016  f7ffbffe          B.W      SPI_Send
;;;437        
;;;438    //			ENTER_LP_mode();
;;;439    //			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;440    //        	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC);    
;;;441    //			VIDEO_ON();
;;;442    }
;;;443    
                          ENDP


                          AREA ||i.check_power||, CODE, READONLY, ALIGN=2

                  check_power PROC
;;;392    
;;;393    void check_power(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;394    {
000002  b083              SUB      sp,sp,#0xc
;;;395    	  	ENTER_LP_mode(); //enter  LP mode
000004  f7fffffe          BL       ENTER_LP_mode
;;;396    
;;;397    	 	MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000008  2300              MOVS     r3,#0
00000a  461a              MOV      r2,r3
00000c  2139              MOVS     r1,#0x39
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       MIPI_SPI_Write
;;;398    		MIPI_SPI_Write(0x05,0x39,0xFF,0x80,0x09,0x01);
000014  2501              MOVS     r5,#1
000016  2409              MOVS     r4,#9
000018  2380              MOVS     r3,#0x80
00001a  22ff              MOVS     r2,#0xff
00001c  2139              MOVS     r1,#0x39
00001e  2005              MOVS     r0,#5
000020  e9cd4500          STRD     r4,r5,[sp,#0]
000024  f7fffffe          BL       MIPI_SPI_Write
;;;399    		
;;;400    		MIPI_SPI_Write(0x03,0x39,0x00,0x80);
000028  2380              MOVS     r3,#0x80
00002a  2200              MOVS     r2,#0
00002c  2139              MOVS     r1,#0x39
00002e  2003              MOVS     r0,#3
000030  f7fffffe          BL       MIPI_SPI_Write
;;;401    		MIPI_SPI_Write(0x04,0x39,0xFF,0x80,0x09);
000034  2380              MOVS     r3,#0x80
000036  22ff              MOVS     r2,#0xff
000038  2139              MOVS     r1,#0x39
00003a  2004              MOVS     r0,#4
00003c  9400              STR      r4,[sp,#0]
00003e  f7fffffe          BL       MIPI_SPI_Write
;;;402    
;;;403    		MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000042  2300              MOVS     r3,#0
000044  461a              MOV      r2,r3
000046  2139              MOVS     r1,#0x39
000048  2003              MOVS     r0,#3
00004a  f7fffffe          BL       MIPI_SPI_Write
;;;404    		MIPI_SPI_Write(0x03,0x39,0xD0,0xD5);
00004e  23d5              MOVS     r3,#0xd5
000050  22d0              MOVS     r2,#0xd0
000052  2139              MOVS     r1,#0x39
000054  2003              MOVS     r0,#3
000056  f7fffffe          BL       MIPI_SPI_Write
;;;405    
;;;406    		READ_IC(0XD3,0x00);
00005a  2100              MOVS     r1,#0
00005c  20d3              MOVS     r0,#0xd3
00005e  f7fffffe          BL       READ_IC
;;;407    
;;;408       
;;;409     
;;;410    		if(MIPI_READ_DATA[0] == 0x03)
000062  4c15              LDR      r4,|L33.184|
000064  2000              MOVS     r0,#0
000066  22ff              MOVS     r2,#0xff              ;398
000068  7827              LDRB     r7,[r4,#0]  ; MIPI_READ_DATA
;;;411    		{
;;;412    			ID_OK = 0;
00006a  4914              LDR      r1,|L33.188|
;;;413    			FontR = 0; FontG = 255; FontB = 0;
00006c  4b14              LDR      r3,|L33.192|
00006e  f8dfc054          LDR      r12,|L33.196|
000072  4e15              LDR      r6,|L33.200|
000074  2f03              CMP      r7,#3                 ;410
000076  d018              BEQ      |L33.170|
;;;414    		//		LCD_DisplayStringLine_A( 10 ,800,"otp power OK");
;;;415    		}
;;;416    		else
;;;417    		{
;;;418    			ID_OK = 1;
000078  728d              STRB     r5,[r1,#0xa]
;;;419    			FontR = 255; FontG = 0; FontB = 0;
00007a  701a              STRB     r2,[r3,#0]
00007c  f88c0000          STRB     r0,[r12,#0]
000080  7030              STRB     r0,[r6,#0]
;;;420    			LCD_DisplayStringLine(100,700,"otp  power");
000082  a212              ADR      r2,|L33.204|
000084  f44f712f          MOV      r1,#0x2bc
000088  2064              MOVS     r0,#0x64
00008a  f7fffffe          BL       LCD_DisplayStringLine
;;;421    			SHOW_IC_VALUE_A(300,700,MIPI_READ_DATA[0]);
00008e  7822              LDRB     r2,[r4,#0]  ; MIPI_READ_DATA
000090  f44f712f          MOV      r1,#0x2bc
000094  f44f7096          MOV      r0,#0x12c
000098  f7fffffe          BL       SHOW_IC_VALUE_A
;;;422    			LCD_DisplayStringLine_A( 50 ,800,"otp power NG");
00009c  a20e              ADR      r2,|L33.216|
00009e  f44f7148          MOV      r1,#0x320
0000a2  2032              MOVS     r0,#0x32
0000a4  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L33.168|
;;;423    			while(1);
0000a8  e7fe              B        |L33.168|
                  |L33.170|
0000aa  7288              STRB     r0,[r1,#0xa]          ;412
0000ac  7018              STRB     r0,[r3,#0]            ;413
0000ae  f88c2000          STRB     r2,[r12,#0]           ;413
0000b2  7030              STRB     r0,[r6,#0]            ;413
;;;424    		//		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;425    		}
;;;426    		
;;;427    		////	Delay(5);
;;;428    
;;;429    }
0000b4  b003              ADD      sp,sp,#0xc
0000b6  bdf0              POP      {r4-r7,pc}
;;;430    
                          ENDP

                  |L33.184|
                          DCD      ||.bss||
                  |L33.188|
                          DCD      ||.data||
                  |L33.192|
                          DCD      FontR
                  |L33.196|
                          DCD      FontG
                  |L33.200|
                          DCD      FontB
                  |L33.204|
0000cc  6f747020          DCB      "otp  power",0
0000d0  20706f77
0000d4  657200  
0000d7  00                DCB      0
                  |L33.216|
0000d8  6f747020          DCB      "otp power NG",0
0000dc  706f7765
0000e0  72204e47
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.cycle_OTP||, CODE, READONLY, ALIGN=1

                  cycle_OTP PROC
;;;1534   
;;;1535   void cycle_OTP(u8 OTPValue)
000000  b530              PUSH     {r4,r5,lr}
;;;1536   {
000002  b083              SUB      sp,sp,#0xc
;;;1537   
;;;1538   
;;;1539   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x00);
000004  2500              MOVS     r5,#0
000006  e9cd5000          STRD     r5,r0,[sp,#0]
00000a  4604              MOV      r4,r0                 ;1536
00000c  462b              MOV      r3,r5
00000e  22bb              MOVS     r2,#0xbb
000010  2139              MOVS     r1,#0x39
000012  2006              MOVS     r0,#6
000014  9502              STR      r5,[sp,#8]
000016  f7fffffe          BL       MIPI_SPI_Write
;;;1540   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x01);
00001a  2001              MOVS     r0,#1
00001c  9500              STR      r5,[sp,#0]
00001e  e9cd4001          STRD     r4,r0,[sp,#4]
000022  2300              MOVS     r3,#0
000024  22bb              MOVS     r2,#0xbb
000026  2139              MOVS     r1,#0x39
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       MIPI_SPI_Write
;;;1541   	Delay(5);
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       Delay
000034  e9cd5400          STRD     r5,r4,[sp,#0]
;;;1542   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x00);
000038  2300              MOVS     r3,#0
00003a  22bb              MOVS     r2,#0xbb
00003c  2139              MOVS     r1,#0x39
00003e  2006              MOVS     r0,#6
000040  9502              STR      r5,[sp,#8]
000042  f7fffffe          BL       MIPI_SPI_Write
;;;1543   
;;;1544   }
000046  b003              ADD      sp,sp,#0xc
000048  bd30              POP      {r4,r5,pc}
;;;1545   
                          ENDP


                          AREA ||i.initial_OTP||, CODE, READONLY, ALIGN=1

                  initial_OTP PROC
;;;1545   
;;;1546   void initial_OTP(void)
000000  b510              PUSH     {r4,lr}
;;;1547   {
;;;1548   
;;;1549   //	MIPI_SPI_Write(0x06,0x39, 0xB9,0xFF,0x83,0x69);//EXTC Command Set enable register
;;;1550   //
;;;1551   //	OPEN_OTP_Voltage;//Open 7.5V
;;;1552   //	Delay(50);//Wait 500ms for PVSS stable	8369 no delay time
;;;1553   //
;;;1554   ////	MIPI_SPI_Write(0x06,0x39,0xB6,0x2E,0x2E);	//Set VCOM
;;;1555   //	MIPI_SPI_Write(0x06,0x39,0xE9,0xAA,0x55);	//Set OTP
;;;1556   
;;;1557   //-----------------------GIP timing------------------------//
;;;1558   //	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,0xB3,0x00);
;;;1559   //	MIPI_SPI_Write(0x30,0x39,0xBB,0x00,0x00,0xB3,0x01);
;;;1560   //	Delay(5);
;;;1561   //	MIPI_SPI_Write(0x30,0x39,0xBB,0x00,0x00,0xB3,0x00);
;;;1562   
;;;1563   
;;;1564   
;;;1565   cycle_OTP(0xB0);
000002  20b0              MOVS     r0,#0xb0
000004  f7fffffe          BL       cycle_OTP
;;;1566   cycle_OTP(0xB1);
000008  20b1              MOVS     r0,#0xb1
00000a  f7fffffe          BL       cycle_OTP
;;;1567   cycle_OTP(0xB2);
00000e  20b2              MOVS     r0,#0xb2
000010  f7fffffe          BL       cycle_OTP
;;;1568   cycle_OTP(0xB3);
000014  20b3              MOVS     r0,#0xb3
000016  f7fffffe          BL       cycle_OTP
;;;1569   
;;;1570   //cycle_OTP(0x1C);
;;;1571   //cycle_OTP(0x1D);
;;;1572   
;;;1573   cycle_OTP(0x31);
00001a  2031              MOVS     r0,#0x31
00001c  f7fffffe          BL       cycle_OTP
;;;1574   cycle_OTP(0x32);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       cycle_OTP
;;;1575   cycle_OTP(0x33);
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       cycle_OTP
;;;1576   cycle_OTP(0x34);
00002c  2034              MOVS     r0,#0x34
00002e  f7fffffe          BL       cycle_OTP
;;;1577   cycle_OTP(0x35);
000032  2035              MOVS     r0,#0x35
000034  f7fffffe          BL       cycle_OTP
;;;1578   cycle_OTP(0x36);
000038  2036              MOVS     r0,#0x36
00003a  f7fffffe          BL       cycle_OTP
;;;1579   cycle_OTP(0x37);
00003e  2037              MOVS     r0,#0x37
000040  f7fffffe          BL       cycle_OTP
;;;1580   cycle_OTP(0x38);
000044  2038              MOVS     r0,#0x38
000046  f7fffffe          BL       cycle_OTP
;;;1581   cycle_OTP(0x39);
00004a  2039              MOVS     r0,#0x39
00004c  f7fffffe          BL       cycle_OTP
;;;1582   cycle_OTP(0x3A);
000050  203a              MOVS     r0,#0x3a
000052  f7fffffe          BL       cycle_OTP
;;;1583   cycle_OTP(0x3B);
000056  203b              MOVS     r0,#0x3b
000058  f7fffffe          BL       cycle_OTP
;;;1584   cycle_OTP(0x3C);
00005c  203c              MOVS     r0,#0x3c
00005e  f7fffffe          BL       cycle_OTP
;;;1585   cycle_OTP(0x3D);
000062  203d              MOVS     r0,#0x3d
000064  f7fffffe          BL       cycle_OTP
;;;1586   cycle_OTP(0x3E);
000068  203e              MOVS     r0,#0x3e
00006a  f7fffffe          BL       cycle_OTP
;;;1587   cycle_OTP(0x3F);
00006e  203f              MOVS     r0,#0x3f
000070  f7fffffe          BL       cycle_OTP
;;;1588   
;;;1589   cycle_OTP(0x40);
000074  2040              MOVS     r0,#0x40
000076  f7fffffe          BL       cycle_OTP
;;;1590   cycle_OTP(0x41);
00007a  2041              MOVS     r0,#0x41
00007c  f7fffffe          BL       cycle_OTP
;;;1591   cycle_OTP(0x42);
000080  2042              MOVS     r0,#0x42
000082  f7fffffe          BL       cycle_OTP
;;;1592   cycle_OTP(0x43);
000086  2043              MOVS     r0,#0x43
000088  f7fffffe          BL       cycle_OTP
;;;1593   cycle_OTP(0x44);
00008c  2044              MOVS     r0,#0x44
00008e  f7fffffe          BL       cycle_OTP
;;;1594   cycle_OTP(0x45);
000092  2045              MOVS     r0,#0x45
000094  f7fffffe          BL       cycle_OTP
;;;1595   cycle_OTP(0x46);
000098  2046              MOVS     r0,#0x46
00009a  f7fffffe          BL       cycle_OTP
;;;1596   //cycle_OTP(0x47);
;;;1597   cycle_OTP(0x48);
00009e  2048              MOVS     r0,#0x48
0000a0  f7fffffe          BL       cycle_OTP
;;;1598   cycle_OTP(0x49);
0000a4  2049              MOVS     r0,#0x49
0000a6  f7fffffe          BL       cycle_OTP
;;;1599   cycle_OTP(0x4A);
0000aa  204a              MOVS     r0,#0x4a
0000ac  f7fffffe          BL       cycle_OTP
;;;1600   
;;;1601   cycle_OTP(0x78);
0000b0  2078              MOVS     r0,#0x78
0000b2  f7fffffe          BL       cycle_OTP
;;;1602   cycle_OTP(0x79);
0000b6  2079              MOVS     r0,#0x79
0000b8  f7fffffe          BL       cycle_OTP
;;;1603   cycle_OTP(0x7A);
0000bc  207a              MOVS     r0,#0x7a
0000be  f7fffffe          BL       cycle_OTP
;;;1604   cycle_OTP(0x7B);
0000c2  207b              MOVS     r0,#0x7b
0000c4  f7fffffe          BL       cycle_OTP
;;;1605   cycle_OTP(0x7C);
0000c8  207c              MOVS     r0,#0x7c
0000ca  f7fffffe          BL       cycle_OTP
;;;1606   cycle_OTP(0x7D);
0000ce  207d              MOVS     r0,#0x7d
0000d0  f7fffffe          BL       cycle_OTP
;;;1607   cycle_OTP(0x7E);
0000d4  207e              MOVS     r0,#0x7e
0000d6  f7fffffe          BL       cycle_OTP
;;;1608   cycle_OTP(0x7F);
0000da  207f              MOVS     r0,#0x7f
0000dc  f7fffffe          BL       cycle_OTP
;;;1609   
;;;1610   cycle_OTP(0x80);
0000e0  2080              MOVS     r0,#0x80
0000e2  f7fffffe          BL       cycle_OTP
;;;1611   cycle_OTP(0x81);
0000e6  2081              MOVS     r0,#0x81
0000e8  f7fffffe          BL       cycle_OTP
;;;1612   cycle_OTP(0x82);
0000ec  2082              MOVS     r0,#0x82
0000ee  f7fffffe          BL       cycle_OTP
;;;1613   cycle_OTP(0x83);
0000f2  2083              MOVS     r0,#0x83
0000f4  f7fffffe          BL       cycle_OTP
;;;1614   cycle_OTP(0x84);
0000f8  2084              MOVS     r0,#0x84
0000fa  f7fffffe          BL       cycle_OTP
;;;1615   cycle_OTP(0x85);
0000fe  2085              MOVS     r0,#0x85
000100  f7fffffe          BL       cycle_OTP
;;;1616   cycle_OTP(0x86);
000104  2086              MOVS     r0,#0x86
000106  f7fffffe          BL       cycle_OTP
;;;1617   cycle_OTP(0x87);
00010a  2087              MOVS     r0,#0x87
00010c  f7fffffe          BL       cycle_OTP
;;;1618   cycle_OTP(0x88);
000110  2088              MOVS     r0,#0x88
000112  f7fffffe          BL       cycle_OTP
;;;1619   cycle_OTP(0x89);
000116  2089              MOVS     r0,#0x89
000118  f7fffffe          BL       cycle_OTP
;;;1620   cycle_OTP(0x8A);
00011c  208a              MOVS     r0,#0x8a
00011e  f7fffffe          BL       cycle_OTP
;;;1621   cycle_OTP(0x8B);
000122  208b              MOVS     r0,#0x8b
000124  f7fffffe          BL       cycle_OTP
;;;1622   cycle_OTP(0x8C);
000128  208c              MOVS     r0,#0x8c
00012a  f7fffffe          BL       cycle_OTP
;;;1623   cycle_OTP(0x8D);
00012e  208d              MOVS     r0,#0x8d
000130  f7fffffe          BL       cycle_OTP
;;;1624   cycle_OTP(0x8E);
000134  208e              MOVS     r0,#0x8e
000136  f7fffffe          BL       cycle_OTP
;;;1625   cycle_OTP(0x8F);
00013a  208f              MOVS     r0,#0x8f
00013c  f7fffffe          BL       cycle_OTP
;;;1626   
;;;1627   cycle_OTP(0x90);
000140  2090              MOVS     r0,#0x90
000142  f7fffffe          BL       cycle_OTP
;;;1628   cycle_OTP(0x91);
000146  2091              MOVS     r0,#0x91
000148  f7fffffe          BL       cycle_OTP
;;;1629   cycle_OTP(0x92);
00014c  2092              MOVS     r0,#0x92
00014e  f7fffffe          BL       cycle_OTP
;;;1630   cycle_OTP(0x93);
000152  2093              MOVS     r0,#0x93
000154  f7fffffe          BL       cycle_OTP
;;;1631   cycle_OTP(0x94);
000158  2094              MOVS     r0,#0x94
00015a  f7fffffe          BL       cycle_OTP
;;;1632   cycle_OTP(0x95);
00015e  2095              MOVS     r0,#0x95
000160  f7fffffe          BL       cycle_OTP
;;;1633   cycle_OTP(0x96);
000164  2096              MOVS     r0,#0x96
000166  f7fffffe          BL       cycle_OTP
;;;1634   cycle_OTP(0x97);
00016a  2097              MOVS     r0,#0x97
00016c  f7fffffe          BL       cycle_OTP
;;;1635   cycle_OTP(0x98);
000170  2098              MOVS     r0,#0x98
000172  f7fffffe          BL       cycle_OTP
;;;1636   cycle_OTP(0x99);
000176  2099              MOVS     r0,#0x99
000178  f7fffffe          BL       cycle_OTP
;;;1637   cycle_OTP(0x9A);
00017c  209a              MOVS     r0,#0x9a
00017e  f7fffffe          BL       cycle_OTP
;;;1638   cycle_OTP(0x9B);
000182  209b              MOVS     r0,#0x9b
000184  f7fffffe          BL       cycle_OTP
;;;1639   cycle_OTP(0x9C);
000188  209c              MOVS     r0,#0x9c
00018a  f7fffffe          BL       cycle_OTP
;;;1640   cycle_OTP(0x9D);
00018e  209d              MOVS     r0,#0x9d
000190  f7fffffe          BL       cycle_OTP
;;;1641   cycle_OTP(0x9E);
000194  209e              MOVS     r0,#0x9e
000196  f7fffffe          BL       cycle_OTP
;;;1642   cycle_OTP(0x9F);
00019a  209f              MOVS     r0,#0x9f
00019c  f7fffffe          BL       cycle_OTP
;;;1643   
;;;1644   cycle_OTP(0xA0);
0001a0  20a0              MOVS     r0,#0xa0
0001a2  f7fffffe          BL       cycle_OTP
;;;1645   cycle_OTP(0xA1);
0001a6  20a1              MOVS     r0,#0xa1
0001a8  f7fffffe          BL       cycle_OTP
;;;1646   cycle_OTP(0xA2);
0001ac  20a2              MOVS     r0,#0xa2
0001ae  f7fffffe          BL       cycle_OTP
;;;1647   cycle_OTP(0xA3);
0001b2  20a3              MOVS     r0,#0xa3
0001b4  f7fffffe          BL       cycle_OTP
;;;1648   cycle_OTP(0xA4);
0001b8  20a4              MOVS     r0,#0xa4
0001ba  f7fffffe          BL       cycle_OTP
;;;1649   cycle_OTP(0xA5);
0001be  20a5              MOVS     r0,#0xa5
0001c0  f7fffffe          BL       cycle_OTP
;;;1650   cycle_OTP(0xA6);
0001c4  20a6              MOVS     r0,#0xa6
0001c6  f7fffffe          BL       cycle_OTP
;;;1651   cycle_OTP(0xA7);
0001ca  20a7              MOVS     r0,#0xa7
0001cc  f7fffffe          BL       cycle_OTP
;;;1652   cycle_OTP(0xA8);
0001d0  20a8              MOVS     r0,#0xa8
0001d2  f7fffffe          BL       cycle_OTP
;;;1653   cycle_OTP(0xA9);
0001d6  20a9              MOVS     r0,#0xa9
0001d8  f7fffffe          BL       cycle_OTP
;;;1654   cycle_OTP(0xAA);
0001dc  20aa              MOVS     r0,#0xaa
0001de  f7fffffe          BL       cycle_OTP
;;;1655   cycle_OTP(0xAB);
0001e2  20ab              MOVS     r0,#0xab
0001e4  f7fffffe          BL       cycle_OTP
;;;1656   cycle_OTP(0xAC);
0001e8  20ac              MOVS     r0,#0xac
0001ea  f7fffffe          BL       cycle_OTP
;;;1657   cycle_OTP(0xAD);
0001ee  20ad              MOVS     r0,#0xad
0001f0  f7fffffe          BL       cycle_OTP
;;;1658   cycle_OTP(0xAE);
0001f4  20ae              MOVS     r0,#0xae
0001f6  f7fffffe          BL       cycle_OTP
;;;1659   cycle_OTP(0xAF);
0001fa  e8bd4010          POP      {r4,lr}
0001fe  20af              MOVS     r0,#0xaf
000200  f7ffbffe          B.W      cycle_OTP
;;;1660   
;;;1661   
;;;1662   
;;;1663   
;;;1664   //	MIPI_SPI_Write(0x06,0x39,0xE9,0x00,0x00);	//Set OTP
;;;1665   //
;;;1666   //	CLOSE_OTP_Voltage;//Close 7.5V 
;;;1667   //	Delay(10);//Wait 10ms	8369 no delay time
;;;1668   	
;;;1669   //	SSD1963Command_8(0xBa); 
;;;1670   //	SSD1963Data_8(0x0E);   //RESET=0
;;;1671   //	Delay(12);
;;;1672   //	SSD1963Command_8(0xBa); 
;;;1673   //	SSD1963Data_8(0x0F);   //RESET=1 
;;;1674   //	Delay(12);
;;;1675   	
;;;1676   //	SSD1963INITSSD2825();
;;;1677   //	OTP_initial();
;;;1678   
;;;1679   
;;;1680   	}
;;;1681   
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;116    /*******************************************************************************/
;;;117    int main(void)
000000  b084              SUB      sp,sp,#0x10
000002  f7fffffe          BL       RCC_DeInit
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4ca1              LDR      r4,|L36.664|
000014  2801              CMP      r0,#1
000016  7360              STRB     r0,[r4,#0xd]
000018  d124              BNE      |L36.100|
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L36.76|
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L36.76|
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L36.92|
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L36.92|
                  |L36.100|
000064  2101              MOVS     r1,#1
000066  f2440004          MOV      r0,#0x4004
00006a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;118    {   // uint testf;		//only for test 2014.1.27
;;;119    //	u8 mm=1;
;;;120    //	u32 rand_val;
;;;121    	u32 sdcap=1;
;;;122    	u8 READ_ID = 0;
;;;123    	u16 mm_KEYB1 = 1;
;;;124    
;;;125    //	u8 temp[9];
;;;126    
;;;127      #ifdef DEBUG
;;;128      debug();
;;;129      #endif
;;;130      /* System Clocks Configuration */
;;;131    	RCC_Configuration();	 	
;;;132      /* NVIC Configuration */
;;;133    	NVIC_Configuration();   //中断管理初始化   
00006e  f7fffffe          BL       NVIC_Configuration
000072  2004              MOVS     r0,#4
000074  f7fffffe          BL       SysTick_CLKSourceConfig
000078  4888              LDR      r0,|L36.668|
00007a  f7fffffe          BL       SysTick_SetReload
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       SysTick_ITConfig
000084  2001              MOVS     r0,#1
000086  f7fffffe          BL       SysTick_CounterCmd
;;;134    	SysTick_Config();		    //延时用  	
;;;135    	  
;;;136      //-------------------------------------------------
;;;137      /* Initialize the LCD */
;;;138    	STM32_SSD1963_Init();
00008a  f7fffffe          BL       STM32_SSD1963_Init
00008e  2101              MOVS     r1,#1
000090  2015              MOVS     r0,#0x15
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
000096  2040              MOVS     r0,#0x40
000098  f8ad0000          STRH     r0,[sp,#0]
00009c  2548              MOVS     r5,#0x48
00009e  f88d5003          STRB     r5,[sp,#3]
0000a2  4669              MOV      r1,sp
0000a4  487e              LDR      r0,|L36.672|
0000a6  f7fffffe          BL       GPIO_Init
0000aa  2080              MOVS     r0,#0x80
0000ac  f8ad0000          STRH     r0,[sp,#0]
0000b0  4e7c              LDR      r6,|L36.676|
0000b2  f88d5003          STRB     r5,[sp,#3]
0000b6  4669              MOV      r1,sp
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       GPIO_Init
0000be  15b1              ASRS     r1,r6,#22
0000c0  f8ad1000          STRH     r1,[sp,#0]
0000c4  f88d5003          STRB     r5,[sp,#3]
0000c8  4669              MOV      r1,sp
0000ca  4630              MOV      r0,r6
0000cc  f7fffffe          BL       GPIO_Init
;;;139    
;;;140    	KEYGPIO_Init();
;;;141    	Sensor_GPIO_Config();
0000d0  f7fffffe          BL       Sensor_GPIO_Config
;;;142    	
;;;143    
;;;144    	
;;;145    ///SD  卡初始化部分。
;;;146    	if(SDConfigFlag == 0)
0000d4  7860              LDRB     r0,[r4,#1]  ; SDConfigFlag
;;;147    	{
;;;148    		SDShowFlag=1;
;;;149    	
;;;150    		Status =SD_InitAndConfig();  /*设置SD接口,初始化SD卡*/
;;;151    		sdcap=sd_Capacity>>20; //(sdcap=sd_Capacity/1024/1024)
;;;152    		All_Color(255,255,255)   ;
;;;153    
;;;154    			if(sdcap == 0)
;;;155    			{
;;;156    				FontR = 255;
0000d6  f8df81d0          LDR      r8,|L36.680|
;;;157    				FontB = 20;
0000da  4e74              LDR      r6,|L36.684|
;;;158    				FontG = 20;
0000dc  4f74              LDR      r7,|L36.688|
0000de  f04f0b14          MOV      r11,#0x14             ;157
0000e2  f04f09ff          MOV      r9,#0xff              ;152
0000e6  f04f0a01          MOV      r10,#1                ;121
0000ea  2800              CMP      r0,#0                 ;146
0000ec  d07e              BEQ      |L36.492|
                  |L36.238|
;;;159    //				LCD_DisplayStringLine_A(0,Line0,"SD ERROR!");	
;;;160    
;;;161    				FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
;;;162    //				while(1)
;;;163    //				{
;;;164    //					DelayKEY(100);
;;;165    //				}
;;;166    			}
;;;167    			else
;;;168    			{
;;;169    				FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
;;;170    				SDConfigFlag = 1;
;;;171    					
;;;172    			}
;;;173    	}
;;;174    
;;;175    
;;;176    	FontR = FontG = FontB = 255;			   //屏蔽字符
0000ee  f8869000          STRB     r9,[r6,#0]
0000f2  f8879000          STRB     r9,[r7,#0]
0000f6  f8889000          STRB     r9,[r8,#0]
;;;177    	  	if (FAT_Init())	//初始化FAT文件系统
0000fa  f7fffffe          BL       FAT_Init
0000fe  b150              CBZ      r0,|L36.278|
;;;178    		  {	
;;;179    		  		All_Color(255,255,255)   ;
000100  22ff              MOVS     r2,#0xff
000102  4611              MOV      r1,r2
000104  4610              MOV      r0,r2
000106  f7fffffe          BL       All_Color
;;;180    				FontR = 255;
00010a  f8889000          STRB     r9,[r8,#0]
;;;181    				FontB = 20;
00010e  f886b000          STRB     r11,[r6,#0]
;;;182    				FontG = 20;
000112  f887b000          STRB     r11,[r7,#0]
                  |L36.278|
;;;183    //				LCD_DisplayStringLine_A(0,Line0,"SD ERROR!");
;;;184    //				while(1)
;;;185    				{
;;;186    //					DelayKEY(100);
;;;187    				}
;;;188        
;;;189    		  }
;;;190              FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
000116  f8869000          STRB     r9,[r6,#0]
00011a  f8879000          STRB     r9,[r7,#0]
00011e  f8889000          STRB     r9,[r8,#0]
;;;191    		LCD_DisplayStringLine(0,Line2,"Waiting....");
000122  a264              ADR      r2,|L36.692|
000124  2130              MOVS     r1,#0x30
000126  2000              MOVS     r0,#0
000128  f7fffffe          BL       LCD_DisplayStringLine
;;;192    		
;;;193    			SearchInit();
00012c  f7fffffe          BL       SearchInit
;;;194    
;;;195    		//////////////////show the project ----------------------------------------------------
;;;196    		
;;;197    
;;;198    
;;;199    
;;;200    
;;;201    	     
;;;202    	  	FontR = FontG = FontB = 0;
000130  2500              MOVS     r5,#0
000132  7035              STRB     r5,[r6,#0]
000134  703d              STRB     r5,[r7,#0]
000136  f8885000          STRB     r5,[r8,#0]
;;;203    		LCD_DisplayStringLine_A(10,160,"TFT035_A");	  /////2014/4/4   /////2014/4/4  M1461A0_C
00013a  a261              ADR      r2,|L36.704|
00013c  21a0              MOVS     r1,#0xa0
00013e  200a              MOVS     r0,#0xa
000140  f7fffffe          BL       LCD_DisplayStringLine_A
;;;204    //		LCD_DisplayStringLine_A(30,360,"FGA7_20160426");
;;;205    		DelayKEY(100);
000144  2064              MOVS     r0,#0x64
000146  f7fffffe          BL       DelayKEY
;;;206    //		VCOM_GET();
;;;207    		
;;;208    		
;;;209    	FontR = FontG = FontB = 255;			   //屏蔽字符
00014a  f8869000          STRB     r9,[r6,#0]
00014e  f8879000          STRB     r9,[r7,#0]
000152  f8889000          STRB     r9,[r8,#0]
;;;210    	 
;;;211    
;;;212    		SDShowTimes = 0;
000156  70e5              STRB     r5,[r4,#3]
;;;213    
;;;214    		while (SDShowFlag) //开始BMP文件显示
000158  78a0              LDRB     r0,[r4,#2]  ; SDShowFlag
00015a  b128              CBZ      r0,|L36.360|
;;;215    		{	  
;;;216    		 Disp_BMP() ;
00015c  f7fffffe          BL       Disp_BMP
;;;217    		  Delay(1);
000160  2001              MOVS     r0,#1
000162  f7fffffe          BL       Delay
;;;218    		  SDShowFlag = 0;	
000166  70a5              STRB     r5,[r4,#2]
                  |L36.360|
;;;219    		}				   
;;;220    	
;;;221    //	ID_CHECK_A(10,100);  /////check ID ,if ID NG,,while(1);  if ID ok,DO nothing..	
;;;222    	
;;;223    	FontR = FontG = FontB = 0;			   //显示字符
000168  7035              STRB     r5,[r6,#0]
00016a  703d              STRB     r5,[r7,#0]
00016c  f8885000          STRB     r5,[r8,#0]
;;;224    
;;;225    
;;;226    	 
;;;227    		
;;;228    //	sdcap = KEYA7;
;;;229    
;;;230    
;;;231    ////	while(sdcap!=0)
;;;232    //	
;;;233    //	{sdcap = KEYA7;}
;;;234    
;;;235    //		 
;;;236    //		   if((sdcap==0)||(OTP_TIMES_BEFORE<=0))
;;;237    //		   {	
;;;238    //		   		Flicker_sub_pixel() ;	
;;;239    //			   ////////Re光感板是否放置到A定位置。
;;;240    //					sdcap = KEYA8;
;;;241    //					while(sdcap != 0)	
;;;242    //					{	
;;;243    //						LCD_DisplayStringLine(20,100,"Adjust sensor");	
;;;244    //						Delay(1);
;;;245    //						sdcap = KEYA8;	
;;;246    //					}
;;;247    
;;;248    //				Flicker_sub_pixel() ;
;;;249    //				LCD_WriteArea(3,20,10,790,255,0,0);		   ////start auto otp flow
;;;250    //		   		I2C_DATAL_COMPAREX();
;;;251    //				LCD_WriteArea(3,20,10,790,0,255,0);			  ////to show the best flicker。。。
;;;252    //				DelayKEY(1);
;;;253    //				Flicker_sub_pixel();	
;;;254    //				DelayKEY(1);
;;;255    //				if(DATA_SUM1[count2] <= 350)			 ///for check OTP is OK or NG....		 96
;;;256    //				{
;;;257    //						if(DATA_SUM1[count2] >= 5)
;;;258    //						{
;;;259    //							DelayKEY(1);
;;;260    //							sdcap = 1;
;;;261    //							LCD_CS(1);
;;;262    //							Delay(10);	
;;;263    //							sdcap = KEYA7;
;;;264    ////						    check_power();	   	 	Delay(150);	
;;;265    ////							sdcap = 0;
;;;266    ////							if(sdcap == 0)
;;;267    //						    {
;;;268    //								
;;;269    //								aat = 1;
;;;270    //								MTP_ID();
;;;271    //								FontR = FontG = FontB = 0;
;;;272    //					
;;;273    ////								Soft_reset();
;;;274    //					//			OTP_FLAG = 0;
;;;275    //								aat = 0;
;;;276    //							}
;;;277    //							LCD_CS(0);
;;;278    //							Delay(10);
;;;279    //							Soft_reset();
;;;280    //						    Flicker_sub_pixel();								
;;;281    //							FontR = 50; FontG = 255; FontB = 50;
;;;282    
;;;283    //							VCOM_GET();
;;;284    //							sdcap= MIPI_READ_DATA[4];
;;;285    //							if(sdcap != VCOMDC1)
;;;286    //							{
;;;287    //								OTP_ERROR(); while(1);
;;;288    //							}
;;;289    //							else
;;;290    //							{
;;;291    //								LCD_DisplayStringLine(20,100,"Flicker OTP ok");		
;;;292    //							}
;;;293    //							FontR = 255; FontG = 0; FontB = 0;
;;;294    //							LCD_DisplayStringLine(20,130,"Check flicker again!"); 	DelayKEY(100);
;;;295    //							
;;;296    //							FontR = 0; FontG = 0; FontB = 0;
;;;297    //							
;;;298    //						//	while(1);
;;;299    
;;;300    //						}
;;;301    //						else	   //////////if VCOM value not found perfect,goto error
;;;302    //						{
;;;303    //							OTP_ERROR(); while(1);
;;;304    //						}
;;;305    //				}
;;;306    //				else	   //////////if VCOM value not found perfect,goto error
;;;307    //				{
;;;308    //					OTP_ERROR(); while(1);
;;;309    //				}
;;;310    //				
;;;311    //				
;;;312    //		   }
;;;313    //	else
;;;314    //	{
;;;315    //		Soft_reset();    ///////复位后使用客户初始化code，以便拦检OTP漏烧产品。
;;;316    //	}
;;;317        Flicker_PIXEL();
000170  f7fffffe          BL       Flicker_PIXEL
;;;318        Flicker_sub_pixel() ;
000174  f7fffffe          BL       Flicker_sub_pixel
;;;319    	KEY_adjust();
000178  f7fffffe          BL       KEY_adjust
00017c  f8df814c          LDR      r8,|L36.716|
                  |L36.384|
;;;320    //	Flicker_PIXEL();
;;;321    //	showid_vcom()	;								Delay(150);			mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;322    
;;;323    
;;;324    LCDTest:
;;;325    	
;;;326    		   	All_Color(255,0,0)   ; 							DelayKEY(100);
000180  2200              MOVS     r2,#0
000182  4611              MOV      r1,r2
000184  20ff              MOVS     r0,#0xff
000186  f7fffffe          BL       All_Color
00018a  2064              MOVS     r0,#0x64
00018c  f7fffffe          BL       DelayKEY
;;;327    //
;;;328    /////////*-------enter sleep mode------- */ 
;;;329    //////  	enter_sleep_mode( ) ;
;;;330    //////	DelayKEY(250);
;;;331    //////	exit_sleep_mode( );
;;;332    //////*-------exit sleep mode------- */
;;;333    ////
;;;334      	All_Color(0,255,0)   ;					  		DelayKEY(100);
000190  2200              MOVS     r2,#0
000192  21ff              MOVS     r1,#0xff
000194  4610              MOV      r0,r2
000196  f7fffffe          BL       All_Color
00019a  2064              MOVS     r0,#0x64
00019c  f7fffffe          BL       DelayKEY
;;;335    	All_Color(0,0,255)   ;					  		DelayKEY(100);
0001a0  2100              MOVS     r1,#0
0001a2  22ff              MOVS     r2,#0xff
0001a4  4608              MOV      r0,r1
0001a6  f7fffffe          BL       All_Color
0001aa  2064              MOVS     r0,#0x64
0001ac  f7fffffe          BL       DelayKEY
;;;336    	All_Color(255,255,255)   ;				  	DelayKEY(100);
0001b0  22ff              MOVS     r2,#0xff
0001b2  4611              MOV      r1,r2
0001b4  4610              MOV      r0,r2
0001b6  f7fffffe          BL       All_Color
0001ba  2064              MOVS     r0,#0x64
0001bc  f7fffffe          BL       DelayKEY
;;;337    	LCD_WriteArea(1,XDP-2,1,YDP-2,0,0,0);		DelayKEY(100);
0001c0  2201              MOVS     r2,#1
0001c2  9500              STR      r5,[sp,#0]
0001c4  9501              STR      r5,[sp,#4]
0001c6  23ee              MOVS     r3,#0xee
0001c8  f44f719f          MOV      r1,#0x13e
0001cc  4610              MOV      r0,r2
0001ce  9502              STR      r5,[sp,#8]
0001d0  f7fffffe          BL       LCD_WriteArea
0001d4  2064              MOVS     r0,#0x64
0001d6  f7fffffe          BL       DelayKEY
;;;338    	All_Color(0,0,0)   ;				  		DelayKEY(100);
0001da  2200              MOVS     r2,#0
0001dc  4611              MOV      r1,r2
0001de  4610              MOV      r0,r2
0001e0  f7fffffe          BL       All_Color
0001e4  2064              MOVS     r0,#0x64
0001e6  f7fffffe          BL       DelayKEY
;;;339        All_Color(60,60,60)   ;				  		DelayKEY(100);
0001ea  e000              B        |L36.494|
                  |L36.492|
0001ec  e033              B        |L36.598|
                  |L36.494|
0001ee  223c              MOVS     r2,#0x3c
0001f0  4611              MOV      r1,r2
0001f2  4610              MOV      r0,r2
0001f4  f7fffffe          BL       All_Color
0001f8  2064              MOVS     r0,#0x64
0001fa  f7fffffe          BL       DelayKEY
;;;340    	All_Color(127,127,127)   ;				  		DelayKEY(100);
0001fe  227f              MOVS     r2,#0x7f
000200  4611              MOV      r1,r2
000202  4610              MOV      r0,r2
000204  f7fffffe          BL       All_Color
000208  2064              MOVS     r0,#0x64
00020a  f7fffffe          BL       DelayKEY
;;;341        RGB_color();                                    DelayKEY(100);
00020e  f7fffffe          BL       RGB_color
000212  2064              MOVS     r0,#0x64
000214  f7fffffe          BL       DelayKEY
;;;342        Flicker_PIXEL();                                DelayKEY(100);
000218  f7fffffe          BL       Flicker_PIXEL
00021c  2064              MOVS     r0,#0x64
00021e  f7fffffe          BL       DelayKEY
000222  f884a002          STRB     r10,[r4,#2]
000226  f884a003          STRB     r10,[r4,#3]
;;;343    	SDPicShow(1);				 			   		DelayKEY(80);	
00022a  2701              MOVS     r7,#1
00022c  2600              MOVS     r6,#0
00022e  f8a8a000          STRH     r10,[r8,#0]
                  |L36.562|
000232  f7fffffe          BL       Disp_BMP
000236  2001              MOVS     r0,#1
000238  f7fffffe          BL       DelayKEY
00023c  f8b80000          LDRH     r0,[r8,#0]  ; image_count
000240  4287              CMP      r7,r0
000242  bf98              IT       LS
000244  2e01              CMPLS    r6,#1
000246  d803              BHI      |L36.592|
000248  1c70              ADDS     r0,r6,#1
00024a  f8a87000          STRH     r7,[r8,#0]
00024e  b2c6              UXTB     r6,r0
                  |L36.592|
000250  b1de              CBZ      r6,|L36.650|
000252  70a5              STRB     r5,[r4,#2]
000254  e01c              B        |L36.656|
                  |L36.598|
000256  f884a002          STRB     r10,[r4,#2]           ;148
00025a  f7fffffe          BL       SD_InitAndConfig
00025e  7020              STRB     r0,[r4,#0]            ;150
000260  6a60              LDR      r0,[r4,#0x24]         ;151  ; sd_Capacity
000262  22ff              MOVS     r2,#0xff              ;152
000264  0d05              LSRS     r5,r0,#20             ;151
000266  4611              MOV      r1,r2                 ;152
000268  4610              MOV      r0,r2                 ;152
00026a  f7fffffe          BL       All_Color
00026e  2d00              CMP      r5,#0                 ;154
000270  bf08              IT       EQ                    ;156
000272  f8889000          STRBEQ   r9,[r8,#0]            ;156
000276  f8869000          STRB     r9,[r6,#0]            ;161
00027a  f8879000          STRB     r9,[r7,#0]            ;161
00027e  bf1c              ITT      NE                    ;169
000280  f8889000          STRBNE   r9,[r8,#0]            ;169
000284  f884a001          STRBNE   r10,[r4,#1]           ;170
000288  e731              B        |L36.238|
                  |L36.650|
00028a  78a0              LDRB     r0,[r4,#2]            ;154  ; SDShowFlag
00028c  2800              CMP      r0,#0                 ;154
00028e  d1d0              BNE      |L36.562|
                  |L36.656|
000290  2050              MOVS     r0,#0x50
000292  f7fffffe          BL       DelayKEY
;;;344    
;;;345    
;;;346    		   
;;;347    //	RGB_color();									
;;;348    //	LCD_DisplayStringLine(40,820,"RED");	 LCD_DisplayStringLine(140,820,"GREEN");		LCD_DisplayStringLine(265,820,"BLUE");		  LCD_DisplayStringLine(380,820,"WHITE");
;;;349    //	DelayKEY(80);															mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;350    //	SDPicShow(2);				 			   		Delay(150);			  mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }//SD  1   pic 
;;;351    //	All_Color(255,0,0)   ; 							Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;352    //	All_Color(0,255,0)   ;					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;353    //	All_Color(0,0,255)   ;					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;354    //	All_Color(255,255,255)   ;					   
;;;355    //	LCD_WriteArea(147,147,169,169,160,255,255);				   ////zy暗c	   R160,G210,B0
;;;356    //	LCD_WriteArea(231,231,169,169,255,210,255);
;;;357    //	LCD_WriteArea(311,311,169,169,255,255,0);			  	Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;358    //	All_Color(0,0,0)   ;							
;;;359    //	LCD_WriteArea(147,147,169,169,53,0,0);				   ////zy亮c		 R49,G29,B69
;;;360    //	LCD_WriteArea(231,231,169,169,0,35,0);
;;;361    //	LCD_WriteArea(311,311,169,169,0,0,89);					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;362    // 	SDPicShow(1);				 			   		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   } //SD  1   pic
;;;363    //	Flicker_PIXEL();								Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;364    // 	showid_vcom()	;								Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;365      goto LCDTest;
000296  e773              B        |L36.384|
;;;366    
;;;367    }
;;;368    
                          ENDP

                  |L36.664|
                          DCD      ||.data||
                  |L36.668|
                          DCD      0x00011940
                  |L36.672|
                          DCD      0x40011000
                  |L36.676|
                          DCD      0x40010800
                  |L36.680|
                          DCD      FontR
                  |L36.684|
                          DCD      FontB
                  |L36.688|
                          DCD      FontG
                  |L36.692|
0002b4  57616974          DCB      "Waiting....",0
0002b8  696e672e
0002bc  2e2e2e00
                  |L36.704|
0002c0  54465430          DCB      "TFT035_A",0
0002c4  33355f41
0002c8  00      
0002c9  00                DCB      0
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L36.716|
                          DCD      image_count

                          AREA ||i.showid_vcom||, CODE, READONLY, ALIGN=2

                  showid_vcom PROC
;;;724    
;;;725    void showid_vcom(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;726    {
;;;727    	u8  vcom;
;;;728    
;;;729    	Flicker_PIXEL();		   DelayKEY(1);
000004  f7fffffe          BL       Flicker_PIXEL
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DelayKEY
;;;730    	
;;;731    	
;;;732    	READ_IC_A(0XD9,0x00);
00000e  2100              MOVS     r1,#0
000010  20d9              MOVS     r0,#0xd9
000012  f7fffffe          BL       READ_IC_A
;;;733    	FontR = 0; FontG = 0; FontB = 0;
000016  4e3c              LDR      r6,|L37.264|
000018  4f3c              LDR      r7,|L37.268|
00001a  2500              MOVS     r5,#0
00001c  f8df80f0          LDR      r8,|L37.272|
000020  7035              STRB     r5,[r6,#0]
;;;734    	vcom= MIPI_READ_DATA[0];
000022  f8df90f0          LDR      r9,|L37.276|
000026  703d              STRB     r5,[r7,#0]            ;733
000028  f8885000          STRB     r5,[r8,#0]            ;733
00002c  f8994000          LDRB     r4,[r9,#0]  ; MIPI_READ_DATA
;;;735    	LCD_DisplayStringLine(100,600,"VCOM");
000030  a239              ADR      r2,|L37.280|
000032  f44f7116          MOV      r1,#0x258
000036  2064              MOVS     r0,#0x64
000038  f7fffffe          BL       LCD_DisplayStringLine
;;;736    	SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
00003c  f44f7116          MOV      r1,#0x258
000040  f8992000          LDRB     r2,[r9,#0]  ; MIPI_READ_DATA
000044  1048              ASRS     r0,r1,#1
000046  f7fffffe          BL       SHOW_IC_VALUE_A
;;;737    	
;;;738    	while(ID_CHECK(20,700) == 1)
00004a  f44f712f          MOV      r1,#0x2bc
00004e  2014              MOVS     r0,#0x14
000050  f7fffffe          BL       ID_CHECK
000054  2801              CMP      r0,#1
000056  d126              BNE      |L37.166|
;;;739    	{
;;;740    		READ_ID++;
;;;741    		if(READ_ID >3)
;;;742    		{		while(1);	}
;;;743    		
;;;744    		temp = 1;
;;;745    		temp = KEYA7;
000058  f8dfa0c4          LDR      r10,|L37.288|
00005c  f8df90c4          LDR      r9,|L37.292|
000060  4683              MOV      r11,r0                ;729
                  |L37.98|
000062  f899000c          LDRB     r0,[r9,#0xc]          ;740  ; READ_ID
000066  1c40              ADDS     r0,r0,#1              ;740
000068  b2c0              UXTB     r0,r0                 ;740
00006a  f889000c          STRB     r0,[r9,#0xc]          ;740
00006e  2803              CMP      r0,#3                 ;741
000070  d900              BLS      |L37.116|
                  |L37.114|
000072  e7fe              B        |L37.114|
                  |L37.116|
000074  f8da0000          LDR      r0,[r10,#0]
000078  f0100080          ANDS     r0,r0,#0x80
00007c  f889000b          STRB     r0,[r9,#0xb]
;;;746    		//		temp = 0 ;
;;;747    		
;;;748    		if(temp == 0)
;;;749    		{
;;;750    			aat2 = 0;
;;;751    		//			ENTER_LP_mode();
;;;752    		//			MTP_ID();
;;;753    			aat2 = 1;
000080  bf08              IT       EQ
000082  f8a9b014          STRHEQ   r11,[r9,#0x14]
;;;754    		}
;;;755    		
;;;756    		FontR = FontG = FontB = 0;
000086  f8885000          STRB     r5,[r8,#0]
00008a  703d              STRB     r5,[r7,#0]
00008c  7035              STRB     r5,[r6,#0]
;;;757    		Soft_reset();
00008e  f7fffffe          BL       Soft_reset
;;;758    		Delay(10);	
000092  200a              MOVS     r0,#0xa
000094  f7fffffe          BL       Delay
000098  f44f712f          MOV      r1,#0x2bc             ;738
00009c  2014              MOVS     r0,#0x14              ;738
00009e  f7fffffe          BL       ID_CHECK
0000a2  2801              CMP      r0,#1                 ;738
0000a4  d0dd              BEQ      |L37.98|
                  |L37.166|
;;;759    	
;;;760    	}
;;;761    	
;;;762    	Delay(10);						
0000a6  200a              MOVS     r0,#0xa
0000a8  f7fffffe          BL       Delay
;;;763    	//	READ_IC_A(0XD9,0x00);
;;;764    	
;;;765    	//	Delay(10);
;;;766    	//   LCD_DisplayStringLine(100,600,"VCOM");
;;;767    	////   SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
;;;768    	//	SHOW_IC_VALUE_A(300,600,VCOMDC);
;;;769    	////
;;;770    	////  if(VCOMDC== MIPI_READ_DATA[0] )	
;;;771    	////	{
;;;772    	//		LCD_DisplayStringLine_A(50,700,"VCOMDC PASS");
;;;773    	//	}
;;;774    	//	else
;;;775    	//	{
;;;776    	//	
;;;777    	//		LCD_DisplayStringLine_A(50,700,"VCOMDC NG");
;;;778    	//			while(1);
;;;779    	//	}
;;;780    	//		
;;;781    	FontR = FontG = FontB = 0;
0000ac  f8885000          STRB     r5,[r8,#0]
0000b0  703d              STRB     r5,[r7,#0]
0000b2  7035              STRB     r5,[r6,#0]
;;;782    	LCD_DisplayChinese(20,700,cfont,2);
0000b4  2302              MOVS     r3,#2
0000b6  4a1c              LDR      r2,|L37.296|
0000b8  f44f712f          MOV      r1,#0x2bc
0000bc  2014              MOVS     r0,#0x14
0000be  f7fffffe          BL       LCD_DisplayChinese
;;;783    
;;;784    	if(vcom==0x39)
;;;785    	{
;;;786    		FontR =255; FontG =0; FontB = 0;
0000c2  20ff              MOVS     r0,#0xff
0000c4  2c39              CMP      r4,#0x39              ;784
0000c6  d011              BEQ      |L37.236|
;;;787    		LCD_DisplayChinese(270,700,cfont2,2);
;;;788    	}
;;;789    	else
;;;790    	{
;;;791    		FontR =0; FontG =255; FontB = 0;
0000c8  7035              STRB     r5,[r6,#0]
0000ca  7038              STRB     r0,[r7,#0]
0000cc  f8885000          STRB     r5,[r8,#0]
;;;792    		LCD_DisplayChinese(270,700,cfont1,2);
0000d0  2302              MOVS     r3,#2
0000d2  4a16              LDR      r2,|L37.300|
0000d4  f44f712f          MOV      r1,#0x2bc
0000d8  f44f7087          MOV      r0,#0x10e
0000dc  f7fffffe          BL       LCD_DisplayChinese
                  |L37.224|
;;;793    	}
;;;794    	
;;;795    	FontR = FontG = FontB = 0;
0000e0  f8885000          STRB     r5,[r8,#0]
0000e4  703d              STRB     r5,[r7,#0]
0000e6  7035              STRB     r5,[r6,#0]
;;;796    	
;;;797    
;;;798    }
0000e8  e8bd9ff0          POP      {r4-r12,pc}
                  |L37.236|
0000ec  7030              STRB     r0,[r6,#0]            ;786
0000ee  703d              STRB     r5,[r7,#0]            ;786
0000f0  f8885000          STRB     r5,[r8,#0]            ;786
0000f4  2302              MOVS     r3,#2                 ;787
0000f6  4a0e              LDR      r2,|L37.304|
0000f8  f44f712f          MOV      r1,#0x2bc             ;787
0000fc  f44f7087          MOV      r0,#0x10e             ;787
000100  f7fffffe          BL       LCD_DisplayChinese
000104  e7ec              B        |L37.224|
;;;799    
                          ENDP

000106  0000              DCW      0x0000
                  |L37.264|
                          DCD      FontR
                  |L37.268|
                          DCD      FontG
                  |L37.272|
                          DCD      FontB
                  |L37.276|
                          DCD      ||.bss||
                  |L37.280|
000118  56434f4d          DCB      "VCOM",0
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L37.288|
                          DCD      0x40010808
                  |L37.292|
                          DCD      ||.data||
                  |L37.296|
                          DCD      ||.data||+0x28
                  |L37.300|
                          DCD      ||.data||+0x1c
                  |L37.304|
                          DCD      ||.data||+0x20

                          AREA ||i.showid_vcom_A||, CODE, READONLY, ALIGN=2

                  showid_vcom_A PROC
;;;800    
;;;801    void showid_vcom_A(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;802    {
;;;803    	
;;;804    
;;;805    
;;;806       while(ID_CHECK(20,700) == 1)
000004  f44f712f          MOV      r1,#0x2bc
000008  2014              MOVS     r0,#0x14
00000a  f7fffffe          BL       ID_CHECK
;;;807    	{
;;;808    		READ_ID++;
00000e  4d18              LDR      r5,|L38.112|
000010  2801              CMP      r0,#1                 ;806
000012  d118              BNE      |L38.70|
;;;809    		if(READ_ID >3)
;;;810    		{		while(1);	}
;;;811    
;;;812    //		temp = 1;
;;;813    //		temp = KEYA7;
;;;814    //		temp = 0 ;
;;;815    //
;;;816    //		if(temp == 0)
;;;817    //		{
;;;818    //			aat2 = 0;
;;;819    //			ENTER_LP_mode();
;;;820    //			MTP_ID();
;;;821    //			aat2 = 1;
;;;822    //		}
;;;823    
;;;824    		FontR = FontG = FontB = 0;
000014  4e17              LDR      r6,|L38.116|
000016  4f18              LDR      r7,|L38.120|
000018  f8df8060          LDR      r8,|L38.124|
00001c  2400              MOVS     r4,#0                 ;806
                  |L38.30|
00001e  7b28              LDRB     r0,[r5,#0xc]          ;808  ; READ_ID
000020  1c40              ADDS     r0,r0,#1              ;808
000022  b2c0              UXTB     r0,r0                 ;808
000024  7328              STRB     r0,[r5,#0xc]          ;808
000026  2803              CMP      r0,#3                 ;809
000028  d900              BLS      |L38.44|
                  |L38.42|
00002a  e7fe              B        |L38.42|
                  |L38.44|
00002c  7034              STRB     r4,[r6,#0]
00002e  703c              STRB     r4,[r7,#0]
000030  f8884000          STRB     r4,[r8,#0]
;;;825    		Soft_reset();
000034  f7fffffe          BL       Soft_reset
000038  f44f712f          MOV      r1,#0x2bc             ;806
00003c  2014              MOVS     r0,#0x14              ;806
00003e  f7fffffe          BL       ID_CHECK
000042  2801              CMP      r0,#1                 ;806
000044  d0eb              BEQ      |L38.30|
                  |L38.70|
;;;826    
;;;827    
;;;828    	}
;;;829    
;;;830    	Delay(10);						
000046  200a              MOVS     r0,#0xa
000048  f7fffffe          BL       Delay
;;;831    //	READ_IC_A(0XD9,0x00);
;;;832    
;;;833    	Delay(10);
00004c  200a              MOVS     r0,#0xa
00004e  f7fffffe          BL       Delay
;;;834       LCD_DisplayStringLine(100,600,"VCOM");
000052  a20b              ADR      r2,|L38.128|
000054  f44f7116          MOV      r1,#0x258
000058  2064              MOVS     r0,#0x64
00005a  f7fffffe          BL       LCD_DisplayStringLine
;;;835    //   SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
;;;836    	SHOW_IC_VALUE_A(300,600,VCOMDC);
00005e  792a              LDRB     r2,[r5,#4]  ; VCOMDC
000060  e8bd41f0          POP      {r4-r8,lr}
000064  f44f7116          MOV      r1,#0x258
000068  1048              ASRS     r0,r1,#1
00006a  f7ffbffe          B.W      SHOW_IC_VALUE_A
;;;837    //
;;;838    //  if(VCOMDC== MIPI_READ_DATA[0] )	
;;;839    //	{
;;;840    //		LCD_DisplayStringLine_A(50,700,"VCOMDC PASS");
;;;841    //	}
;;;842    //	else
;;;843    //	{
;;;844    //	
;;;845    //		LCD_DisplayStringLine_A(50,700,"VCOMDC NG");
;;;846    //			while(1);
;;;847    //	}
;;;848    //		
;;;849    
;;;850    
;;;851    
;;;852    
;;;853    }
;;;854    
                          ENDP

00006e  0000              DCW      0x0000
                  |L38.112|
                          DCD      ||.data||
                  |L38.116|
                          DCD      FontB
                  |L38.120|
                          DCD      FontG
                  |L38.124|
                          DCD      FontR
                  |L38.128|
000080  56434f4d          DCB      "VCOM",0
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MIPI_READ_DATA
                          %        12
                  SDCardInfo
                          %        80
                  DATA_SUM1
                          %        60
                  SURE
                          %        60

                          AREA ||area_number.41||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.41||, ||.bss||
                  DATA_SUMY
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  Status
000000  2a                DCB      0x2a
                  SDConfigFlag
000001  00                DCB      0x00
                  SDShowFlag
000002  01                DCB      0x01
                  SDShowTimes
000003  01                DCB      0x01
                  VCOMDC
000004  15                DCB      0x15
                  STEP
000005  18                DCB      0x18
                  OTP_VALUE1
000006  00                DCB      0x00
                  OTP_VALUE2
000007  00                DCB      0x00
                  OTP_TIMES
000008  00                DCB      0x00
                  OTP_TIMES_BEFORE
000009  00                DCB      0x00
                  ID_OK
00000a  01                DCB      0x01
                  temp
00000b  01                DCB      0x01
                  READ_ID
00000c  00                DCB      0x00
                  HSEStartUpStatus
00000d  00                DCB      0x00
                  count1
00000e  0000              DCW      0x0000
                  count2
000010  0000              DCW      0x0000
                  aat
000012  0000              DCW      0x0000
                  aat2
000014  0001              DCW      0x0001
                  VCOMDC1
000016  0000              DCW      0x0000
                  TimingDelay
                          DCD      0x00000000
                  cfont1
00001c  11131400          DCB      0x11,0x13,0x14,0x00
                  cfont2
000020  12131400          DCB      0x12,0x13,0x14,0x00
                  sd_Capacity
                          DCD      0x00000000
                  cfont
000028  0d0e0f10          DCB      0x0d,0x0e,0x0f,0x10
00002c  00                DCB      0x00

                          AREA ||area_number.44||, DATA, ALIGN=1

                          EXPORTAS ||area_number.44||, ||.data||
                  vcomdc_value
000000  0000              DCW      0x0000

                          AREA ||area_number.45||, DATA, ALIGN=0

                          EXPORTAS ||area_number.45||, ||.data||
                  VCOM1
000000  15                DCB      0x15

                          AREA ||area_number.46||, DATA, ALIGN=1

                          EXPORTAS ||area_number.46||, ||.data||
                  GPIO_InitStructure
                          DCDU     0x00000000

                  __ARM_use_no_argv EQU 0
