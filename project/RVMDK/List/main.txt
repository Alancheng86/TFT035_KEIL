; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=517 -DVECT_TAB_FLASH --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Decrement_TimingDelay||, CODE, READONLY, ALIGN=2

                  Decrement_TimingDelay PROC
;;;1002   *******************************************************************************/
;;;1003   void Decrement_TimingDelay(void)
000000  4804              LDR      r0,|L1.20|
;;;1004   {
;;;1005     if (TimingDelay != 0x00)
000002  6981              LDR      r1,[r0,#0x18]  ; TimingDelay
000004  2900              CMP      r1,#0                 ;1004
;;;1006     {
;;;1007       TimingDelay--;
;;;1008     }
;;;1009   }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  6981              LDR      r1,[r0,#0x18]         ;1007  ; TimingDelay
00000c  1e49              SUBS     r1,r1,#1              ;1007
00000e  6181              STR      r1,[r0,#0x18]         ;1007  ; TimingDelay
000010  4770              BX       lr
;;;1010   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.data||

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=2

                  Delay PROC
;;;972    *******************************************************************************/
;;;973    void Delay(u32 nCount)				 //////delay  10ms
000000  b510              PUSH     {r4,lr}
;;;974    {
;;;975      TimingDelay = nCount*10;
000002  4c07              LDR      r4,|L2.32|
000004  eb000080          ADD      r0,r0,r0,LSL #2
000008  0040              LSLS     r0,r0,#1
00000a  61a0              STR      r0,[r4,#0x18]  ; TimingDelay
;;;976      /* Enable the SysTick Counter */
;;;977      //SysTick_CounterCmd(SysTick_Counter_Enable);	
;;;978      SysTick_ITConfig(ENABLE);//ENABLE DISABLE		
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       SysTick_ITConfig
                  |L2.18|
;;;979      while(TimingDelay != 0)
000012  69a0              LDR      r0,[r4,#0x18]  ; TimingDelay
000014  2800              CMP      r0,#0
000016  d1fc              BNE      |L2.18|
;;;980      {;;}
;;;981      SysTick_ITConfig(DISABLE);//ENABLE DISABLE 
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      SysTick_ITConfig
;;;982    }
;;;983    
                          ENDP

                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.DelayKEY||, CODE, READONLY, ALIGN=2

                  DelayKEY PROC
;;;1052   
;;;1053   void DelayKEY (u32 k)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1054   { 
000002  b083              SUB      sp,sp,#0xc
000004  0006              MOVS     r6,r0
;;;1055       volatile u16 m=1;
000006  f04f0001          MOV      r0,#1
00000a  f8ad0000          STRH     r0,[sp,#0]
;;;1056   	volatile u32 j;
;;;1057   
;;;1058         for (j=0; j<k; j++)
00000e  f04f0000          MOV      r0,#0
000012  9001              STR      r0,[sp,#4]            ;1054
;;;1059            {  
;;;1060   		 	m=KEYC6;	
;;;1061   			Delay(2);
;;;1062               while(m==0)
;;;1063                 {
;;;1064   			  	m=KEYC6; 
;;;1065   			  	Delay(2);
;;;1066   
;;;1067   			  }            
;;;1068            }	
;;;1069   
;;;1070   }
000014  bf04              ITT      EQ
000016  b003              ADDEQ    sp,sp,#0xc
000018  bdf0              POPEQ    {r4-r7,pc}
00001a  4f14              LDR      r7,|L3.108|
00001c  4c14              LDR      r4,|L3.112|
00001e  2514              MOVS     r5,#0x14              ;1060
                  |L3.32|
000020  68b8              LDR      r0,[r7,#8]            ;1060
000022  f0000040          AND      r0,r0,#0x40           ;1060
000026  f8ad0000          STRH     r0,[sp,#0]            ;1060
00002a  2002              MOVS     r0,#2                 ;1061
00002c  f7fffffe          BL       Delay
000030  f8bd0000          LDRH     r0,[sp,#0]            ;1062
000034  b990              CBNZ     r0,|L3.92|
                  |L3.54|
000036  68b8              LDR      r0,[r7,#8]            ;1064
000038  f0000040          AND      r0,r0,#0x40           ;1064
00003c  f8ad0000          STRH     r0,[sp,#0]            ;1064
000040  61a5              STR      r5,[r4,#0x18]         ;1064  ; TimingDelay
000042  2001              MOVS     r0,#1                 ;1064
000044  f7fffffe          BL       SysTick_ITConfig
                  |L3.72|
000048  69a1              LDR      r1,[r4,#0x18]         ;1064  ; TimingDelay
00004a  2900              CMP      r1,#0                 ;1064
00004c  d1fc              BNE      |L3.72|
00004e  2000              MOVS     r0,#0                 ;1064
000050  f7fffffe          BL       SysTick_ITConfig
000054  f8bd0000          LDRH     r0,[sp,#0]            ;1062
000058  2800              CMP      r0,#0                 ;1062
00005a  d0ec              BEQ      |L3.54|
                  |L3.92|
00005c  9801              LDR      r0,[sp,#4]            ;1058
00005e  1c40              ADDS     r0,r0,#1              ;1058
000060  9001              STR      r0,[sp,#4]            ;1058
000062  42b0              CMP      r0,r6                 ;1058
000064  d3dc              BCC      |L3.32|
000066  b003              ADD      sp,sp,#0xc
000068  bdf0              POP      {r4-r7,pc}
;;;1071   
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      0x40011000
                  |L3.112|
                          DCD      ||.data||

                          AREA ||i.I2C_DATAL_COMPARE||, CODE, READONLY, ALIGN=2

                  I2C_DATAL_COMPARE PROC
;;;1375   }
;;;1376   void I2C_DATAL_COMPARE(void)
000000  f8dfc030          LDR      r12,|L4.52|
;;;1377   {
000004  b430              PUSH     {r4,r5}
;;;1378   		int yy=1,zz=0;
000006  2101              MOVS     r1,#1
;;;1379   	while(yy<count1 && zz<count1)
000008  f8bc200e          LDRH     r2,[r12,#0xe]
;;;1380   	{
;;;1381   		if(	DATA_SUM1[zz]>DATA_SUM1[yy])
00000c  4b0a              LDR      r3,|L4.56|
00000e  2000              MOVS     r0,#0                 ;1378
                  |L4.16|
000010  4291              CMP      r1,r2                 ;1379
000012  bfb2              ITEE     LT                    ;1379
000014  4290              CMPLT    r0,r2                 ;1379
;;;1382   		{
;;;1383   			count2=yy;zz=zz+1;	
;;;1384   		}
;;;1385   		else
;;;1386   		{
;;;1387   			count2=zz;yy=yy+1;
;;;1388   		}
;;;1389   	}	
;;;1390   }
000016  bc30              POPGE    {r4,r5}
000018  4770              BXGE     lr
00001a  f8334010          LDRH     r4,[r3,r0,LSL #1]     ;1381
00001e  f8335011          LDRH     r5,[r3,r1,LSL #1]     ;1381
000022  42ac              CMP      r4,r5                 ;1381
000024  bf87              ITTEE    HI                    ;1383
000026  f8ac1010          STRHHI   r1,[r12,#0x10]        ;1383
00002a  1c40              ADDHI    r0,r0,#1              ;1383
00002c  f8ac0010          STRHLS   r0,[r12,#0x10]        ;1387
000030  1c49              ADDLS    r1,r1,#1              ;1387
000032  e7ed              B        |L4.16|
;;;1391   
                          ENDP

                  |L4.52|
                          DCD      ||.data||
                  |L4.56|
                          DCD      ||.bss||+0x5c

                          AREA ||i.I2C_DATAL_COMPAREX||, CODE, READONLY, ALIGN=2

                  I2C_DATAL_COMPAREX PROC
;;;1337   }
;;;1338   void I2C_DATAL_COMPAREX(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1339   {
000002  b083              SUB      sp,sp,#0xc
;;;1340   
;;;1341   //	TSL2583_init();			////must initial TSL2583,,,for AUTO OTP use..
;;;1342   //	while(1)
;;;1343   //	{
;;;1344   	GET_FLICKER();
000004  f7fffffe          BL       GET_FLICKER
;;;1345   	I2C_MEMSURE1(STEP , VCOMDC);   //最大找寻 20次，调整的阶数值保存于SURE数组中
000008  4c18              LDR      r4,|L5.108|
00000a  7921              LDRB     r1,[r4,#4]  ; VCOMDC
00000c  7960              LDRB     r0,[r4,#5]  ; STEP
00000e  f7fffffe          BL       I2C_MEMSURE1
000012  2101              MOVS     r1,#1
000014  4b16              LDR      r3,|L5.112|
000016  89e2              LDRH     r2,[r4,#0xe]
000018  2000              MOVS     r0,#0
                  |L5.26|
00001a  4291              CMP      r1,r2
00001c  bfb8              IT       LT
00001e  4290              CMPLT    r0,r2
000020  da0a              BGE      |L5.56|
000022  f833c010          LDRH     r12,[r3,r0,LSL #1]
000026  f8335011          LDRH     r5,[r3,r1,LSL #1]
00002a  45ac              CMP      r12,r5
00002c  bf87              ITTEE    HI
00002e  8221              STRHHI   r1,[r4,#0x10]
000030  1c40              ADDHI    r0,r0,#1
000032  8220              STRHLS   r0,[r4,#0x10]
000034  1c49              ADDLS    r1,r1,#1
000036  e7f0              B        |L5.26|
                  |L5.56|
;;;1346   	I2C_DATAL_COMPARE();      //  
;;;1347       count1=0;
000038  2000              MOVS     r0,#0
00003a  81e0              STRH     r0,[r4,#0xe]
;;;1348   
;;;1349   	
;;;1350   /*在最小值附近停下来。。。后续开启OTP功能即可。。*/
;;;1351   //		VCOMDC1 = SURE[count2];				 //挑选出最好的VCOM的值，下CODE，看效果。
;;;1352   //		SHOW_value(3,50,count2);
;;;1353   //		SHOW_value(3,50,VCOMDC1);
;;;1354   
;;;1355   
;;;1356   
;;;1357   //		VCOMDC1 = SURE[count2 ] + 7;
;;;1358   //		VCOMDC1 = SURE[count2];					///////////////2013-12-05
;;;1359   		VCOMDC1 = SURE[count2];					///////////////2013-12-15
00003c  480d              LDR      r0,|L5.116|
00003e  8a21              LDRH     r1,[r4,#0x10]  ; count2
;;;1360   //	  VCOMDC1 = SURE[count2]+0;  //2014.1.27 count2为最优vcom所在的序号，根据序号在SURE数组找到对应阶数
;;;1361   //		HX8369_cmd_4(0xb6,VCOMDC1,VCOMDC1,0X00);	   ////write the perfect    vcom value
;;;1362   
;;;1363   //			ENTER_LP_mode();
;;;1364   			MIPI_SPI_Write(0x05,0x39,0xB9,0xff,0x83,0x69); 
000040  23ff              MOVS     r3,#0xff
000042  22b9              MOVS     r2,#0xb9
000044  f8300011          LDRH     r0,[r0,r1,LSL #1]     ;1359
000048  82e0              STRH     r0,[r4,#0x16]         ;1359
00004a  2169              MOVS     r1,#0x69
00004c  2083              MOVS     r0,#0x83
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
000052  2139              MOVS     r1,#0x39
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       MIPI_SPI_Write
;;;1365   //				MIPI_SPI_Write(0x04,0x39,0xB6,VCOMDC1,0x28);
;;;1366   				MIPI_SPI_Write(0x04,0x39,0xB6,VCOMDC1,VCOMDC1);
00005a  8ae3              LDRH     r3,[r4,#0x16]  ; VCOMDC1
00005c  22b6              MOVS     r2,#0xb6
00005e  2139              MOVS     r1,#0x39
000060  2004              MOVS     r0,#4
000062  9300              STR      r3,[sp,#0]
000064  f7fffffe          BL       MIPI_SPI_Write
;;;1367   //				
;;;1368   //			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;1369   //        	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC1);
;;;1370   //			VIDEO_ON();
;;;1371   //	}
;;;1372   //		VCOMDC1 = DATA_SUM1[count2];		////挑选出最小的FLICKER值，显示出来。
;;;1373   //		SHOW_value(3,125,VCOMDC1);
;;;1374   
;;;1375   }
000068  b003              ADD      sp,sp,#0xc
00006a  bd30              POP      {r4,r5,pc}
;;;1376   void I2C_DATAL_COMPARE(void)
                          ENDP

                  |L5.108|
                          DCD      ||.data||
                  |L5.112|
                          DCD      ||.bss||+0x5c
                  |L5.116|
                          DCD      ||.bss||+0x98

                          AREA ||i.I2C_MEMSURE||, CODE, READONLY, ALIGN=2

                  I2C_MEMSURE PROC
;;;1291   }
;;;1292   void I2C_MEMSURE(void)
000000  252a              MOVS     r5,#0x2a
;;;1293   { 
;;;1294   		u16 mm_KEYA7 = 1;
;;;1295   	int temp;	  //temp 为加的阶数
;;;1296       u16 a=0x2A,b;
;;;1297   		SENSOR_Check(0x52);			/////S3		
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       SENSOR_Check
;;;1298   	SENSOR_Check(0x72);			/////S2
000008  2072              MOVS     r0,#0x72
00000a  f7fffffe          BL       SENSOR_Check
;;;1299      while(1)
;;;1300      {
;;;1301           	Delay(4);	
;;;1302      	  	mm_KEYA7 =  KEYA7;
00000e  4c14              LDR      r4,|L6.96|
                  |L6.16|
000010  2004              MOVS     r0,#4                 ;1301
000012  f7fffffe          BL       Delay
000016  6820              LDR      r0,[r4,#0]
000018  f0100f80          TST      r0,#0x80
;;;1303      if(mm_KEYA7 == 0)
00001c  d1f8              BNE      |L6.16|
                  |L6.30|
;;;1304   		{
;;;1305   	
;;;1306   			 while(!mm_KEYA7)
;;;1307   			 {		mm_KEYA7 =  KEYA7;}
00001e  6820              LDR      r0,[r4,#0]
000020  f0100f80          TST      r0,#0x80
000024  d0fb              BEQ      |L6.30|
;;;1308   
;;;1309   
;;;1310      
;;;1311   //	HX8369_cmd_4(0xb6,SURE[sss],SURE[sss],0X00);		  ////set vcom
;;;1312   	       MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  2139              MOVS     r1,#0x39
00002c  2003              MOVS     r0,#3
00002e  f7fffffe          BL       MIPI_SPI_Write
;;;1313           	MIPI_SPI_Write(0x03,0x39,0xD9,a);
000032  462b              MOV      r3,r5
000034  22d9              MOVS     r2,#0xd9
000036  2139              MOVS     r1,#0x39
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       MIPI_SPI_Write
;;;1314   		  Delay(5);
00003e  2005              MOVS     r0,#5
000040  f7fffffe          BL       Delay
;;;1315   //	 	 READ_IC_A(0XD9,0x00);
;;;1316   
;;;1317    //   LCD_DisplayStringLine(100,600,"VCOM");
;;;1318    SHOW_IC_VALUE_A(300,600,a);
000044  f44f7116          MOV      r1,#0x258
000048  b2ea              UXTB     r2,r5
00004a  1048              ASRS     r0,r1,#1
00004c  f7fffffe          BL       SHOW_IC_VALUE_A
;;;1319    	
;;;1320   //	SENSOR_Check(0x92);			/////S1
;;;1321   
;;;1322   	Delay(5);
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       Delay
;;;1323           b=	GET_FLICKER();	 ///get flicker value
000056  f7fffffe          BL       GET_FLICKER
;;;1324   //	  SHOW_IC_VALUE_A(300,600,b);
;;;1325   	if(b <= 180)
;;;1326   	{temp=1;  }
;;;1327   	else if((b>180)&&(b< 180*2))
;;;1328   	{temp=2; }
;;;1329   	else
;;;1330   	{ temp=3;}
;;;1331   	a=a+1;
00005a  1c68              ADDS     r0,r5,#1
00005c  b285              UXTH     r5,r0
00005e  e7d7              B        |L6.16|
;;;1332   			
;;;1333   	}
;;;1334   	
;;;1335   
;;;1336      }
;;;1337   }
;;;1338   void I2C_DATAL_COMPAREX(void)
                          ENDP

                  |L6.96|
                          DCD      0x40010808

                          AREA ||i.I2C_MEMSURE1||, CODE, READONLY, ALIGN=2

                  I2C_MEMSURE1 PROC
;;;1221   
;;;1222   void I2C_MEMSURE1(int kk  , int vcomdcdata)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1223   { int i=0,tep1=0,tep2=0,flag=0; //2014.1.27  HFZ
000004  f04f0500          MOV      r5,#0
000008  b083              SUB      sp,sp,#0xc
00000a  4689              MOV      r9,r1
00000c  f1b00800          SUBS     r8,r0,#0
000010  462c              MOV      r4,r5
;;;1224   	int sss=0,yyy=0,aaa=0,temp;	  //temp 为加的阶数
000012  462e              MOV      r6,r5
000014  46aa              MOV      r10,r5
000016  462f              MOV      r7,r5
;;;1225   	for (yyy=0;yyy<kk;yyy++)	 //Ω?
;;;1226   	{SURE[sss]=vcomdcdata+aaa;
;;;1227   
;;;1228   //	HX8369_cmd_4(0xb6,SURE[sss],SURE[sss],0X00);		  ////set vcom
;;;1229   	MIPI_SPI_Write(0x05,0x39,0xB9,0xff,0x83,0x69); 
;;;1230   //				MIPI_SPI_Write(0x04,0x39,0xB6,SURE[sss],0x28);
;;;1231   		MIPI_SPI_Write(0x04,0x39,0xB6,SURE[sss],SURE[sss]);
;;;1232   		
;;;1233   //		MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;1234   //        	MIPI_SPI_Write(0x03,0x39,0xD9,SURE[sss]);
;;;1235   //	 SHOW_IC_VALUE_A(300,600,SURE[sss]);
;;;1236   		
;;;1237   	SENSOR_Check(0x52);			/////S3		
;;;1238   	SENSOR_Check(0x72);			/////S2
;;;1239   
;;;1240   	
;;;1241   //	SENSOR_Check(0x92);			/////S1
;;;1242   
;;;1243   	Delay(5);
;;;1244   	DATA_SUM1[count1] =	GET_FLICKER();	 ///get flicker value
;;;1245   ///////////////*------新增一部分光感ID检验功能，一旦光感失效，即停止在此处。-----*/
;;;1246     //------2014.1.27--HFZ-START-------
;;;1247   		if (flag==0)                             //判断是否找到了最低点
;;;1248   			{
;;;1249   				tep2=tep1=DATA_SUM1[count1];
;;;1250   				flag=1;
;;;1251   			}
;;;1252   		else
;;;1253   			{ 
;;;1254   				tep1=DATA_SUM1[count1];
;;;1255   					if(tep1<tep2)
;;;1256   					{
;;;1257   							tep2=tep1;
;;;1258   							 flag=1;  //此处flag再次赋值是为了在一旦再次出现更小值的情况，清除flag计数 令后续可以找到真正的最小值
;;;1259   					}
;;;1260   					else   // if (tep1>tep2)       //如果找到了最低点，则继续寻找两次(flag=1~3)
;;;1261   					  	flag++;
;;;1262   					
;;;1263   					if ((flag==3) & (tep2<300))    //判断是否是真的最低点，再确认是否小于预定值，如果是则停止寻找以节约时间。
;;;1264   					{
;;;1265   						for(i=(count1+1);i<STEP;i++)
;;;1266   							DATA_SUM1[i]=500;                     //填充剩下的数组，否则后续处理会出错
;;;1267   					
;;;1268   							yyy=kk;     //改变判断条件，使本函数提前结束
;;;1269   					}
;;;1270   			}
;;;1271   		  //
;;;1272   	 //------2014.1.27----HFZ--END------	
;;;1273   				
;;;1274   //	temp=1;			
;;;1275   	if(DATA_SUM1[count1] <180)
;;;1276   	{temp=1;  }
;;;1277   	else if((DATA_SUM1[count1]>=180)&&(DATA_SUM1[count1] < 200*2))
;;;1278   	{temp=2; }
;;;1279   	else if((DATA_SUM1[count1]>=400)&&(DATA_SUM1[count1] < 400*2))
;;;1280   	{ temp=4;}
;;;1281   	else
;;;1282   	{ temp=8;}
;;;1283   //	SHOW_value(3,125,DATA_SUM1[coufnt1]);
;;;1284   	count1=count1+1;
;;;1285   //	SHOW_value(3,90,sss);
;;;1286   //	SHOW_value(3,50,vcomdcdata+aaa); //DelayKEY(1);
;;;1287   
;;;1288   	aaa=aaa+temp;
;;;1289   	sss=sss+1;
;;;1290   	}
;;;1291   }
000018  bfdc              ITT      LE
00001a  b003              ADDLE    sp,sp,#0xc
00001c  e8bd8ff0          POPLE    {r4-r11,pc}
                  |L7.32|
000020  eb090007          ADD      r0,r9,r7              ;1226
000024  f8dfb0f4          LDR      r11,|L7.284|
000028  2169              MOVS     r1,#0x69              ;1229
00002a  23ff              MOVS     r3,#0xff              ;1229
00002c  f82b0016          STRH     r0,[r11,r6,LSL #1]    ;1226
000030  2083              MOVS     r0,#0x83              ;1229
000032  e9cd0100          STRD     r0,r1,[sp,#0]         ;1229
000036  22b9              MOVS     r2,#0xb9              ;1229
000038  2139              MOVS     r1,#0x39              ;1229
00003a  2005              MOVS     r0,#5                 ;1229
00003c  f7fffffe          BL       MIPI_SPI_Write
000040  f83b3016          LDRH     r3,[r11,r6,LSL #1]    ;1231
000044  22b6              MOVS     r2,#0xb6              ;1231
000046  2139              MOVS     r1,#0x39              ;1231
000048  2004              MOVS     r0,#4                 ;1231
00004a  9300              STR      r3,[sp,#0]            ;1231
00004c  f7fffffe          BL       MIPI_SPI_Write
000050  2052              MOVS     r0,#0x52              ;1237
000052  f7fffffe          BL       sensor_check
000056  b150              CBZ      r0,|L7.110|
000058  4a31              LDR      r2,|L7.288|
00005a  2150              MOVS     r1,#0x50              ;1237
00005c  2064              MOVS     r0,#0x64              ;1237
00005e  f7fffffe          BL       LCD_DisplayStringLine
000062  4a30              LDR      r2,|L7.292|
000064  2132              MOVS     r1,#0x32              ;1237
000066  2014              MOVS     r0,#0x14              ;1237
000068  f7fffffe          BL       LCD_DisplayStringLine
                  |L7.108|
00006c  e7fe              B        |L7.108|
                  |L7.110|
00006e  2072              MOVS     r0,#0x72              ;1238
000070  f7fffffe          BL       sensor_check
000074  b150              CBZ      r0,|L7.140|
000076  4a2c              LDR      r2,|L7.296|
000078  2150              MOVS     r1,#0x50              ;1238
00007a  208c              MOVS     r0,#0x8c              ;1238
00007c  f7fffffe          BL       LCD_DisplayStringLine
000080  4a28              LDR      r2,|L7.292|
000082  2132              MOVS     r1,#0x32              ;1238
000084  2014              MOVS     r0,#0x14              ;1238
000086  f7fffffe          BL       LCD_DisplayStringLine
                  |L7.138|
00008a  e7fe              B        |L7.138|
                  |L7.140|
00008c  2005              MOVS     r0,#5                 ;1243
00008e  f7fffffe          BL       Delay
000092  f7fffffe          BL       GET_FLICKER
000096  f8dfc098          LDR      r12,|L7.304|
00009a  4601              MOV      r1,r0                 ;1244
00009c  f8dfb08c          LDR      r11,|L7.300|
0000a0  f8bc000e          LDRH     r0,[r12,#0xe]         ;1244  ; count1
0000a4  f82b1010          STRH     r1,[r11,r0,LSL #1]    ;1244
0000a8  b10c              CBZ      r4,|L7.174|
0000aa  42a9              CMP      r1,r5                 ;1255
0000ac  da02              BGE      |L7.180|
                  |L7.174|
0000ae  460d              MOV      r5,r1                 ;1257
0000b0  2401              MOVS     r4,#1                 ;1258
0000b2  e013              B        |L7.220|
                  |L7.180|
0000b4  1c64              ADDS     r4,r4,#1              ;1258
0000b6  2c03              CMP      r4,#3                 ;1263
0000b8  d110              BNE      |L7.220|
0000ba  f5b57f96          CMP      r5,#0x12c             ;1263
0000be  da0d              BGE      |L7.220|
0000c0  f89c3005          LDRB     r3,[r12,#5]           ;1265  ; STEP
0000c4  1c42              ADDS     r2,r0,#1              ;1265
0000c6  429a              CMP      r2,r3                 ;1265
0000c8  bfb8              IT       LT                    ;1266
0000ca  f44f71fa          MOVLT    r1,#0x1f4             ;1266
0000ce  da04              BGE      |L7.218|
                  |L7.208|
0000d0  f82b1012          STRH     r1,[r11,r2,LSL #1]    ;1266
0000d4  1c52              ADDS     r2,r2,#1              ;1266
0000d6  429a              CMP      r2,r3                 ;1265
0000d8  dbfa              BLT      |L7.208|
                  |L7.218|
0000da  46c2              MOV      r10,r8                ;1268
                  |L7.220|
0000dc  f83b1010          LDRH     r1,[r11,r0,LSL #1]    ;1275
0000e0  29b4              CMP      r1,#0xb4              ;1275
0000e2  bf38              IT       CC                    ;1276
0000e4  2201              MOVCC    r2,#1                 ;1276
0000e6  d30c              BCC      |L7.258|
0000e8  f1a102b4          SUB      r2,r1,#0xb4           ;1277
0000ec  2adc              CMP      r2,#0xdc              ;1277
0000ee  bf38              IT       CC                    ;1278
0000f0  2202              MOVCC    r2,#2                 ;1278
0000f2  d306              BCC      |L7.258|
0000f4  f5a171c8          SUB      r1,r1,#0x190          ;1277
0000f8  f5b17fc8          CMP      r1,#0x190             ;1279
0000fc  bf34              ITE      CC                    ;1280
0000fe  2204              MOVCC    r2,#4                 ;1280
000100  2208              MOVCS    r2,#8                 ;1282
                  |L7.258|
000102  1c40              ADDS     r0,r0,#1              ;1282
000104  1c76              ADDS     r6,r6,#1              ;1288
000106  f10a0a01          ADD      r10,r10,#1            ;1288
00010a  f8ac000e          STRH     r0,[r12,#0xe]         ;1284
00010e  4417              ADD      r7,r7,r2              ;1288
000110  45c2              CMP      r10,r8                ;1225
000112  db85              BLT      |L7.32|
000114  b003              ADD      sp,sp,#0xc
000116  e8bd8ff0          POP      {r4-r11,pc}
;;;1292   void I2C_MEMSURE(void)
                          ENDP

00011a  0000              DCW      0x0000
                  |L7.284|
                          DCD      ||.bss||+0x98
                  |L7.288|
                          DCD      ||i.SENSOR_Check||+0x48
                  |L7.292|
                          DCD      ||i.SENSOR_Check||+0x54
                  |L7.296|
                          DCD      ||i.SENSOR_Check||+0x4c
                  |L7.300|
                          DCD      ||.bss||+0x5c
                  |L7.304|
                          DCD      ||.data||

                          AREA ||i.ID_CHECK||, CODE, READONLY, ALIGN=2

                  ID_CHECK PROC
;;;634    
;;;635    u8 ID_CHECK(u16 adx,u16 ady)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;636    {
;;;637    //	READ_IC(0XB6,0x00);
;;;638    FontR = 0; FontG = 0; FontB = 0;
000004  4e34              LDR      r6,|L8.216|
000006  2500              MOVS     r5,#0
000008  4f34              LDR      r7,|L8.220|
00000a  f8df80d4          LDR      r8,|L8.224|
00000e  7035              STRB     r5,[r6,#0]
000010  703d              STRB     r5,[r7,#0]
000012  f8885000          STRB     r5,[r8,#0]
;;;639    	READ_IC(0XDA,0x00);
000016  4629              MOV      r1,r5
000018  20da              MOVS     r0,#0xda
00001a  f7fffffe          BL       READ_IC
;;;640    	OTP_VALUE1 =   MIPI_READ_DATA[0];
00001e  f8df90c4          LDR      r9,|L8.228|
000022  4c31              LDR      r4,|L8.232|
;;;641    	READ_IC(0XDB,0x00);
000024  2100              MOVS     r1,#0
000026  f8990000          LDRB     r0,[r9,#0]            ;640  ; MIPI_READ_DATA
00002a  71a0              STRB     r0,[r4,#6]            ;640
00002c  20db              MOVS     r0,#0xdb
00002e  f7fffffe          BL       READ_IC
;;;642    	OTP_VALUE2 =   MIPI_READ_DATA[0];
000032  f8990000          LDRB     r0,[r9,#0]  ; MIPI_READ_DATA
000036  71e0              STRB     r0,[r4,#7]
;;;643    	READ_IC(0XDC,0x00);
000038  2100              MOVS     r1,#0
00003a  20dc              MOVS     r0,#0xdc
00003c  f7fffffe          BL       READ_IC
;;;644    	OTP_TIMES =   MIPI_READ_DATA[0];
000040  f8990000          LDRB     r0,[r9,#0]  ; MIPI_READ_DATA
000044  7220              STRB     r0,[r4,#8]
;;;645    //	READ_IC(0X04,0x00);
;;;646    
;;;647    	LCD_DisplayStringLine(100,100, "ID1");
000046  2164              MOVS     r1,#0x64
000048  a228              ADR      r2,|L8.236|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       LCD_DisplayStringLine
;;;648    	SHOW_IC_VALUE_A(200,100, OTP_VALUE1);
000050  79a2              LDRB     r2,[r4,#6]  ; OTP_VALUE1
000052  2164              MOVS     r1,#0x64
000054  20c8              MOVS     r0,#0xc8
000056  f7fffffe          BL       SHOW_IC_VALUE_A
;;;649    	 LCD_DisplayStringLine(100,200, "ID2");
00005a  a225              ADR      r2,|L8.240|
00005c  21c8              MOVS     r1,#0xc8
00005e  2064              MOVS     r0,#0x64
000060  f7fffffe          BL       LCD_DisplayStringLine
;;;650    	SHOW_IC_VALUE_A(200,200, OTP_VALUE2);
000064  21c8              MOVS     r1,#0xc8
000066  79e2              LDRB     r2,[r4,#7]  ; OTP_VALUE2
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       SHOW_IC_VALUE_A
;;;651    	 LCD_DisplayStringLine(100,300, "ID3");
00006e  a221              ADR      r2,|L8.244|
000070  f44f7196          MOV      r1,#0x12c
000074  2064              MOVS     r0,#0x64
000076  f7fffffe          BL       LCD_DisplayStringLine
;;;652    	SHOW_IC_VALUE_A(200,300, OTP_TIMES);
00007a  7a22              LDRB     r2,[r4,#8]  ; OTP_TIMES
00007c  f44f7196          MOV      r1,#0x12c
000080  20c8              MOVS     r0,#0xc8
000082  f7fffffe          BL       SHOW_IC_VALUE_A
;;;653    //	LCD_DisplayStringLine_A(adx,ady,"ID=");
;;;654    
;;;655    	if((OTP_VALUE1 == 0xD5)&&(OTP_VALUE2 == 0x97)&&(OTP_TIMES == 0xCA))
000086  79a1              LDRB     r1,[r4,#6]  ; OTP_VALUE1
;;;656    	{
;;;657    		ID_OK = 0;
;;;658    		FontR = 0; FontG = 255; FontB = 0;
000088  20ff              MOVS     r0,#0xff
00008a  29d5              CMP      r1,#0xd5              ;655
00008c  bf01              ITTTT    EQ                    ;655
00008e  79e1              LDRBEQ   r1,[r4,#7]            ;655  ; OTP_VALUE2
000090  2997              CMPEQ    r1,#0x97              ;655
000092  7a21              LDRBEQ   r1,[r4,#8]            ;655  ; OTP_TIMES
000094  29ca              CMPEQ    r1,#0xca              ;655
000096  d012              BEQ      |L8.190|
;;;659    //		LCD_DisplayStringLine_A(adx+150,ady,"OK");
;;;660    		LCD_DisplayStringLine_A(50,400,"ID CODE PASS");
;;;661    	}
;;;662    	else
;;;663    	{
;;;664    		ID_OK = 1;
000098  2101              MOVS     r1,#1
00009a  72a1              STRB     r1,[r4,#0xa]
;;;665    		FontR = 255; FontG = 0; FontB = 0;
00009c  7030              STRB     r0,[r6,#0]
00009e  703d              STRB     r5,[r7,#0]
0000a0  f8885000          STRB     r5,[r8,#0]
;;;666    //		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;667    		LCD_DisplayStringLine_A( 50 ,400,"ID CODE NG");
0000a4  a214              ADR      r2,|L8.248|
0000a6  f44f71c8          MOV      r1,#0x190
0000aa  2032              MOVS     r0,#0x32
0000ac  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L8.176|
;;;668    	}
;;;669    	FontR = 0; FontG = 0; FontB = 0;
0000b0  7035              STRB     r5,[r6,#0]
0000b2  703d              STRB     r5,[r7,#0]
0000b4  f8885000          STRB     r5,[r8,#0]
;;;670    //	DelayKEY(15);
;;;671    
;;;672    	return ID_OK;
0000b8  7aa0              LDRB     r0,[r4,#0xa]  ; ID_OK
;;;673    }
0000ba  e8bd87f0          POP      {r4-r10,pc}
                  |L8.190|
0000be  72a5              STRB     r5,[r4,#0xa]          ;657
0000c0  7035              STRB     r5,[r6,#0]            ;658
0000c2  7038              STRB     r0,[r7,#0]            ;658
0000c4  f8885000          STRB     r5,[r8,#0]            ;658
0000c8  a20e              ADR      r2,|L8.260|
0000ca  f44f71c8          MOV      r1,#0x190             ;660
0000ce  2032              MOVS     r0,#0x32              ;660
0000d0  f7fffffe          BL       LCD_DisplayStringLine_A
0000d4  e7ec              B        |L8.176|
;;;674    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L8.216|
                          DCD      FontR
                  |L8.220|
                          DCD      FontG
                  |L8.224|
                          DCD      FontB
                  |L8.228|
                          DCD      ||.bss||
                  |L8.232|
                          DCD      ||.data||
                  |L8.236|
0000ec  49443100          DCB      "ID1",0
                  |L8.240|
0000f0  49443200          DCB      "ID2",0
                  |L8.244|
0000f4  49443300          DCB      "ID3",0
                  |L8.248|
0000f8  49442043          DCB      "ID CODE NG",0
0000fc  4f444520
000100  4e4700  
000103  00                DCB      0
                  |L8.260|
000104  49442043          DCB      "ID CODE PASS",0
000108  4f444520
00010c  50415353
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.ID_CHECK_A||, CODE, READONLY, ALIGN=2

                  ID_CHECK_A PROC
;;;674    
;;;675    u8 ID_CHECK_A(u16 adx,u16 ady)
000000  b570              PUSH     {r4-r6,lr}
;;;676    {
;;;677        READ_IC(0X5F,0x00);
000002  2100              MOVS     r1,#0
000004  205f              MOVS     r0,#0x5f
000006  f7fffffe          BL       READ_IC
;;;678    	OTP_TIMES =   MIPI_READ_DATA[0];
00000a  4d1b              LDR      r5,|L9.120|
00000c  4c1b              LDR      r4,|L9.124|
;;;679    	
;;;680    	READ_IC(0XDA,0x00);
00000e  2100              MOVS     r1,#0
000010  7828              LDRB     r0,[r5,#0]            ;678  ; MIPI_READ_DATA
000012  7220              STRB     r0,[r4,#8]            ;678
000014  20da              MOVS     r0,#0xda
000016  f7fffffe          BL       READ_IC
;;;681    	OTP_VALUE1 =   MIPI_READ_DATA[0];
00001a  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
00001c  71a0              STRB     r0,[r4,#6]
;;;682    	READ_IC(0XDB,0x00);
00001e  2100              MOVS     r1,#0
000020  20db              MOVS     r0,#0xdb
000022  f7fffffe          BL       READ_IC
;;;683    	OTP_VALUE2 =   MIPI_READ_DATA[0];
000026  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
000028  71e0              STRB     r0,[r4,#7]
;;;684    	READ_IC(0XDC,0x00);
00002a  2100              MOVS     r1,#0
00002c  20dc              MOVS     r0,#0xdc
00002e  f7fffffe          BL       READ_IC
;;;685    	OTP_TIMES =   MIPI_READ_DATA[0];
000032  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
000034  7220              STRB     r0,[r4,#8]
;;;686    
;;;687    //	LCD_DisplayStringLine_A(adx,ady,"ID=");
;;;688    
;;;689    	if((OTP_VALUE1 == 0xD5)&&(OTP_VALUE2 == 0x97)&&(OTP_TIMES == 0xCA))
000036  79a6              LDRB     r6,[r4,#6]  ; OTP_VALUE1
000038  2100              MOVS     r1,#0
;;;690    	{
;;;691    		ID_OK = 0;
;;;692    		FontR = 0; FontG = 255; FontB = 0;
00003a  4a11              LDR      r2,|L9.128|
00003c  23ff              MOVS     r3,#0xff
00003e  f8dfc044          LDR      r12,|L9.132|
000042  4d11              LDR      r5,|L9.136|
000044  2ed5              CMP      r6,#0xd5              ;689
000046  bf02              ITTT     EQ                    ;689
000048  79e6              LDRBEQ   r6,[r4,#7]            ;689  ; OTP_VALUE2
00004a  2e97              CMPEQ    r6,#0x97              ;689
00004c  28ca              CMPEQ    r0,#0xca              ;689
00004e  d00d              BEQ      |L9.108|
;;;693    //		LCD_DisplayStringLine_A(adx+150,ady,"OK");
;;;694    	}
;;;695    	else
;;;696    	{
;;;697    		ID_OK = 1;
000050  2001              MOVS     r0,#1
000052  72a0              STRB     r0,[r4,#0xa]
;;;698    		FontR = 255; FontG = 0; FontB = 0;
000054  7013              STRB     r3,[r2,#0]
000056  f88c1000          STRB     r1,[r12,#0]
00005a  7029              STRB     r1,[r5,#0]
;;;699    		LCD_DisplayStringLine_A( 50 ,400,"ID CODE NG");
00005c  a20b              ADR      r2,|L9.140|
00005e  f44f71c8          MOV      r1,#0x190
000062  2032              MOVS     r0,#0x32
000064  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L9.104|
;;;700    //		while(1);
;;;701    //		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;702    	}
;;;703    
;;;704    
;;;705    	return ID_OK;
000068  7aa0              LDRB     r0,[r4,#0xa]  ; ID_OK
;;;706    }
00006a  bd70              POP      {r4-r6,pc}
                  |L9.108|
00006c  72a1              STRB     r1,[r4,#0xa]          ;691
00006e  7011              STRB     r1,[r2,#0]            ;692
000070  f88c3000          STRB     r3,[r12,#0]           ;692
000074  7029              STRB     r1,[r5,#0]            ;692
000076  e7f7              B        |L9.104|
;;;707    
                          ENDP

                  |L9.120|
                          DCD      ||.bss||
                  |L9.124|
                          DCD      ||.data||
                  |L9.128|
                          DCD      FontR
                  |L9.132|
                          DCD      FontG
                  |L9.136|
                          DCD      FontB
                  |L9.140|
00008c  49442043          DCB      "ID CODE NG",0
000090  4f444520
000094  4e4700  
000097  00                DCB      0

                          AREA ||i.InterruptConfig||, CODE, READONLY, ALIGN=2

                  InterruptConfig PROC
;;;950    *******************************************************************************/
;;;951    void InterruptConfig(void)
000000  b510              PUSH     {r4,lr}
;;;952    { 
;;;953      /* Deinitializes the NVIC */
;;;954      NVIC_DeInit();
000002  f7fffffe          BL       NVIC_DeInit
;;;955    
;;;956      NVIC_Configuration();
000006  f7fffffe          BL       NVIC_Configuration
;;;957    
;;;958      /* Configure the Priority Group to 2 bits */
;;;959      //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);		
;;;960    
;;;961      /* Configure the SysTick handler priority */
;;;962      //为了使用SDIO中断，下面的中断优先级被我改低了
;;;963      NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 1, 1);
00000a  2201              MOVS     r2,#1
00000c  e8bd4010          POP      {r4,lr}
000010  4611              MOV      r1,r2
000012  4801              LDR      r0,|L10.24|
000014  f7ffbffe          B.W      NVIC_SystemHandlerPriorityConfig
;;;964    }
;;;965    
                          ENDP

                  |L10.24|
                          DCD      0x0002c39a

                          AREA ||i.KEYGPIO_Init||, CODE, READONLY, ALIGN=2

                  KEYGPIO_Init PROC
;;;1033   
;;;1034   void KEYGPIO_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1035   {
;;;1036    GPIO_InitTypeDef GPIO_InitStructure; 
;;;1037    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2015              MOVS     r0,#0x15
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1038     
;;;1039     /*[把KEYGPIO KEY7/8配置成输入模式] */
;;;1040     GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_6;
00000a  2040              MOVS     r0,#0x40
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;1041     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
000010  2448              MOVS     r4,#0x48
000012  f88d4003          STRB     r4,[sp,#3]
;;;1042     GPIO_Init(GPIOC, &GPIO_InitStructure);  
000016  4669              MOV      r1,sp
000018  4806              LDR      r0,|L11.52|
00001a  f7fffffe          BL       GPIO_Init
;;;1043   
;;;1044     GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_7 ;
00001e  2080              MOVS     r0,#0x80
000020  f8ad0000          STRH     r0,[sp,#0]
;;;1045     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
000024  f88d4003          STRB     r4,[sp,#3]
;;;1046     GPIO_Init(GPIOA, &GPIO_InitStructure); 
000028  4669              MOV      r1,sp
00002a  4803              LDR      r0,|L11.56|
00002c  f7fffffe          BL       GPIO_Init
;;;1047       
;;;1048   //    GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_8;
;;;1049   //  GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
;;;1050   //  GPIO_Init(GPIOA, &GPIO_InitStructure); 
;;;1051   }
000030  bd38              POP      {r3-r5,pc}
;;;1052   
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40011000
                  |L11.56|
                          DCD      0x40010800

                          AREA ||i.KEY_adjust||, CODE, READONLY, ALIGN=2

                  KEY_adjust PROC
;;;428    
;;;429    void KEY_adjust(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;430    {
;;;431    	u16 mm_KEYA7 = 1 ;
;;;432    	u16 mm_KEYA8 = 1 ;
;;;433    	u16 mm_KEYC6 = 1;
;;;434    	u8 OTP_FLAG = 1;
000004  2401              MOVS     r4,#1
;;;435    
;;;436    
;;;437       while(OTP_FLAG)
;;;438       {
;;;439    		mm_KEYA7 = 	KEYA7;
000006  4f2a              LDR      r7,|L12.176|
;;;440    		mm_KEYA8 =  KEYA8;
;;;441    		mm_KEYC6 = 	KEYC6;
000008  f8df80a8          LDR      r8,|L12.180|
;;;442    		
;;;443    		if(mm_KEYA7 == 0)
;;;444    		{
;;;445    		
;;;446    			 while(!mm_KEYA7)
;;;447    			{	mm_KEYA7 =  KEYA7;}
;;;448    
;;;449    			VCOMDC++;
00000c  f8df90a8          LDR      r9,|L12.184|
000010  f04f0a00          MOV      r10,#0                ;441
000014  46a3              MOV      r11,r4                ;431
                  |L12.22|
000016  6838              LDR      r0,[r7,#0]            ;439
000018  6839              LDR      r1,[r7,#0]            ;440
00001a  f0100f80          TST      r0,#0x80              ;439
00001e  f4017580          AND      r5,r1,#0x100          ;440
000022  f8d81008          LDR      r1,[r8,#8]            ;441
000026  f0010640          AND      r6,r1,#0x40           ;441
00002a  d111              BNE      |L12.80|
                  |L12.44|
00002c  6838              LDR      r0,[r7,#0]            ;447
00002e  f0100f80          TST      r0,#0x80              ;447
000032  d0fb              BEQ      |L12.44|
000034  f8990004          LDRB     r0,[r9,#4]  ; VCOMDC
;;;450    //			ENTER_LP_mode();
;;;451    //			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;452    //        	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC);
;;;453    			SHOW_IC_VALUE_A(270,800, VCOMDC);
000038  f44f7148          MOV      r1,#0x320
00003c  1c40              ADDS     r0,r0,#1              ;449
00003e  b2c2              UXTB     r2,r0                 ;449
000040  f8892004          STRB     r2,[r9,#4]            ;449
000044  f44f7087          MOV      r0,#0x10e
000048  f7fffffe          BL       SHOW_IC_VALUE_A
;;;454    			VIDEO_ON();
00004c  f7fffffe          BL       VIDEO_ON
                  |L12.80|
;;;455    		}
;;;456    		if(mm_KEYA8 == 0)
000050  b98d              CBNZ     r5,|L12.118|
                  |L12.82|
;;;457    		{
;;;458    		  
;;;459    			 while(!mm_KEYA8)
;;;460    			  {	mm_KEYA8 =  KEYA8;}
000052  6838              LDR      r0,[r7,#0]
000054  f4107f80          TST      r0,#0x100
000058  d0fb              BEQ      |L12.82|
;;;461    			VCOMDC--;
00005a  f8990004          LDRB     r0,[r9,#4]  ; VCOMDC
;;;462    //			ENTER_LP_mode();
;;;463    //			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;464    //        	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC);
;;;465    			SHOW_IC_VALUE_A(270,800, VCOMDC);
00005e  f44f7148          MOV      r1,#0x320
000062  1e40              SUBS     r0,r0,#1              ;461
000064  b2c2              UXTB     r2,r0                 ;461
000066  f8892004          STRB     r2,[r9,#4]            ;461
00006a  f44f7087          MOV      r0,#0x10e
00006e  f7fffffe          BL       SHOW_IC_VALUE_A
;;;466    			VIDEO_ON();
000072  f7fffffe          BL       VIDEO_ON
                  |L12.118|
;;;467    		}
;;;468    		if(mm_KEYC6 == 0)
000076  b9a6              CBNZ     r6,|L12.162|
                  |L12.120|
;;;469    		{
;;;470    	
;;;471    			 while(!mm_KEYC6)
;;;472    			 {		mm_KEYC6 =  KEYC6;}
000078  f8d80008          LDR      r0,[r8,#8]
00007c  f0100f40          TST      r0,#0x40
000080  d0fa              BEQ      |L12.120|
;;;473    			aat = 1;
;;;474    //			ENTER_LP_mode();
;;;475    //			MTP_ID();
;;;476    			FontR = FontG = FontB = 0;
000082  480e              LDR      r0,|L12.188|
000084  f8a9b012          STRH     r11,[r9,#0x12]        ;473
000088  f880a000          STRB     r10,[r0,#0]
00008c  480c              LDR      r0,|L12.192|
00008e  f880a000          STRB     r10,[r0,#0]
000092  480c              LDR      r0,|L12.196|
000094  f880a000          STRB     r10,[r0,#0]
;;;477    
;;;478    			Soft_reset();
000098  f7fffffe          BL       Soft_reset
;;;479    			OTP_FLAG = 0;
00009c  2400              MOVS     r4,#0
;;;480    			aat = 0;
00009e  f8a9a012          STRH     r10,[r9,#0x12]
                  |L12.162|
;;;481    		}
;;;482    		Delay(25);	
0000a2  2019              MOVS     r0,#0x19
0000a4  f7fffffe          BL       Delay
0000a8  2c00              CMP      r4,#0                 ;437
0000aa  d1b4              BNE      |L12.22|
;;;483    		
;;;484    		
;;;485    	}
;;;486    }
0000ac  e8bd9ff0          POP      {r4-r12,pc}
;;;487    
                          ENDP

                  |L12.176|
                          DCD      0x40010808
                  |L12.180|
                          DCD      0x40011000
                  |L12.184|
                          DCD      ||.data||
                  |L12.188|
                          DCD      FontB
                  |L12.192|
                          DCD      FontG
                  |L12.196|
                          DCD      FontR

                          AREA ||i.MDelay||, CODE, READONLY, ALIGN=2

                  MDelay PROC
;;;985    
;;;986    void MDelay(u32 nCount)						 ////delay 1ms		for auto OTP use
000000  b510              PUSH     {r4,lr}
;;;987    {
;;;988      TimingDelay = nCount;
000002  4c06              LDR      r4,|L13.28|
000004  61a0              STR      r0,[r4,#0x18]  ; TimingDelay
;;;989      /* Enable the SysTick Counter */
;;;990      //SysTick_CounterCmd(SysTick_Counter_Enable);	
;;;991      SysTick_ITConfig(ENABLE);//ENABLE DISABLE		
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       SysTick_ITConfig
                  |L13.12|
;;;992      while(TimingDelay != 0)
00000c  69a0              LDR      r0,[r4,#0x18]  ; TimingDelay
00000e  2800              CMP      r0,#0
000010  d1fc              BNE      |L13.12|
;;;993      {;;}
;;;994      SysTick_ITConfig(DISABLE);//ENABLE DISABLE 
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      SysTick_ITConfig
;;;995    }
;;;996    /*******************************************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      ||.data||

                          AREA ||i.MTP||, CODE, READONLY, ALIGN=1

                  MTP PROC
;;;1391   
;;;1392   void MTP(void)
000000  b510              PUSH     {r4,lr}
;;;1393   {
;;;1394   	///display off
;;;1395   			SSD1963GPIOOUTCOM(0xBC);		                
000002  20bc              MOVS     r0,#0xbc
000004  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1396   	SSD1963GPIOOUTDATA_16(0x0001);					
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1397   			SSD1963GPIOOUTCOM(0xbf);
00000e  20bf              MOVS     r0,#0xbf
000010  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1398   	SSD1963GPIOOUTDATA_18(0x28);	  //
000014  2028              MOVS     r0,#0x28
000016  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1399   	Delay(5);			 //delay 40ms
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       Delay
;;;1400   
;;;1401   			SSD1963GPIOOUTCOM(0xBC);		                
000020  20bc              MOVS     r0,#0xbc
000022  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1402   	SSD1963GPIOOUTDATA_16(0x0002);					
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1403   			SSD1963GPIOOUTCOM(0xbf);
00002c  20bf              MOVS     r0,#0xbf
00002e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1404   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000032  20b7              MOVS     r0,#0xb7
000034  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1405   	SSD1963GPIOOUTDATA_18(0x5a);
000038  205a              MOVS     r0,#0x5a
00003a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1406   	MDelay(20);			   ////delay 1ms
00003e  2014              MOVS     r0,#0x14
000040  f7fffffe          BL       MDelay
;;;1407   
;;;1408   	//////////set otp_index[8:0]
;;;1409   			SSD1963GPIOOUTCOM(0xBC);		                
000044  20bc              MOVS     r0,#0xbc
000046  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1410   	SSD1963GPIOOUTDATA_16(0x0006);					
00004a  2006              MOVS     r0,#6
00004c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1411   			SSD1963GPIOOUTCOM(0xbf);
000050  20bf              MOVS     r0,#0xbf
000052  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1412   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000056  20b7              MOVS     r0,#0xb7
000058  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1413   	SSD1963GPIOOUTDATA_18(0x5a);
00005c  205a              MOVS     r0,#0x5a
00005e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1414   	SSD1963GPIOOUTDATA_18(0x00);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1415   	SSD1963GPIOOUTDATA_18(0x00);
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1416   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
00006e  200d              MOVS     r0,#0xd
000070  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1417   	SSD1963GPIOOUTDATA_18(0x00);
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1418   	MDelay(10);	
00007a  200a              MOVS     r0,#0xa
00007c  f7fffffe          BL       MDelay
;;;1419   	
;;;1420   	///////////////set otp_mask[7:0]
;;;1421   			SSD1963GPIOOUTCOM(0xBC);		               
000080  20bc              MOVS     r0,#0xbc
000082  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1422   	SSD1963GPIOOUTDATA_16(0x0006);						 
000086  2006              MOVS     r0,#6
000088  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1423   			SSD1963GPIOOUTCOM(0xbf);
00008c  20bf              MOVS     r0,#0xbf
00008e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1424   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000092  20b7              MOVS     r0,#0xb7
000094  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1425   	SSD1963GPIOOUTDATA_18(0x5a);
000098  205a              MOVS     r0,#0x5a
00009a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1426   	SSD1963GPIOOUTDATA_18(0x00);
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1427   	SSD1963GPIOOUTDATA_18(0x00);
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1428   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
0000aa  200d              MOVS     r0,#0xd
0000ac  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1429   	SSD1963GPIOOUTDATA_18(0x00);
0000b0  2000              MOVS     r0,#0
0000b2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1430   	MDelay(10);		
0000b6  200a              MOVS     r0,#0xa
0000b8  f7fffffe          BL       MDelay
;;;1431   
;;;1432   	/////////////set otp address
;;;1433   			SSD1963GPIOOUTCOM(0xBC);		              
0000bc  20bc              MOVS     r0,#0xbc
0000be  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1434   	SSD1963GPIOOUTDATA_16(0x0006);						 
0000c2  2006              MOVS     r0,#6
0000c4  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1435   			SSD1963GPIOOUTCOM(0xbf);
0000c8  20bf              MOVS     r0,#0xbf
0000ca  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1436   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0000ce  20b7              MOVS     r0,#0xb7
0000d0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1437   	SSD1963GPIOOUTDATA_18(0x5a);
0000d4  205a              MOVS     r0,#0x5a
0000d6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1438   	SSD1963GPIOOUTDATA_18(0x00);
0000da  2000              MOVS     r0,#0
0000dc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1439   	SSD1963GPIOOUTDATA_18(0x00);
0000e0  2000              MOVS     r0,#0
0000e2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1440   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
0000e6  200d              MOVS     r0,#0xd
0000e8  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1441   	SSD1963GPIOOUTDATA_18(0x00);
0000ec  2000              MOVS     r0,#0
0000ee  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1442   	MDelay(10);
0000f2  200a              MOVS     r0,#0xa
0000f4  f7fffffe          BL       MDelay
;;;1443   
;;;1444   	/////////////set otp_prog = 1;
;;;1445   			SSD1963GPIOOUTCOM(0xBC);		             
0000f8  20bc              MOVS     r0,#0xbc
0000fa  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1446   	SSD1963GPIOOUTDATA_16(0x0006);						 
0000fe  2006              MOVS     r0,#6
000100  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1447   			SSD1963GPIOOUTCOM(0xbf);
000104  20bf              MOVS     r0,#0xbf
000106  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1448   	SSD1963GPIOOUTDATA_18(0xb7);	  //
00010a  20b7              MOVS     r0,#0xb7
00010c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1449   	SSD1963GPIOOUTDATA_18(0x5a);
000110  205a              MOVS     r0,#0x5a
000112  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1450   	SSD1963GPIOOUTDATA_18(0x00);
000116  2000              MOVS     r0,#0
000118  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1451   	SSD1963GPIOOUTDATA_18(0x00);
00011c  2000              MOVS     r0,#0
00011e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1452   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
000122  200d              MOVS     r0,#0xd
000124  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1453   	SSD1963GPIOOUTDATA_18(0x01);
000128  2001              MOVS     r0,#1
00012a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1454   	MDelay(45);		 		///DELAY 11ms
00012e  202d              MOVS     r0,#0x2d
000130  f7fffffe          BL       MDelay
;;;1455   
;;;1456   	/////////////set otp_index[8:0]
;;;1457   			SSD1963GPIOOUTCOM(0xBC);		              
000134  20bc              MOVS     r0,#0xbc
000136  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1458   	SSD1963GPIOOUTDATA_16(0x0006);						 
00013a  2006              MOVS     r0,#6
00013c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1459   			SSD1963GPIOOUTCOM(0xbf);
000140  20bf              MOVS     r0,#0xbf
000142  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1460   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000146  20b7              MOVS     r0,#0xb7
000148  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1461   	SSD1963GPIOOUTDATA_18(0x5a);
00014c  205a              MOVS     r0,#0x5a
00014e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1462   	SSD1963GPIOOUTDATA_18(0x00);
000152  2000              MOVS     r0,#0
000154  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1463   	SSD1963GPIOOUTDATA_18(0x00);
000158  2000              MOVS     r0,#0
00015a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1464   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
00015e  200e              MOVS     r0,#0xe
000160  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1465   	SSD1963GPIOOUTDATA_18(0x00);
000164  2000              MOVS     r0,#0
000166  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1466   	MDelay(10);
00016a  200a              MOVS     r0,#0xa
00016c  f7fffffe          BL       MDelay
;;;1467   
;;;1468   	/////////////set otp_mask[7:0]
;;;1469   			SSD1963GPIOOUTCOM(0xBC);		                
000170  20bc              MOVS     r0,#0xbc
000172  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1470   	SSD1963GPIOOUTDATA_16(0x0006);						
000176  2006              MOVS     r0,#6
000178  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1471   			SSD1963GPIOOUTCOM(0xbf);
00017c  20bf              MOVS     r0,#0xbf
00017e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1472   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000182  20b7              MOVS     r0,#0xb7
000184  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1473   	SSD1963GPIOOUTDATA_18(0x5a);
000188  205a              MOVS     r0,#0x5a
00018a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1474   	SSD1963GPIOOUTDATA_18(0x00);
00018e  2000              MOVS     r0,#0
000190  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1475   	SSD1963GPIOOUTDATA_18(0x00);
000194  2000              MOVS     r0,#0
000196  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1476   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
00019a  200e              MOVS     r0,#0xe
00019c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1477   	SSD1963GPIOOUTDATA_18(0x00);
0001a0  2000              MOVS     r0,#0
0001a2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1478   	MDelay(10);
0001a6  200a              MOVS     r0,#0xa
0001a8  f7fffffe          BL       MDelay
;;;1479   
;;;1480   	/////////////set otp address
;;;1481   			SSD1963GPIOOUTCOM(0xBC);		                 
0001ac  20bc              MOVS     r0,#0xbc
0001ae  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1482   	SSD1963GPIOOUTDATA_16(0x0006);					
0001b2  2006              MOVS     r0,#6
0001b4  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1483   			SSD1963GPIOOUTCOM(0xbf);
0001b8  20bf              MOVS     r0,#0xbf
0001ba  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1484   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0001be  20b7              MOVS     r0,#0xb7
0001c0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1485   	SSD1963GPIOOUTDATA_18(0x5a);
0001c4  205a              MOVS     r0,#0x5a
0001c6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1486   	SSD1963GPIOOUTDATA_18(0x00);
0001ca  2000              MOVS     r0,#0
0001cc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1487   	SSD1963GPIOOUTDATA_18(0x00);
0001d0  2000              MOVS     r0,#0
0001d2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1488   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
0001d6  200e              MOVS     r0,#0xe
0001d8  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1489   	SSD1963GPIOOUTDATA_18(0x00);
0001dc  2000              MOVS     r0,#0
0001de  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1490   	MDelay(10);
0001e2  200a              MOVS     r0,#0xa
0001e4  f7fffffe          BL       MDelay
;;;1491   
;;;1492   	/////////////set otp_prog = 1;
;;;1493   			SSD1963GPIOOUTCOM(0xBC);		                 
0001e8  20bc              MOVS     r0,#0xbc
0001ea  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1494   	SSD1963GPIOOUTDATA_16(0x0006);						  
0001ee  2006              MOVS     r0,#6
0001f0  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1495   			SSD1963GPIOOUTCOM(0xbf);
0001f4  20bf              MOVS     r0,#0xbf
0001f6  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1496   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0001fa  20b7              MOVS     r0,#0xb7
0001fc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1497   	SSD1963GPIOOUTDATA_18(0x5a);
000200  205a              MOVS     r0,#0x5a
000202  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1498   	SSD1963GPIOOUTDATA_18(0x00);
000206  2000              MOVS     r0,#0
000208  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1499   	SSD1963GPIOOUTDATA_18(0x00);
00020c  2000              MOVS     r0,#0
00020e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1500   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
000212  200e              MOVS     r0,#0xe
000214  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1501   	SSD1963GPIOOUTDATA_18(0x01);
000218  2001              MOVS     r0,#1
00021a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1502   	MDelay(45);		 		///DELAY 11ms
00021e  202d              MOVS     r0,#0x2d
000220  f7fffffe          BL       MDelay
;;;1503   
;;;1504      	//////MTP   OVER ,,,OTP  Disable
;;;1505   			SSD1963GPIOOUTCOM(0xBC);		                 
000224  20bc              MOVS     r0,#0xbc
000226  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1506   	SSD1963GPIOOUTDATA_16(0x0002);						  
00022a  2002              MOVS     r0,#2
00022c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1507   			SSD1963GPIOOUTCOM(0xbf);
000230  20bf              MOVS     r0,#0xbf
000232  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1508   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000236  20b7              MOVS     r0,#0xb7
000238  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1509   	SSD1963GPIOOUTDATA_18(0xff);
00023c  20ff              MOVS     r0,#0xff
00023e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1510   	MDelay(10);
000242  200a              MOVS     r0,#0xa
000244  f7fffffe          BL       MDelay
;;;1511   
;;;1512   	///display on
;;;1513   			SSD1963GPIOOUTCOM(0xBC);		                
000248  20bc              MOVS     r0,#0xbc
00024a  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1514   	SSD1963GPIOOUTDATA_16(0x0001);					
00024e  2001              MOVS     r0,#1
000250  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1515   			SSD1963GPIOOUTCOM(0xbf);
000254  20bf              MOVS     r0,#0xbf
000256  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1516   	SSD1963GPIOOUTDATA_18(0x29);	  //
00025a  2029              MOVS     r0,#0x29
00025c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1517   	Delay(5);			 //delay 40ms
000260  e8bd4010          POP      {r4,lr}
000264  2005              MOVS     r0,#5
000266  f7ffbffe          B.W      Delay
;;;1518   }
;;;1519   
                          ENDP


                          AREA ||i.MTP_ID||, CODE, READONLY, ALIGN=2

                  MTP_ID PROC
;;;1667   
;;;1668   void MTP_ID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1669   {
000002  b084              SUB      sp,sp,#0x10
;;;1670   	MIPI_SPI_Write(0x05,0x39, 0xB9,0xFF,0x83,0x69);//EXTC Command Set enable register
000004  2169              MOVS     r1,#0x69
000006  2083              MOVS     r0,#0x83
000008  e9cd0100          STRD     r0,r1,[sp,#0]
00000c  23ff              MOVS     r3,#0xff
00000e  22b9              MOVS     r2,#0xb9
000010  2139              MOVS     r1,#0x39
000012  2005              MOVS     r0,#5
000014  f7fffffe          BL       MIPI_SPI_Write
;;;1671   
;;;1672   //	MIPI_SPI_Write(0x05,0x39, 0xBF,0xE0,0x00,0x00);
;;;1673   	
;;;1674   //	OPEN_OTP_Voltage;//Open 7.5V
;;;1675   	Delay(50);//Wait 500ms for PVSS stable	8369 no delay time
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       Delay
;;;1676   	
;;;1677   //	MIPI_SPI_Write(0x05,0x39, 0xB6,VCOMDC,0x28);//This command is used to set VCOM Voltage include VCOM Low and VCOM High Voltage.
;;;1678   	MIPI_SPI_Write(0x04,0x39, 0xB6,VCOMDC1,VCOMDC1);
00001e  4833              LDR      r0,|L15.236|
000020  22b6              MOVS     r2,#0xb6
000022  2139              MOVS     r1,#0x39
000024  8ac3              LDRH     r3,[r0,#0x16]  ; VCOMDC1
000026  2004              MOVS     r0,#4
000028  9300              STR      r3,[sp,#0]
00002a  f7fffffe          BL       MIPI_SPI_Write
;;;1679   	
;;;1680   	MIPI_SPI_Write(0x05,0x39, 0xE9,0xAA,0x55);// This command is used to set OTP key to enter or leave OTP program mode.
00002e  2055              MOVS     r0,#0x55
000030  9000              STR      r0,[sp,#0]
000032  23aa              MOVS     r3,#0xaa
000034  22e9              MOVS     r2,#0xe9
000036  2139              MOVS     r1,#0x39
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       MIPI_SPI_Write
;;;1681   	Delay(50);//Wait 500ms for PVSS stable 8369 no delay time
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       Delay
;;;1682   
;;;1683   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x00);
000044  2400              MOVS     r4,#0
000046  251c              MOVS     r5,#0x1c
000048  e9cd4500          STRD     r4,r5,[sp,#0]
00004c  4623              MOV      r3,r4
00004e  22bb              MOVS     r2,#0xbb
000050  2139              MOVS     r1,#0x39
000052  2006              MOVS     r0,#6
000054  9402              STR      r4,[sp,#8]
000056  f7fffffe          BL       MIPI_SPI_Write
;;;1684   
;;;1685   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x01);
00005a  2601              MOVS     r6,#1
00005c  2300              MOVS     r3,#0
00005e  22bb              MOVS     r2,#0xbb
000060  2139              MOVS     r1,#0x39
000062  2006              MOVS     r0,#6
000064  9602              STR      r6,[sp,#8]
000066  e9cd4500          STRD     r4,r5,[sp,#0]
00006a  f7fffffe          BL       MIPI_SPI_Write
;;;1686   	Delay(5);
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       Delay
000074  e9cd4500          STRD     r4,r5,[sp,#0]
;;;1687   
;;;1688   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x00);
000078  2300              MOVS     r3,#0
00007a  22bb              MOVS     r2,#0xbb
00007c  2139              MOVS     r1,#0x39
00007e  2006              MOVS     r0,#6
000080  9402              STR      r4,[sp,#8]
000082  f7fffffe          BL       MIPI_SPI_Write
;;;1689   	Delay(5);
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       Delay
;;;1690   
;;;1691   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x00);
00008c  251d              MOVS     r5,#0x1d
00008e  e9cd4500          STRD     r4,r5,[sp,#0]
000092  2300              MOVS     r3,#0
000094  22bb              MOVS     r2,#0xbb
000096  2139              MOVS     r1,#0x39
000098  2006              MOVS     r0,#6
00009a  9402              STR      r4,[sp,#8]
00009c  f7fffffe          BL       MIPI_SPI_Write
;;;1692   	Delay(5);
0000a0  2005              MOVS     r0,#5
0000a2  f7fffffe          BL       Delay
;;;1693   
;;;1694   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x01);
0000a6  2300              MOVS     r3,#0
0000a8  22bb              MOVS     r2,#0xbb
0000aa  2139              MOVS     r1,#0x39
0000ac  2006              MOVS     r0,#6
0000ae  9602              STR      r6,[sp,#8]
0000b0  e9cd4500          STRD     r4,r5,[sp,#0]
0000b4  f7fffffe          BL       MIPI_SPI_Write
;;;1695   	Delay(5);
0000b8  2005              MOVS     r0,#5
0000ba  f7fffffe          BL       Delay
0000be  e9cd4500          STRD     r4,r5,[sp,#0]
;;;1696   
;;;1697   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x00);
0000c2  2300              MOVS     r3,#0
0000c4  22bb              MOVS     r2,#0xbb
0000c6  2139              MOVS     r1,#0x39
0000c8  2006              MOVS     r0,#6
0000ca  9402              STR      r4,[sp,#8]
0000cc  f7fffffe          BL       MIPI_SPI_Write
;;;1698   	Delay(5);
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       Delay
;;;1699   
;;;1700   	initial_OTP();
0000d6  f7fffffe          BL       initial_OTP
;;;1701   
;;;1702   	MIPI_SPI_Write(0x06,0x39, 0xE9,0x00,0x00);//set OTP off
0000da  2300              MOVS     r3,#0
0000dc  22e9              MOVS     r2,#0xe9
0000de  2139              MOVS     r1,#0x39
0000e0  2006              MOVS     r0,#6
0000e2  9400              STR      r4,[sp,#0]
0000e4  f7fffffe          BL       MIPI_SPI_Write
;;;1703   
;;;1704   //	CLOSE_OTP_Voltage;//Close 7.5V 
;;;1705   //	Delay(10);//Wait 10ms	8369 no delay time
;;;1706   //	
;;;1707   //	SSD1963Command_8(0xBa); 
;;;1708   //	SSD1963Data_8(0x0E);   //RESET=0
;;;1709   //	Delay(12);
;;;1710   //	SSD1963Command_8(0xBa); 
;;;1711   //	SSD1963Data_8(0x0F);   //RESET=1 
;;;1712   //	Delay(12);
;;;1713   //	
;;;1714   //	SSD1963INITSSD2825();
;;;1715   //	OTP_initial();//GPI009A0 (HX8369-A01) initial code
;;;1716   	
;;;1717   	
;;;1718   }
0000e8  b004              ADD      sp,sp,#0x10
0000ea  bd70              POP      {r4-r6,pc}
;;;1719   
                          ENDP

                  |L15.236|
                          DCD      ||.data||

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;912    *******************************************************************************/
;;;913    void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;914    {
;;;915    //------------zp2000--------------------------------
;;;916      NVIC_InitTypeDef NVIC_InitStructure;
;;;917    
;;;918      /* Configure the NVIC Preemption Priority Bits */
;;;919      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);//该函数调用了两次
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;920    
;;;921      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQChannel;
00000a  2031              MOVS     r0,#0x31
00000c  f88d0000          STRB     r0,[sp,#0]
;;;922      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2400              MOVS     r4,#0
000012  f88d4001          STRB     r4,[sp,#1]
;;;923      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  f88d4002          STRB     r4,[sp,#2]
;;;924      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2501              MOVS     r5,#1
00001c  f88d5003          STRB     r5,[sp,#3]
;;;925      NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;926    
;;;927      /* Enable the RTC Interrupt */
;;;928      NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
000026  2003              MOVS     r0,#3
000028  f88d0000          STRB     r0,[sp,#0]
;;;929      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002c  f88d5001          STRB     r5,[sp,#1]
;;;930      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000030  f88d4002          STRB     r4,[sp,#2]
;;;931      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000034  f88d5003          STRB     r5,[sp,#3]
;;;932      NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;933    
;;;934    #ifdef  VECT_TAB_RAM  
;;;935      /* Set the Vector Table base location at 0x20000000 */ 
;;;936      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;937    #else  /* VECT_TAB_FLASH  */
;;;938      /* Set the Vector Table base location at 0x08000000 */ 
;;;939      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
00003e  2100              MOVS     r1,#0
000040  06e8              LSLS     r0,r5,#27
000042  f7fffffe          BL       NVIC_SetVectorTable
;;;940    #endif
;;;941    
;;;942    }
000046  bd38              POP      {r3-r5,pc}
;;;943    
                          ENDP


                          AREA ||i.OTP_ERROR||, CODE, READONLY, ALIGN=2

                  OTP_ERROR PROC
;;;489    
;;;490    void OTP_ERROR(void)
000000  4c0b              LDR      r4,|L17.48|
;;;491    {
;;;492    		
;;;493    	FontR = 50; FontG = 255; FontB = 50;
000002  4e0c              LDR      r6,|L17.52|
000004  2032              MOVS     r0,#0x32
000006  4f0c              LDR      r7,|L17.56|
000008  7020              STRB     r0,[r4,#0]
00000a  25ff              MOVS     r5,#0xff
00000c  7035              STRB     r5,[r6,#0]
00000e  7038              STRB     r0,[r7,#0]
;;;494    	LCD_DisplayStringLine(20,100,"Flicker OTP NG");		
000010  a20a              ADR      r2,|L17.60|
000012  2164              MOVS     r1,#0x64
000014  2014              MOVS     r0,#0x14
000016  f7fffffe          BL       LCD_DisplayStringLine
;;;495    	FontR = 255; FontG = 0; FontB = 0;
00001a  7025              STRB     r5,[r4,#0]
00001c  2000              MOVS     r0,#0
00001e  7030              STRB     r0,[r6,#0]
000020  7038              STRB     r0,[r7,#0]
;;;496    	LCD_DisplayStringLine(20,130,"Reset do flicker OTP again!"); //	DelayKEY(100);
000022  a20a              ADR      r2,|L17.76|
000024  2182              MOVS     r1,#0x82
000026  2014              MOVS     r0,#0x14
000028  f7fffffe          BL       LCD_DisplayStringLine
                  |L17.44|
;;;497    	while(1);
00002c  e7fe              B        |L17.44|
;;;498    }
;;;499    
                          ENDP

00002e  0000              DCW      0x0000
                  |L17.48|
                          DCD      FontR
                  |L17.52|
                          DCD      FontG
                  |L17.56|
                          DCD      FontB
                  |L17.60|
00003c  466c6963          DCB      "Flicker OTP NG",0
000040  6b657220
000044  4f545020
000048  4e4700  
00004b  00                DCB      0
                  |L17.76|
00004c  52657365          DCB      "Reset do flicker OTP again!",0
000050  7420646f
000054  20666c69
000058  636b6572
00005c  204f5450
000060  20616761
000064  696e2100

                          AREA ||i.OTP_NO||, CODE, READONLY, ALIGN=2

                  OTP_NO PROC
;;;499    
;;;500    void OTP_NO(void)
000000  4e0e              LDR      r6,|L18.60|
;;;501    {
;;;502    	while(1)
;;;503    	{
;;;504    		
;;;505    		LCD_DisplayStringLine_A(10,700,"OTP");
;;;506    		FontR = 255; FontG = FontB = 0;
000002  4d0f              LDR      r5,|L18.64|
000004  4f0f              LDR      r7,|L18.68|
000006  2400              MOVS     r4,#0                 ;501
000008  f04f08ff          MOV      r8,#0xff
                  |L18.12|
00000c  a20e              ADR      r2,|L18.72|
00000e  f44f712f          MOV      r1,#0x2bc             ;505
000012  200a              MOVS     r0,#0xa               ;505
000014  f7fffffe          BL       LCD_DisplayStringLine_A
000018  f8868000          STRB     r8,[r6,#0]
00001c  702c              STRB     r4,[r5,#0]
00001e  703c              STRB     r4,[r7,#0]
;;;507    		LCD_DisplayStringLine_A(160,700,"NO");
000020  a20a              ADR      r2,|L18.76|
000022  f44f712f          MOV      r1,#0x2bc
000026  20a0              MOVS     r0,#0xa0
000028  f7fffffe          BL       LCD_DisplayStringLine_A
;;;508    		Delay(100);
00002c  2064              MOVS     r0,#0x64
00002e  f7fffffe          BL       Delay
;;;509    		FontR = FontG = FontB = 0;	
000032  702c              STRB     r4,[r5,#0]
000034  703c              STRB     r4,[r7,#0]
000036  7034              STRB     r4,[r6,#0]
000038  e7e8              B        |L18.12|
;;;510    	}
;;;511    }
;;;512    
                          ENDP

00003a  0000              DCW      0x0000
                  |L18.60|
                          DCD      FontR
                  |L18.64|
                          DCD      FontB
                  |L18.68|
                          DCD      FontG
                  |L18.72|
000048  4f545000          DCB      "OTP",0
                  |L18.76|
00004c  4e4f00            DCB      "NO",0
00004f  00                DCB      0

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;854    *******************************************************************************/
;;;855    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;856    {   
;;;857      /* RCC system reset(for debug purpose) */
;;;858      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;859    
;;;860      /* Enable HSE */
;;;861      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;862    
;;;863      /* Wait till HSE is ready */
;;;864      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4918              LDR      r1,|L19.116|
;;;865    
;;;866      if(HSEStartUpStatus == SUCCESS)
000014  2801              CMP      r0,#1
000016  7348              STRB     r0,[r1,#0xd]          ;864
000018  d124              BNE      |L19.100|
;;;867      {
;;;868        /* Enable Prefetch Buffer */
;;;869        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;870    
;;;871        /* Flash 2 wait state */
;;;872        FLASH_SetLatency(FLASH_Latency_2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
;;;873     	
;;;874        /* HCLK = SYSCLK */
;;;875        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
;;;876      
;;;877        /* PCLK2 = HCLK */
;;;878        RCC_PCLK2Config(RCC_HCLK_Div1); 
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
;;;879    
;;;880        /* PCLK1 = HCLK/2 */
;;;881        RCC_PCLK1Config(RCC_HCLK_Div2);
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
;;;882    
;;;883        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;884        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
;;;885    
;;;886        /* Enable PLL */ 
;;;887        RCC_PLLCmd(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L19.76|
;;;888    
;;;889        /* Wait till PLL is ready */
;;;890        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L19.76|
;;;891        {
;;;892        }
;;;893    
;;;894        /* Select PLL as system clock source */
;;;895        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L19.92|
;;;896    
;;;897        /* Wait till PLL is used as system clock source */
;;;898        while(RCC_GetSYSCLKSource() != 0x08)
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L19.92|
                  |L19.100|
;;;899        {
;;;900        }
;;;901      }
;;;902      /* Enable USART1 and GPIOA clock */
;;;903      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
000064  e8bd4010          POP      {r4,lr}
000068  2101              MOVS     r1,#1
00006a  f2440004          MOV      r0,#0x4004
00006e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;904    }
;;;905    
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      ||.data||

                          AREA ||i.READ_SSD2825||, CODE, READONLY, ALIGN=2

                  READ_SSD2825 PROC
;;;528    
;;;529    void READ_SSD2825(u8 cmd)
000000  b500              PUSH     {lr}
;;;530    {
000002  b083              SUB      sp,sp,#0xc
;;;531    	u16 R_data=0;
;;;532    	u32 sdcap=0;
;;;533    	u8 TCH[6];
;;;534    
;;;535    	R_data = SSD2825_READ(cmd);
000004  f7fffffe          BL       SSD2825_READ
;;;536    
;;;537    
;;;538    	sdcap=R_data;
;;;539    	   TCH[5]=0;
000008  2100              MOVS     r1,#0
;;;540    	   TCH[4]=(sdcap%10+0x30);sdcap/=10;
00000a  4b22              LDR      r3,|L20.148|
00000c  f88d1005          STRB     r1,[sp,#5]            ;539
000010  fba32100          UMULL    r2,r1,r3,r0
000014  08c9              LSRS     r1,r1,#3
000016  424a              RSBS     r2,r1,#0
000018  eb020282          ADD      r2,r2,r2,LSL #2
00001c  eb000042          ADD      r0,r0,r2,LSL #1
000020  3030              ADDS     r0,r0,#0x30
000022  f88d0004          STRB     r0,[sp,#4]
;;;541    	   TCH[3]=(sdcap%10+0x30);sdcap/=10;
000026  fba32001          UMULL    r2,r0,r3,r1
00002a  08c2              LSRS     r2,r0,#3
00002c  4250              RSBS     r0,r2,#0
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  eb010040          ADD      r0,r1,r0,LSL #1
000036  3030              ADDS     r0,r0,#0x30
000038  f88d0003          STRB     r0,[sp,#3]
;;;542    	   TCH[2]=(sdcap%10+0x30);sdcap/=10;
00003c  fba31002          UMULL    r1,r0,r3,r2
000040  08c0              LSRS     r0,r0,#3
000042  4241              RSBS     r1,r0,#0
000044  eb010181          ADD      r1,r1,r1,LSL #2
000048  eb020141          ADD      r1,r2,r1,LSL #1
00004c  3130              ADDS     r1,r1,#0x30
00004e  f88d1002          STRB     r1,[sp,#2]
;;;543    	   TCH[1]=(sdcap%10+0x30);sdcap/=10;
000052  fba32100          UMULL    r2,r1,r3,r0
000056  08c9              LSRS     r1,r1,#3
000058  424a              RSBS     r2,r1,#0
00005a  eb020282          ADD      r2,r2,r2,LSL #2
00005e  eb000042          ADD      r0,r0,r2,LSL #1
000062  3030              ADDS     r0,r0,#0x30
000064  f88d0001          STRB     r0,[sp,#1]
;;;544    	   TCH[0]=(sdcap%10+0x30);
000068  fba32001          UMULL    r2,r0,r3,r1
00006c  08c0              LSRS     r0,r0,#3
00006e  4240              RSBS     r0,r0,#0
000070  eb000080          ADD      r0,r0,r0,LSL #2
000074  eb010040          ADD      r0,r1,r0,LSL #1
000078  3030              ADDS     r0,r0,#0x30
00007a  f88d0000          STRB     r0,[sp,#0]
;;;545    	    
;;;546    	   LCD_DisplayStringLine(95,40,TCH);
00007e  466a              MOV      r2,sp
000080  2128              MOVS     r1,#0x28
000082  205f              MOVS     r0,#0x5f
000084  f7fffffe          BL       LCD_DisplayStringLine
;;;547    	   DelayKEY(30);
000088  201e              MOVS     r0,#0x1e
00008a  f7fffffe          BL       DelayKEY
;;;548    }
00008e  b003              ADD      sp,sp,#0xc
000090  bd00              POP      {pc}
;;;549    
                          ENDP

000092  0000              DCW      0x0000
                  |L20.148|
                          DCD      0xcccccccd

                          AREA ||i.SDPicShow||, CODE, READONLY, ALIGN=2

                  SDPicShow PROC
;;;550    
;;;551    void SDPicShow(u8 pic)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;552    {
;;;553    	u8 k;
;;;554    	k = 0;
;;;555    		SDShowFlag = 1;
000004  4f0f              LDR      r7,|L21.68|
000006  4605              MOV      r5,r0                 ;552
000008  2001              MOVS     r0,#1
;;;556    		SDShowTimes = 1;
;;;557    
;;;558    		image_count = pic;
00000a  4e0f              LDR      r6,|L21.72|
00000c  70b8              STRB     r0,[r7,#2]            ;555
00000e  70f8              STRB     r0,[r7,#3]            ;556
000010  2400              MOVS     r4,#0                 ;554
000012  8035              STRH     r5,[r6,#0]
                  |L21.20|
;;;559    
;;;560    		while(SDShowFlag) 
;;;561    	{	  
;;;562    	  Disp_BMP() ;
000014  f7fffffe          BL       Disp_BMP
;;;563    	  DelayKEY(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       DelayKEY
;;;564    
;;;565       		if((image_count >= pic)&&(k <= 1))
00001e  8830              LDRH     r0,[r6,#0]  ; image_count
000020  4285              CMP      r5,r0
000022  bf98              IT       LS
000024  2c01              CMPLS    r4,#1
000026  d802              BHI      |L21.46|
;;;566    		{
;;;567    			image_count = pic;
;;;568    			k++;
000028  1c60              ADDS     r0,r4,#1
00002a  8035              STRH     r5,[r6,#0]            ;567
00002c  b2c4              UXTB     r4,r0
                  |L21.46|
;;;569    		}
;;;570    
;;;571    			  //此段为了使用SD卡的指定图片调用；；
;;;572    		if(k >= 1)
00002e  b11c              CBZ      r4,|L21.56|
;;;573    		{
;;;574    			SDShowFlag=0;	
000030  2000              MOVS     r0,#0
000032  70b8              STRB     r0,[r7,#2]
;;;575    		} 
;;;576    
;;;577    	}
;;;578    
;;;579    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L21.56|
000038  78b8              LDRB     r0,[r7,#2]            ;560  ; SDShowFlag
00003a  2800              CMP      r0,#0                 ;560
00003c  d1ea              BNE      |L21.20|
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;580    
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
                          DCD      ||.data||
                  |L21.72|
                          DCD      image_count

                          AREA ||i.SD_InitAndConfig||, CODE, READONLY, ALIGN=2

                  SD_InitAndConfig PROC
;;;1138   /* Private functions ---------------------------------------------------------*/
;;;1139   SD_Error SD_InitAndConfig(void)
000000  b510              PUSH     {r4,lr}
;;;1140   {
;;;1141     Status = SD_Init();
000002  f7fffffe          BL       SD_Init
000006  4c10              LDR      r4,|L22.72|
;;;1142   
;;;1143     if (Status == SD_OK)
000008  282a              CMP      r0,#0x2a
00000a  7020              STRB     r0,[r4,#0]            ;1141
00000c  d119              BNE      |L22.66|
;;;1144     {
;;;1145       /*----------------- Read CSD/CID MSD registers ------------------*/
;;;1146       Status = SD_GetCardInfo(&SDCardInfo);
00000e  480f              LDR      r0,|L22.76|
000010  f7fffffe          BL       SD_GetCardInfo
000014  7020              STRB     r0,[r4,#0]
;;;1147     }
;;;1148     
;;;1149     if (Status == SD_OK)
000016  282a              CMP      r0,#0x2a
000018  d113              BNE      |L22.66|
;;;1150     {
;;;1151       /*----------------- Select Card --------------------------------*/
;;;1152       Status = SD_SelectDeselect((u32) (SDCardInfo.RCA << 16));
00001a  480c              LDR      r0,|L22.76|
00001c  f8b0004c          LDRH     r0,[r0,#0x4c]  ; SDCardInfo
000020  0400              LSLS     r0,r0,#16
000022  f7fffffe          BL       SD_SelectDeselect
000026  7020              STRB     r0,[r4,#0]
;;;1153     }
;;;1154     
;;;1155     if (Status == SD_OK)
000028  282a              CMP      r0,#0x2a
00002a  d10a              BNE      |L22.66|
;;;1156     {
;;;1157       /*----------------- Set BusWidth ------------------------------*/
;;;1158       Status = SD_EnableWideBusOperation(SDIO_BusWide_4b);
00002c  f44f6000          MOV      r0,#0x800
000030  f7fffffe          BL       SD_EnableWideBusOperation
000034  7020              STRB     r0,[r4,#0]
;;;1159     }
;;;1160     
;;;1161     /* Set Device Transfer Mode to INTERRUPT to DMA */
;;;1162     if (Status == SD_OK)
000036  282a              CMP      r0,#0x2a
000038  d103              BNE      |L22.66|
;;;1163     {  
;;;1164       Status = SD_SetDeviceMode(SD_DMA_MODE);//SD_DMA_MODE,SD_INTERRUPT_MODE
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       SD_SetDeviceMode
000040  7020              STRB     r0,[r4,#0]
                  |L22.66|
;;;1165     }
;;;1166     return Status;
000042  b2c0              UXTB     r0,r0
;;;1167   }
000044  bd10              POP      {r4,pc}
;;;1168   
                          ENDP

000046  0000              DCW      0x0000
                  |L22.72|
                          DCD      ||.data||
                  |L22.76|
                          DCD      ||.bss||+0xc

                          AREA ||i.SENSOR_Check||, CODE, READONLY, ALIGN=2

                  SENSOR_Check PROC
;;;1191   
;;;1192   void SENSOR_Check(u8 Device_N)
000000  b510              PUSH     {r4,lr}
;;;1193   {
000002  4604              MOV      r4,r0
;;;1194   	u16 temp1 =0;
;;;1195   //	temp1 = I2C_READ_BYTE(Device_N,0x9e);  /////ADC channel 0 data0low
;;;1196   	temp1 = sensor_check(Device_N);
000004  f7fffffe          BL       sensor_check
;;;1197   	if(temp1 == 0)	  
000008  2800              CMP      r0,#0
;;;1198   	{	
;;;1199   //		Delay(1);	
;;;1200   		;
;;;1201   	}
;;;1202   //	else if	(temp1 == 0)	 	
;;;1203   //	{
;;;1204   //		;	
;;;1205   ////		Delay(1);	
;;;1206   //	}
;;;1207   	else
;;;1208   	{
;;;1209   		while(1)
;;;1210   		{
;;;1211   			if(Device_N == S3_addr)	  {		LCD_DisplayStringLine(100,80,"S3");		}
;;;1212   			if(Device_N == S2_addr)	  {		LCD_DisplayStringLine(140,80,"S2");		}
;;;1213   			if(Device_N == S1_addr)	  {		LCD_DisplayStringLine(180,80,"S1");		}
;;;1214   
;;;1215   			LCD_DisplayStringLine(20,50,"sensor  error");		//红色高亮显示sensor error，警示光感失灵，暂停在此处。
;;;1216   			while(1);
;;;1217   		}
;;;1218   	}	
;;;1219   }
00000a  bf08              IT       EQ
00000c  bd10              POPEQ    {r4,pc}
00000e  2c52              CMP      r4,#0x52              ;1211
000010  d004              BEQ      |L23.28|
000012  2c72              CMP      r4,#0x72              ;1212
000014  d006              BEQ      |L23.36|
000016  2c92              CMP      r4,#0x92              ;1213
000018  d00a              BEQ      |L23.48|
00001a  e00e              B        |L23.58|
                  |L23.28|
00001c  2150              MOVS     r1,#0x50              ;1211
00001e  a20a              ADR      r2,|L23.72|
000020  2064              MOVS     r0,#0x64              ;1211
000022  e002              B        |L23.42|
                  |L23.36|
000024  a209              ADR      r2,|L23.76|
000026  2150              MOVS     r1,#0x50              ;1212
000028  208c              MOVS     r0,#0x8c              ;1212
                  |L23.42|
00002a  f7fffffe          BL       LCD_DisplayStringLine
00002e  e004              B        |L23.58|
                  |L23.48|
000030  a207              ADR      r2,|L23.80|
000032  2150              MOVS     r1,#0x50              ;1213
000034  20b4              MOVS     r0,#0xb4              ;1213
000036  f7fffffe          BL       LCD_DisplayStringLine
                  |L23.58|
00003a  a206              ADR      r2,|L23.84|
00003c  2132              MOVS     r1,#0x32              ;1215
00003e  2014              MOVS     r0,#0x14              ;1215
000040  f7fffffe          BL       LCD_DisplayStringLine
                  |L23.68|
000044  e7fe              B        |L23.68|
;;;1220   
                          ENDP

000046  0000              DCW      0x0000
                  |L23.72|
000048  533300            DCB      "S3",0
00004b  00                DCB      0
                  |L23.76|
00004c  533200            DCB      "S2",0
00004f  00                DCB      0
                  |L23.80|
000050  533100            DCB      "S1",0
000053  00                DCB      0
                  |L23.84|
000054  73656e73          DCB      "sensor  error",0
000058  6f722020
00005c  6572726f
000060  7200    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.SHOW_IC_VALUE||, CODE, READONLY, ALIGN=2

                  SHOW_IC_VALUE PROC
;;;581    
;;;582    void SHOW_IC_VALUE(u16 adx,u16 ady,u32 cmd)
000000  b510              PUSH     {r4,lr}
;;;583    {
000002  b082              SUB      sp,sp,#8
;;;584    	
;;;585    //	u16 R_data=0;
;;;586    	u32 sdcap=0;
;;;587    	u8 TCH[7];
;;;588    
;;;589    	sdcap=cmd;
;;;590    	if(sdcap == 0x55)
000004  2a55              CMP      r2,#0x55
;;;591    	{	LCD_DisplayStringLine(adx,ady,"0x55");	}	 			//ID1 = 0X55
000006  bf08              IT       EQ
000008  a227              ADREQ    r2,|L24.168|
00000a  d049              BEQ      |L24.160|
;;;592    	else if(sdcap == 0x44)
00000c  2a44              CMP      r2,#0x44
;;;593    	{	LCD_DisplayStringLine(adx,ady,"0x44");	}			    //ID2 = 0X44
00000e  bf08              IT       EQ
000010  a227              ADREQ    r2,|L24.176|
000012  d045              BEQ      |L24.160|
;;;594    	else if(sdcap == 0xF0)
000014  2af0              CMP      r2,#0xf0
;;;595    	{	LCD_DisplayStringLine(adx,ady,"0xF0");	}			    //ID3 = 0XF0
000016  bf08              IT       EQ
000018  a227              ADREQ    r2,|L24.184|
00001a  d041              BEQ      |L24.160|
;;;596    	else
;;;597    	{
;;;598    	   TCH[6]=0;
00001c  2300              MOVS     r3,#0
00001e  f88d3006          STRB     r3,[sp,#6]
;;;599    	   TCH[5]=0;
;;;600    	   TCH[4]=(sdcap%10+0x30);sdcap/=10;
000022  4c27              LDR      r4,|L24.192|
000024  f88d3005          STRB     r3,[sp,#5]            ;599
000028  fba4c302          UMULL    r12,r3,r4,r2
00002c  08db              LSRS     r3,r3,#3
00002e  f1c30c00          RSB      r12,r3,#0
000032  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000036  eb02024c          ADD      r2,r2,r12,LSL #1
00003a  3230              ADDS     r2,r2,#0x30
00003c  f88d2004          STRB     r2,[sp,#4]
;;;601    	   TCH[3]=(sdcap%10+0x30);sdcap/=10;
000040  fba4c203          UMULL    r12,r2,r4,r3
000044  ea4f0cd2          LSR      r12,r2,#3
000048  f1cc0200          RSB      r2,r12,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb030242          ADD      r2,r3,r2,LSL #1
000054  3230              ADDS     r2,r2,#0x30
000056  f88d2003          STRB     r2,[sp,#3]
;;;602    	   TCH[2]=(sdcap%10+0x30);sdcap/=10;
00005a  fba4320c          UMULL    r3,r2,r4,r12
00005e  08d2              LSRS     r2,r2,#3
000060  4253              RSBS     r3,r2,#0
000062  eb030383          ADD      r3,r3,r3,LSL #2
000066  eb0c0343          ADD      r3,r12,r3,LSL #1
00006a  3330              ADDS     r3,r3,#0x30
00006c  f88d3002          STRB     r3,[sp,#2]
;;;603    	   TCH[1]=(sdcap%10+0x30);sdcap/=10;
000070  fba4c302          UMULL    r12,r3,r4,r2
000074  08db              LSRS     r3,r3,#3
000076  f1c30c00          RSB      r12,r3,#0
00007a  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00007e  eb02024c          ADD      r2,r2,r12,LSL #1
000082  3230              ADDS     r2,r2,#0x30
000084  f88d2001          STRB     r2,[sp,#1]
;;;604    	   TCH[0]=(sdcap%10+0x30);
000088  fba4c203          UMULL    r12,r2,r4,r3
00008c  08d2              LSRS     r2,r2,#3
00008e  4252              RSBS     r2,r2,#0
000090  eb020282          ADD      r2,r2,r2,LSL #2
000094  eb030242          ADD      r2,r3,r2,LSL #1
000098  3230              ADDS     r2,r2,#0x30
00009a  f88d2000          STRB     r2,[sp,#0]
;;;605    	    
;;;606    	   LCD_DisplayStringLine(adx,ady,TCH);
00009e  466a              MOV      r2,sp
                  |L24.160|
0000a0  f7fffffe          BL       LCD_DisplayStringLine
;;;607    	}
;;;608    }
0000a4  b002              ADD      sp,sp,#8
0000a6  bd10              POP      {r4,pc}
;;;609    
                          ENDP

                  |L24.168|
0000a8  30783535          DCB      "0x55",0
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L24.176|
0000b0  30783434          DCB      "0x44",0
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L24.184|
0000b8  30784630          DCB      "0xF0",0
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L24.192|
                          DCD      0xcccccccd

                          AREA ||i.SHOW_IC_VALUE_A||, CODE, READONLY, ALIGN=2

                  SHOW_IC_VALUE_A PROC
;;;609    
;;;610    void SHOW_IC_VALUE_A(u16 adx,u16 n,u8 data)           //被调函数要在调用函数之前！
000000  b570              PUSH     {r4-r6,lr}
;;;611    {
;;;612        u8 table[17]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','\0'};
000002  a312              ADR      r3,|L25.76|
000004  b088              SUB      sp,sp,#0x20           ;611
000006  e8931070          LDM      r3,{r4-r6,r12}
00000a  e88d1070          STM      sp,{r4-r6,r12}
00000e  691b              LDR      r3,[r3,#0x10]
;;;613        u8 value[5]={0};
000010  9304              STR      r3,[sp,#0x10]
000012  2300              MOVS     r3,#0
000014  9305              STR      r3,[sp,#0x14]
;;;614        u16 temp;  
;;;615        
;;;616    //    temp=data>>12;
;;;617    //    temp=temp&0x0f;
;;;618    //    value[0]=table[temp];
;;;619    //    temp=data>>8;
;;;620    //    temp=temp&0x0f;
;;;621    //    value[1]=table[temp];			 ///屏蔽掉的代a16位字符@示
;;;622        value[0]=0x30;	//////底0
000016  9306              STR      r3,[sp,#0x18]
000018  2330              MOVS     r3,#0x30
00001a  f88d3014          STRB     r3,[sp,#0x14]
;;;623    	value[1]=0x78;	//////小x		 ///定值8位字符@示的0x
00001e  2378              MOVS     r3,#0x78
000020  f88d3015          STRB     r3,[sp,#0x15]
;;;624    	temp=data>>4;
000024  0913              LSRS     r3,r2,#4
;;;625        temp=temp&0x0f;
;;;626        value[2]=table[temp];
;;;627        temp=data;
;;;628        temp=temp&0x0f;
000026  f002020f          AND      r2,r2,#0xf
00002a  f81d3003          LDRB     r3,[sp,r3]            ;626
00002e  f88d3016          STRB     r3,[sp,#0x16]         ;626
;;;629        value[3]=table[temp];
000032  f81d2002          LDRB     r2,[sp,r2]
000036  f88d2017          STRB     r2,[sp,#0x17]
;;;630        value[4]=table[16];
00003a  f89d2010          LDRB     r2,[sp,#0x10]
00003e  f88d2018          STRB     r2,[sp,#0x18]
;;;631    
;;;632        LCD_DisplayStringLine(adx,n,value);
000042  aa05              ADD      r2,sp,#0x14
000044  f7fffffe          BL       LCD_DisplayStringLine
;;;633    }
000048  b008              ADD      sp,sp,#0x20
00004a  bd70              POP      {r4-r6,pc}
;;;634    
                          ENDP

                  |L25.76|
00004c  30313233          DCB      "0123456789ABCDEF",0
000050  34353637
000054  38394142
000058  43444546
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.SHOW_value||, CODE, READONLY, ALIGN=2

                  SHOW_value PROC
;;;512    
;;;513    void SHOW_value(u16 addx,u16 addy,u32 Data)
000000  b510              PUSH     {r4,lr}
;;;514    {
000002  b082              SUB      sp,sp,#8
;;;515    	u32 sdcap;
;;;516    	u8 TCH[7];
;;;517    
;;;518    	sdcap = Data;
;;;519    	TCH[4]=0;
000004  2300              MOVS     r3,#0
;;;520    	TCH[3]=(sdcap%10+0x30);sdcap/=10;
000006  4c1b              LDR      r4,|L26.116|
000008  f88d3004          STRB     r3,[sp,#4]            ;519
00000c  fba4c302          UMULL    r12,r3,r4,r2
000010  08db              LSRS     r3,r3,#3
000012  f1c30c00          RSB      r12,r3,#0
000016  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00001a  eb02024c          ADD      r2,r2,r12,LSL #1
00001e  3230              ADDS     r2,r2,#0x30
000020  f88d2003          STRB     r2,[sp,#3]
;;;521    	TCH[2]=(sdcap%10+0x30);sdcap/=10;
000024  fba4c203          UMULL    r12,r2,r4,r3
000028  08d2              LSRS     r2,r2,#3
00002a  f1c20c00          RSB      r12,r2,#0
00002e  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000032  eb03034c          ADD      r3,r3,r12,LSL #1
000036  3330              ADDS     r3,r3,#0x30
000038  f88d3002          STRB     r3,[sp,#2]
;;;522    	TCH[1]=(sdcap%10+0x30);sdcap/=10;
00003c  fba4c302          UMULL    r12,r3,r4,r2
000040  08db              LSRS     r3,r3,#3
000042  f1c30c00          RSB      r12,r3,#0
000046  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00004a  eb02024c          ADD      r2,r2,r12,LSL #1
00004e  3230              ADDS     r2,r2,#0x30
000050  f88d2001          STRB     r2,[sp,#1]
;;;523    	TCH[0]=(sdcap%10+0x30);
000054  fba4c203          UMULL    r12,r2,r4,r3
000058  08d2              LSRS     r2,r2,#3
00005a  4252              RSBS     r2,r2,#0
00005c  eb020282          ADD      r2,r2,r2,LSL #2
000060  eb030242          ADD      r2,r3,r2,LSL #1
000064  3230              ADDS     r2,r2,#0x30
000066  f88d2000          STRB     r2,[sp,#0]
;;;524    
;;;525    	LCD_DisplayStringLine(addx,addy,TCH);
00006a  466a              MOV      r2,sp
00006c  f7fffffe          BL       LCD_DisplayStringLine
;;;526    
;;;527    }
000070  b002              ADD      sp,sp,#8
000072  bd10              POP      {r4,pc}
;;;528    
                          ENDP

                  |L26.116|
                          DCD      0xcccccccd

                          AREA ||i.SysTick_Config||, CODE, READONLY, ALIGN=2

                  SysTick_Config PROC
;;;1017   *******************************************************************************/
;;;1018   void SysTick_Config(void)
000000  b510              PUSH     {r4,lr}
;;;1019   {
;;;1020     /* Configure HCLK clock as SysTick clock source */
;;;1021     SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;1022    
;;;1023     /* SysTick interrupt each 100 Hz with HCLK equal to 72MHz */
;;;1024     SysTick_SetReload(72000);
000008  4805              LDR      r0,|L27.32|
00000a  f7fffffe          BL       SysTick_SetReload
;;;1025   
;;;1026     /* Enable the SysTick Interrupt */
;;;1027     SysTick_ITConfig(DISABLE);//ENABLE DISABLE
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       SysTick_ITConfig
;;;1028   
;;;1029     /* Enable the SysTick Counter */
;;;1030     SysTick_CounterCmd(SysTick_Counter_Enable);
000014  e8bd4010          POP      {r4,lr}
000018  2001              MOVS     r0,#1
00001a  f7ffbffe          B.W      SysTick_CounterCmd
;;;1031   }
;;;1032   //----设定按键接口--------------
                          ENDP

00001e  0000              DCW      0x0000
                  |L27.32|
                          DCD      0x00011940

                          AREA ||i.USART1GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  USART1GPIO_Configuration PROC
;;;1120   *******************************************************************************/
;;;1121   void USART1GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1122   {
;;;1123     GPIO_InitTypeDef GPIO_InitStructure;
;;;1124   
;;;1125     /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;1126     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;1127     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;1128     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
;;;1129     GPIO_Init(GPIOA, &GPIO_InitStructure);
000012  4c09              LDR      r4,|L28.56|
000014  f88d0002          STRB     r0,[sp,#2]            ;1128
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       GPIO_Init
;;;1130       
;;;1131     /* Configure USART1 Rx (PA.10) as input floating */
;;;1132     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000020  1521              ASRS     r1,r4,#20
000022  f8ad1000          STRH     r1,[sp,#0]
;;;1133     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2104              MOVS     r1,#4
000028  f88d1003          STRB     r1,[sp,#3]
;;;1134     GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;1135   }
000034  bd38              POP      {r3-r5,pc}
;;;1136   
                          ENDP

000036  0000              DCW      0x0000
                  |L28.56|
                          DCD      0x40010800

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;1071   
;;;1072   void USART_Configuration(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1073   {
000002  b087              SUB      sp,sp,#0x1c
;;;1074     USART_InitTypeDef USART_InitStructure;
;;;1075     USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;1076   
;;;1077   /* USART1 configuration ------------------------------------------------------*/
;;;1078     /* USART1 configured as follow:
;;;1079           - BaudRate = 115200 baud  
;;;1080           - Word Length = 8 Bits
;;;1081           - One Stop Bit
;;;1082           - No parity
;;;1083           - Hardware flow control disabled (RTS and CTS signals)
;;;1084           - Receive and transmit enabled
;;;1085           - USART Clock disabled
;;;1086           - USART CPOL: Clock is active low
;;;1087           - USART CPHA: Data is captured on the middle 
;;;1088           - USART LastBit: The clock pulse of the last data bit is not output to 
;;;1089                            the SCLK pin
;;;1090     */
;;;1091   USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;1092   USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;1093   USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0014          STRH     r0,[sp,#0x14]
;;;1094   USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;1095   /* Configure the USART1 synchronous paramters */
;;;1096   USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L29.84|
000010  f8ad4010          STRH     r4,[sp,#0x10]         ;1091
000014  f8ad4012          STRH     r4,[sp,#0x12]         ;1092
000018  f8ad4016          STRH     r4,[sp,#0x16]         ;1094
00001c  a904              ADD      r1,sp,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;1097   
;;;1098   USART_InitStructure.USART_BaudRate = 115200;
000024  f44f31e1          MOV      r1,#0x1c200
;;;1099   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9100              STR      r1,[sp,#0]
;;;1100   USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;1101   USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4008          STRH     r4,[sp,#8]
;;;1102   USART_InitStructure.USART_HardwareFlowControl = 
;;;1103   USART_HardwareFlowControl_None;
;;;1104   
;;;1105   USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  210c              MOVS     r1,#0xc
000030  f8ad4004          STRH     r4,[sp,#4]            ;1099
000034  f8ad100a          STRH     r1,[sp,#0xa]
000038  f8ad4006          STRH     r4,[sp,#6]            ;1100
00003c  f8ad400c          STRH     r4,[sp,#0xc]          ;1102
;;;1106   /* Configure USART1 basic and asynchronous paramters */
;;;1107   USART_Init(USART1, &USART_InitStructure);
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;1108       
;;;1109     /* Enable USART1 */
;;;1110     USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;1111     
;;;1112   }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;1113   
                          ENDP

                  |L29.84|
                          DCD      0x40013800

                          AREA ||i.VCOM_GET||, CODE, READONLY, ALIGN=2

                  VCOM_GET PROC
;;;1721   
;;;1722   u8 VCOM_GET(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1723   {
;;;1724   	READ_VCOM_OTP_TIMES_HX8369(0x1B);
000002  201b              MOVS     r0,#0x1b
000004  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
;;;1725   		DelayKEY(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DelayKEY
;;;1726   		switch(MIPI_READ_DATA[4])
00000e  4d38              LDR      r5,|L30.240|
000010  2100              MOVS     r1,#0
;;;1727   		{
;;;1728   			case 0xFF:
;;;1729   				
;;;1730   				OTP_TIMES_BEFORE = 0;
000012  4c38              LDR      r4,|L30.244|
000014  7928              LDRB     r0,[r5,#4]            ;1726  ; MIPI_READ_DATA
000016  2827              CMP      r0,#0x27              ;1726
000018  d035              BEQ      |L30.134|
00001a  dc03              BGT      |L30.36|
00001c  b130              CBZ      r0,|L30.44|
00001e  2803              CMP      r0,#3                 ;1726
000020  d04b              BEQ      |L30.186|
000022  e003              B        |L30.44|
                  |L30.36|
000024  286f              CMP      r0,#0x6f              ;1726
000026  d015              BEQ      |L30.84|
000028  28ff              CMP      r0,#0xff              ;1726
00002a  d007              BEQ      |L30.60|
                  |L30.44|
;;;1731   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1732   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1733   				break;
;;;1734   			
;;;1735   			case 0x6F:
;;;1736   				
;;;1737   				OTP_TIMES_BEFORE = 1;
;;;1738   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1739   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1740   				READ_VCOM_OTP_TIMES_HX8369(0x1C);
;;;1741   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1742   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1743   				break;
;;;1744   			
;;;1745   			case 0x27:
;;;1746   				
;;;1747   				OTP_TIMES_BEFORE = 2;
;;;1748   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1749   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1750   				READ_VCOM_OTP_TIMES_HX8369(0x1E);
;;;1751   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1752   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1753   				break;
;;;1754   			
;;;1755   			case 0x03:
;;;1756   				
;;;1757   				OTP_TIMES_BEFORE = 3;
;;;1758   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1759   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1760   				READ_VCOM_OTP_TIMES_HX8369(0x20);
;;;1761   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1762   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1763   				break;
;;;1764   			
;;;1765   			case 0x00:
;;;1766   				
;;;1767   				OTP_TIMES_BEFORE = 0;
00002c  7261              STRB     r1,[r4,#9]
;;;1768   				LCD_DisplayStringLine(20,10,"otp read error");
00002e  a232              ADR      r2,|L30.248|
000030  210a              MOVS     r1,#0xa
000032  2014              MOVS     r0,#0x14
000034  f7fffffe          BL       LCD_DisplayStringLine
                  |L30.56|
;;;1769   				break;
;;;1770   			
;;;1771   			default:
;;;1772   				
;;;1773   				OTP_TIMES_BEFORE = 0;
;;;1774   				LCD_DisplayStringLine(20,10,"otp read error");
;;;1775   				break;
;;;1776   		}
;;;1777   		
;;;1778   		return 0;
000038  2000              MOVS     r0,#0
;;;1779   }
00003a  bd70              POP      {r4-r6,pc}
                  |L30.60|
00003c  7261              STRB     r1,[r4,#9]            ;1730
00003e  a232              ADR      r2,|L30.264|
000040  210a              MOVS     r1,#0xa               ;1731
000042  2001              MOVS     r0,#1                 ;1731
000044  f7fffffe          BL       LCD_DisplayStringLine
000048  7a62              LDRB     r2,[r4,#9]            ;1732  ; OTP_TIMES_BEFORE
00004a  210a              MOVS     r1,#0xa               ;1732
00004c  20c3              MOVS     r0,#0xc3              ;1732
00004e  f7fffffe          BL       SHOW_IC_VALUE_A
000052  e7f1              B        |L30.56|
                  |L30.84|
000054  2001              MOVS     r0,#1                 ;1737
000056  7260              STRB     r0,[r4,#9]            ;1737
000058  a22b              ADR      r2,|L30.264|
00005a  210a              MOVS     r1,#0xa               ;1738
00005c  f7fffffe          BL       LCD_DisplayStringLine
000060  7a62              LDRB     r2,[r4,#9]            ;1739  ; OTP_TIMES_BEFORE
000062  210a              MOVS     r1,#0xa               ;1739
000064  20c3              MOVS     r0,#0xc3              ;1739
000066  f7fffffe          BL       SHOW_IC_VALUE_A
00006a  201c              MOVS     r0,#0x1c              ;1740
00006c  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
000070  a229              ADR      r2,|L30.280|
000072  2132              MOVS     r1,#0x32              ;1741
000074  2001              MOVS     r0,#1                 ;1741
000076  f7fffffe          BL       LCD_DisplayStringLine
00007a  792a              LDRB     r2,[r5,#4]            ;1742  ; MIPI_READ_DATA
00007c  2132              MOVS     r1,#0x32              ;1742
00007e  20c3              MOVS     r0,#0xc3              ;1742
000080  f7fffffe          BL       SHOW_IC_VALUE_A
000084  e7d8              B        |L30.56|
                  |L30.134|
000086  2002              MOVS     r0,#2                 ;1747
000088  7260              STRB     r0,[r4,#9]            ;1747
00008a  a21f              ADR      r2,|L30.264|
00008c  210a              MOVS     r1,#0xa               ;1748
00008e  2001              MOVS     r0,#1                 ;1748
000090  f7fffffe          BL       LCD_DisplayStringLine
000094  7a62              LDRB     r2,[r4,#9]            ;1749  ; OTP_TIMES_BEFORE
000096  210a              MOVS     r1,#0xa               ;1749
000098  20c3              MOVS     r0,#0xc3              ;1749
00009a  f7fffffe          BL       SHOW_IC_VALUE_A
00009e  201e              MOVS     r0,#0x1e              ;1750
0000a0  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
0000a4  a21c              ADR      r2,|L30.280|
0000a6  2132              MOVS     r1,#0x32              ;1751
0000a8  2001              MOVS     r0,#1                 ;1751
0000aa  f7fffffe          BL       LCD_DisplayStringLine
0000ae  792a              LDRB     r2,[r5,#4]            ;1752  ; MIPI_READ_DATA
0000b0  2132              MOVS     r1,#0x32              ;1752
0000b2  20c3              MOVS     r0,#0xc3              ;1752
0000b4  f7fffffe          BL       SHOW_IC_VALUE_A
0000b8  e7be              B        |L30.56|
                  |L30.186|
0000ba  2003              MOVS     r0,#3                 ;1757
0000bc  7260              STRB     r0,[r4,#9]            ;1757
0000be  a212              ADR      r2,|L30.264|
0000c0  210a              MOVS     r1,#0xa               ;1758
0000c2  2001              MOVS     r0,#1                 ;1758
0000c4  f7fffffe          BL       LCD_DisplayStringLine
0000c8  7a62              LDRB     r2,[r4,#9]            ;1759  ; OTP_TIMES_BEFORE
0000ca  210a              MOVS     r1,#0xa               ;1759
0000cc  20c3              MOVS     r0,#0xc3              ;1759
0000ce  f7fffffe          BL       SHOW_IC_VALUE_A
0000d2  2020              MOVS     r0,#0x20              ;1760
0000d4  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
0000d8  a20f              ADR      r2,|L30.280|
0000da  2132              MOVS     r1,#0x32              ;1761
0000dc  2001              MOVS     r0,#1                 ;1761
0000de  f7fffffe          BL       LCD_DisplayStringLine
0000e2  792a              LDRB     r2,[r5,#4]            ;1762  ; MIPI_READ_DATA
0000e4  2132              MOVS     r1,#0x32              ;1762
0000e6  20c3              MOVS     r0,#0xc3              ;1762
0000e8  f7fffffe          BL       SHOW_IC_VALUE_A
0000ec  e7a4              B        |L30.56|
;;;1780   /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
                          ENDP

0000ee  0000              DCW      0x0000
                  |L30.240|
                          DCD      ||.bss||
                  |L30.244|
                          DCD      ||.data||
                  |L30.248|
0000f8  6f747020          DCB      "otp read error",0
0000fc  72656164
000100  20657272
000104  6f7200  
000107  00                DCB      0
                  |L30.264|
000108  6f747020          DCB      "otp times = ",0
00010c  74696d65
000110  73203d20
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L30.280|
000118  76636f6d          DCB      "vcom value = ",0
00011c  2076616c
000120  7565203d
000124  2000    
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.check_power||, CODE, READONLY, ALIGN=2

                  check_power PROC
;;;390    
;;;391    void check_power(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;392    {
000002  b083              SUB      sp,sp,#0xc
;;;393    	  	ENTER_LP_mode(); //enter  LP mode
000004  f7fffffe          BL       ENTER_LP_mode
;;;394    
;;;395    	 	MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000008  2300              MOVS     r3,#0
00000a  461a              MOV      r2,r3
00000c  2139              MOVS     r1,#0x39
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       MIPI_SPI_Write
;;;396    		MIPI_SPI_Write(0x05,0x39,0xFF,0x80,0x09,0x01);
000014  2501              MOVS     r5,#1
000016  2409              MOVS     r4,#9
000018  2380              MOVS     r3,#0x80
00001a  22ff              MOVS     r2,#0xff
00001c  2139              MOVS     r1,#0x39
00001e  2005              MOVS     r0,#5
000020  e9cd4500          STRD     r4,r5,[sp,#0]
000024  f7fffffe          BL       MIPI_SPI_Write
;;;397    		
;;;398    		MIPI_SPI_Write(0x03,0x39,0x00,0x80);
000028  2380              MOVS     r3,#0x80
00002a  2200              MOVS     r2,#0
00002c  2139              MOVS     r1,#0x39
00002e  2003              MOVS     r0,#3
000030  f7fffffe          BL       MIPI_SPI_Write
;;;399    		MIPI_SPI_Write(0x04,0x39,0xFF,0x80,0x09);
000034  2380              MOVS     r3,#0x80
000036  22ff              MOVS     r2,#0xff
000038  2139              MOVS     r1,#0x39
00003a  2004              MOVS     r0,#4
00003c  9400              STR      r4,[sp,#0]
00003e  f7fffffe          BL       MIPI_SPI_Write
;;;400    
;;;401    		MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000042  2300              MOVS     r3,#0
000044  461a              MOV      r2,r3
000046  2139              MOVS     r1,#0x39
000048  2003              MOVS     r0,#3
00004a  f7fffffe          BL       MIPI_SPI_Write
;;;402    		MIPI_SPI_Write(0x03,0x39,0xD0,0xD5);
00004e  23d5              MOVS     r3,#0xd5
000050  22d0              MOVS     r2,#0xd0
000052  2139              MOVS     r1,#0x39
000054  2003              MOVS     r0,#3
000056  f7fffffe          BL       MIPI_SPI_Write
;;;403    
;;;404    		READ_IC(0XD3,0x00);
00005a  2100              MOVS     r1,#0
00005c  20d3              MOVS     r0,#0xd3
00005e  f7fffffe          BL       READ_IC
;;;405    
;;;406       
;;;407     
;;;408    		if(MIPI_READ_DATA[0] == 0x03)
000062  4c15              LDR      r4,|L31.184|
000064  2000              MOVS     r0,#0
000066  22ff              MOVS     r2,#0xff              ;396
000068  7827              LDRB     r7,[r4,#0]  ; MIPI_READ_DATA
;;;409    		{
;;;410    			ID_OK = 0;
00006a  4914              LDR      r1,|L31.188|
;;;411    			FontR = 0; FontG = 255; FontB = 0;
00006c  4b14              LDR      r3,|L31.192|
00006e  f8dfc054          LDR      r12,|L31.196|
000072  4e15              LDR      r6,|L31.200|
000074  2f03              CMP      r7,#3                 ;408
000076  d018              BEQ      |L31.170|
;;;412    		//		LCD_DisplayStringLine_A( 10 ,800,"otp power OK");
;;;413    		}
;;;414    		else
;;;415    		{
;;;416    			ID_OK = 1;
000078  728d              STRB     r5,[r1,#0xa]
;;;417    			FontR = 255; FontG = 0; FontB = 0;
00007a  701a              STRB     r2,[r3,#0]
00007c  f88c0000          STRB     r0,[r12,#0]
000080  7030              STRB     r0,[r6,#0]
;;;418    			LCD_DisplayStringLine(100,700,"otp  power");
000082  a212              ADR      r2,|L31.204|
000084  f44f712f          MOV      r1,#0x2bc
000088  2064              MOVS     r0,#0x64
00008a  f7fffffe          BL       LCD_DisplayStringLine
;;;419    			SHOW_IC_VALUE_A(300,700,MIPI_READ_DATA[0]);
00008e  7822              LDRB     r2,[r4,#0]  ; MIPI_READ_DATA
000090  f44f712f          MOV      r1,#0x2bc
000094  f44f7096          MOV      r0,#0x12c
000098  f7fffffe          BL       SHOW_IC_VALUE_A
;;;420    			LCD_DisplayStringLine_A( 50 ,800,"otp power NG");
00009c  a20e              ADR      r2,|L31.216|
00009e  f44f7148          MOV      r1,#0x320
0000a2  2032              MOVS     r0,#0x32
0000a4  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L31.168|
;;;421    			while(1);
0000a8  e7fe              B        |L31.168|
                  |L31.170|
0000aa  7288              STRB     r0,[r1,#0xa]          ;410
0000ac  7018              STRB     r0,[r3,#0]            ;411
0000ae  f88c2000          STRB     r2,[r12,#0]           ;411
0000b2  7030              STRB     r0,[r6,#0]            ;411
;;;422    		//		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;423    		}
;;;424    		
;;;425    		////	Delay(5);
;;;426    
;;;427    }
0000b4  b003              ADD      sp,sp,#0xc
0000b6  bdf0              POP      {r4-r7,pc}
;;;428    
                          ENDP

                  |L31.184|
                          DCD      ||.bss||
                  |L31.188|
                          DCD      ||.data||
                  |L31.192|
                          DCD      FontR
                  |L31.196|
                          DCD      FontG
                  |L31.200|
                          DCD      FontB
                  |L31.204|
0000cc  6f747020          DCB      "otp  power",0
0000d0  20706f77
0000d4  657200  
0000d7  00                DCB      0
                  |L31.216|
0000d8  6f747020          DCB      "otp power NG",0
0000dc  706f7765
0000e0  72204e47
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.cycle_OTP||, CODE, READONLY, ALIGN=1

                  cycle_OTP PROC
;;;1520   
;;;1521   void cycle_OTP(u8 OTPValue)
000000  b530              PUSH     {r4,r5,lr}
;;;1522   {
000002  b083              SUB      sp,sp,#0xc
;;;1523   
;;;1524   
;;;1525   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x00);
000004  2500              MOVS     r5,#0
000006  e9cd5000          STRD     r5,r0,[sp,#0]
00000a  4604              MOV      r4,r0                 ;1522
00000c  462b              MOV      r3,r5
00000e  22bb              MOVS     r2,#0xbb
000010  2139              MOVS     r1,#0x39
000012  2006              MOVS     r0,#6
000014  9502              STR      r5,[sp,#8]
000016  f7fffffe          BL       MIPI_SPI_Write
;;;1526   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x01);
00001a  2001              MOVS     r0,#1
00001c  9500              STR      r5,[sp,#0]
00001e  e9cd4001          STRD     r4,r0,[sp,#4]
000022  2300              MOVS     r3,#0
000024  22bb              MOVS     r2,#0xbb
000026  2139              MOVS     r1,#0x39
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       MIPI_SPI_Write
;;;1527   	Delay(5);
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       Delay
000034  e9cd5400          STRD     r5,r4,[sp,#0]
;;;1528   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x00);
000038  2300              MOVS     r3,#0
00003a  22bb              MOVS     r2,#0xbb
00003c  2139              MOVS     r1,#0x39
00003e  2006              MOVS     r0,#6
000040  9502              STR      r5,[sp,#8]
000042  f7fffffe          BL       MIPI_SPI_Write
;;;1529   
;;;1530   }
000046  b003              ADD      sp,sp,#0xc
000048  bd30              POP      {r4,r5,pc}
;;;1531   
                          ENDP


                          AREA ||i.initial_OTP||, CODE, READONLY, ALIGN=1

                  initial_OTP PROC
;;;1531   
;;;1532   void initial_OTP(void)
000000  b510              PUSH     {r4,lr}
;;;1533   {
;;;1534   
;;;1535   //	MIPI_SPI_Write(0x06,0x39, 0xB9,0xFF,0x83,0x69);//EXTC Command Set enable register
;;;1536   //
;;;1537   //	OPEN_OTP_Voltage;//Open 7.5V
;;;1538   //	Delay(50);//Wait 500ms for PVSS stable	8369 no delay time
;;;1539   //
;;;1540   ////	MIPI_SPI_Write(0x06,0x39,0xB6,0x2E,0x2E);	//Set VCOM
;;;1541   //	MIPI_SPI_Write(0x06,0x39,0xE9,0xAA,0x55);	//Set OTP
;;;1542   
;;;1543   //-----------------------GIP timing------------------------//
;;;1544   //	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,0xB3,0x00);
;;;1545   //	MIPI_SPI_Write(0x30,0x39,0xBB,0x00,0x00,0xB3,0x01);
;;;1546   //	Delay(5);
;;;1547   //	MIPI_SPI_Write(0x30,0x39,0xBB,0x00,0x00,0xB3,0x00);
;;;1548   
;;;1549   
;;;1550   
;;;1551   cycle_OTP(0xB0);
000002  20b0              MOVS     r0,#0xb0
000004  f7fffffe          BL       cycle_OTP
;;;1552   cycle_OTP(0xB1);
000008  20b1              MOVS     r0,#0xb1
00000a  f7fffffe          BL       cycle_OTP
;;;1553   cycle_OTP(0xB2);
00000e  20b2              MOVS     r0,#0xb2
000010  f7fffffe          BL       cycle_OTP
;;;1554   cycle_OTP(0xB3);
000014  20b3              MOVS     r0,#0xb3
000016  f7fffffe          BL       cycle_OTP
;;;1555   
;;;1556   //cycle_OTP(0x1C);
;;;1557   //cycle_OTP(0x1D);
;;;1558   
;;;1559   cycle_OTP(0x31);
00001a  2031              MOVS     r0,#0x31
00001c  f7fffffe          BL       cycle_OTP
;;;1560   cycle_OTP(0x32);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       cycle_OTP
;;;1561   cycle_OTP(0x33);
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       cycle_OTP
;;;1562   cycle_OTP(0x34);
00002c  2034              MOVS     r0,#0x34
00002e  f7fffffe          BL       cycle_OTP
;;;1563   cycle_OTP(0x35);
000032  2035              MOVS     r0,#0x35
000034  f7fffffe          BL       cycle_OTP
;;;1564   cycle_OTP(0x36);
000038  2036              MOVS     r0,#0x36
00003a  f7fffffe          BL       cycle_OTP
;;;1565   cycle_OTP(0x37);
00003e  2037              MOVS     r0,#0x37
000040  f7fffffe          BL       cycle_OTP
;;;1566   cycle_OTP(0x38);
000044  2038              MOVS     r0,#0x38
000046  f7fffffe          BL       cycle_OTP
;;;1567   cycle_OTP(0x39);
00004a  2039              MOVS     r0,#0x39
00004c  f7fffffe          BL       cycle_OTP
;;;1568   cycle_OTP(0x3A);
000050  203a              MOVS     r0,#0x3a
000052  f7fffffe          BL       cycle_OTP
;;;1569   cycle_OTP(0x3B);
000056  203b              MOVS     r0,#0x3b
000058  f7fffffe          BL       cycle_OTP
;;;1570   cycle_OTP(0x3C);
00005c  203c              MOVS     r0,#0x3c
00005e  f7fffffe          BL       cycle_OTP
;;;1571   cycle_OTP(0x3D);
000062  203d              MOVS     r0,#0x3d
000064  f7fffffe          BL       cycle_OTP
;;;1572   cycle_OTP(0x3E);
000068  203e              MOVS     r0,#0x3e
00006a  f7fffffe          BL       cycle_OTP
;;;1573   cycle_OTP(0x3F);
00006e  203f              MOVS     r0,#0x3f
000070  f7fffffe          BL       cycle_OTP
;;;1574   
;;;1575   cycle_OTP(0x40);
000074  2040              MOVS     r0,#0x40
000076  f7fffffe          BL       cycle_OTP
;;;1576   cycle_OTP(0x41);
00007a  2041              MOVS     r0,#0x41
00007c  f7fffffe          BL       cycle_OTP
;;;1577   cycle_OTP(0x42);
000080  2042              MOVS     r0,#0x42
000082  f7fffffe          BL       cycle_OTP
;;;1578   cycle_OTP(0x43);
000086  2043              MOVS     r0,#0x43
000088  f7fffffe          BL       cycle_OTP
;;;1579   cycle_OTP(0x44);
00008c  2044              MOVS     r0,#0x44
00008e  f7fffffe          BL       cycle_OTP
;;;1580   cycle_OTP(0x45);
000092  2045              MOVS     r0,#0x45
000094  f7fffffe          BL       cycle_OTP
;;;1581   cycle_OTP(0x46);
000098  2046              MOVS     r0,#0x46
00009a  f7fffffe          BL       cycle_OTP
;;;1582   //cycle_OTP(0x47);
;;;1583   cycle_OTP(0x48);
00009e  2048              MOVS     r0,#0x48
0000a0  f7fffffe          BL       cycle_OTP
;;;1584   cycle_OTP(0x49);
0000a4  2049              MOVS     r0,#0x49
0000a6  f7fffffe          BL       cycle_OTP
;;;1585   cycle_OTP(0x4A);
0000aa  204a              MOVS     r0,#0x4a
0000ac  f7fffffe          BL       cycle_OTP
;;;1586   
;;;1587   cycle_OTP(0x78);
0000b0  2078              MOVS     r0,#0x78
0000b2  f7fffffe          BL       cycle_OTP
;;;1588   cycle_OTP(0x79);
0000b6  2079              MOVS     r0,#0x79
0000b8  f7fffffe          BL       cycle_OTP
;;;1589   cycle_OTP(0x7A);
0000bc  207a              MOVS     r0,#0x7a
0000be  f7fffffe          BL       cycle_OTP
;;;1590   cycle_OTP(0x7B);
0000c2  207b              MOVS     r0,#0x7b
0000c4  f7fffffe          BL       cycle_OTP
;;;1591   cycle_OTP(0x7C);
0000c8  207c              MOVS     r0,#0x7c
0000ca  f7fffffe          BL       cycle_OTP
;;;1592   cycle_OTP(0x7D);
0000ce  207d              MOVS     r0,#0x7d
0000d0  f7fffffe          BL       cycle_OTP
;;;1593   cycle_OTP(0x7E);
0000d4  207e              MOVS     r0,#0x7e
0000d6  f7fffffe          BL       cycle_OTP
;;;1594   cycle_OTP(0x7F);
0000da  207f              MOVS     r0,#0x7f
0000dc  f7fffffe          BL       cycle_OTP
;;;1595   
;;;1596   cycle_OTP(0x80);
0000e0  2080              MOVS     r0,#0x80
0000e2  f7fffffe          BL       cycle_OTP
;;;1597   cycle_OTP(0x81);
0000e6  2081              MOVS     r0,#0x81
0000e8  f7fffffe          BL       cycle_OTP
;;;1598   cycle_OTP(0x82);
0000ec  2082              MOVS     r0,#0x82
0000ee  f7fffffe          BL       cycle_OTP
;;;1599   cycle_OTP(0x83);
0000f2  2083              MOVS     r0,#0x83
0000f4  f7fffffe          BL       cycle_OTP
;;;1600   cycle_OTP(0x84);
0000f8  2084              MOVS     r0,#0x84
0000fa  f7fffffe          BL       cycle_OTP
;;;1601   cycle_OTP(0x85);
0000fe  2085              MOVS     r0,#0x85
000100  f7fffffe          BL       cycle_OTP
;;;1602   cycle_OTP(0x86);
000104  2086              MOVS     r0,#0x86
000106  f7fffffe          BL       cycle_OTP
;;;1603   cycle_OTP(0x87);
00010a  2087              MOVS     r0,#0x87
00010c  f7fffffe          BL       cycle_OTP
;;;1604   cycle_OTP(0x88);
000110  2088              MOVS     r0,#0x88
000112  f7fffffe          BL       cycle_OTP
;;;1605   cycle_OTP(0x89);
000116  2089              MOVS     r0,#0x89
000118  f7fffffe          BL       cycle_OTP
;;;1606   cycle_OTP(0x8A);
00011c  208a              MOVS     r0,#0x8a
00011e  f7fffffe          BL       cycle_OTP
;;;1607   cycle_OTP(0x8B);
000122  208b              MOVS     r0,#0x8b
000124  f7fffffe          BL       cycle_OTP
;;;1608   cycle_OTP(0x8C);
000128  208c              MOVS     r0,#0x8c
00012a  f7fffffe          BL       cycle_OTP
;;;1609   cycle_OTP(0x8D);
00012e  208d              MOVS     r0,#0x8d
000130  f7fffffe          BL       cycle_OTP
;;;1610   cycle_OTP(0x8E);
000134  208e              MOVS     r0,#0x8e
000136  f7fffffe          BL       cycle_OTP
;;;1611   cycle_OTP(0x8F);
00013a  208f              MOVS     r0,#0x8f
00013c  f7fffffe          BL       cycle_OTP
;;;1612   
;;;1613   cycle_OTP(0x90);
000140  2090              MOVS     r0,#0x90
000142  f7fffffe          BL       cycle_OTP
;;;1614   cycle_OTP(0x91);
000146  2091              MOVS     r0,#0x91
000148  f7fffffe          BL       cycle_OTP
;;;1615   cycle_OTP(0x92);
00014c  2092              MOVS     r0,#0x92
00014e  f7fffffe          BL       cycle_OTP
;;;1616   cycle_OTP(0x93);
000152  2093              MOVS     r0,#0x93
000154  f7fffffe          BL       cycle_OTP
;;;1617   cycle_OTP(0x94);
000158  2094              MOVS     r0,#0x94
00015a  f7fffffe          BL       cycle_OTP
;;;1618   cycle_OTP(0x95);
00015e  2095              MOVS     r0,#0x95
000160  f7fffffe          BL       cycle_OTP
;;;1619   cycle_OTP(0x96);
000164  2096              MOVS     r0,#0x96
000166  f7fffffe          BL       cycle_OTP
;;;1620   cycle_OTP(0x97);
00016a  2097              MOVS     r0,#0x97
00016c  f7fffffe          BL       cycle_OTP
;;;1621   cycle_OTP(0x98);
000170  2098              MOVS     r0,#0x98
000172  f7fffffe          BL       cycle_OTP
;;;1622   cycle_OTP(0x99);
000176  2099              MOVS     r0,#0x99
000178  f7fffffe          BL       cycle_OTP
;;;1623   cycle_OTP(0x9A);
00017c  209a              MOVS     r0,#0x9a
00017e  f7fffffe          BL       cycle_OTP
;;;1624   cycle_OTP(0x9B);
000182  209b              MOVS     r0,#0x9b
000184  f7fffffe          BL       cycle_OTP
;;;1625   cycle_OTP(0x9C);
000188  209c              MOVS     r0,#0x9c
00018a  f7fffffe          BL       cycle_OTP
;;;1626   cycle_OTP(0x9D);
00018e  209d              MOVS     r0,#0x9d
000190  f7fffffe          BL       cycle_OTP
;;;1627   cycle_OTP(0x9E);
000194  209e              MOVS     r0,#0x9e
000196  f7fffffe          BL       cycle_OTP
;;;1628   cycle_OTP(0x9F);
00019a  209f              MOVS     r0,#0x9f
00019c  f7fffffe          BL       cycle_OTP
;;;1629   
;;;1630   cycle_OTP(0xA0);
0001a0  20a0              MOVS     r0,#0xa0
0001a2  f7fffffe          BL       cycle_OTP
;;;1631   cycle_OTP(0xA1);
0001a6  20a1              MOVS     r0,#0xa1
0001a8  f7fffffe          BL       cycle_OTP
;;;1632   cycle_OTP(0xA2);
0001ac  20a2              MOVS     r0,#0xa2
0001ae  f7fffffe          BL       cycle_OTP
;;;1633   cycle_OTP(0xA3);
0001b2  20a3              MOVS     r0,#0xa3
0001b4  f7fffffe          BL       cycle_OTP
;;;1634   cycle_OTP(0xA4);
0001b8  20a4              MOVS     r0,#0xa4
0001ba  f7fffffe          BL       cycle_OTP
;;;1635   cycle_OTP(0xA5);
0001be  20a5              MOVS     r0,#0xa5
0001c0  f7fffffe          BL       cycle_OTP
;;;1636   cycle_OTP(0xA6);
0001c4  20a6              MOVS     r0,#0xa6
0001c6  f7fffffe          BL       cycle_OTP
;;;1637   cycle_OTP(0xA7);
0001ca  20a7              MOVS     r0,#0xa7
0001cc  f7fffffe          BL       cycle_OTP
;;;1638   cycle_OTP(0xA8);
0001d0  20a8              MOVS     r0,#0xa8
0001d2  f7fffffe          BL       cycle_OTP
;;;1639   cycle_OTP(0xA9);
0001d6  20a9              MOVS     r0,#0xa9
0001d8  f7fffffe          BL       cycle_OTP
;;;1640   cycle_OTP(0xAA);
0001dc  20aa              MOVS     r0,#0xaa
0001de  f7fffffe          BL       cycle_OTP
;;;1641   cycle_OTP(0xAB);
0001e2  20ab              MOVS     r0,#0xab
0001e4  f7fffffe          BL       cycle_OTP
;;;1642   cycle_OTP(0xAC);
0001e8  20ac              MOVS     r0,#0xac
0001ea  f7fffffe          BL       cycle_OTP
;;;1643   cycle_OTP(0xAD);
0001ee  20ad              MOVS     r0,#0xad
0001f0  f7fffffe          BL       cycle_OTP
;;;1644   cycle_OTP(0xAE);
0001f4  20ae              MOVS     r0,#0xae
0001f6  f7fffffe          BL       cycle_OTP
;;;1645   cycle_OTP(0xAF);
0001fa  e8bd4010          POP      {r4,lr}
0001fe  20af              MOVS     r0,#0xaf
000200  f7ffbffe          B.W      cycle_OTP
;;;1646   
;;;1647   
;;;1648   
;;;1649   
;;;1650   //	MIPI_SPI_Write(0x06,0x39,0xE9,0x00,0x00);	//Set OTP
;;;1651   //
;;;1652   //	CLOSE_OTP_Voltage;//Close 7.5V 
;;;1653   //	Delay(10);//Wait 10ms	8369 no delay time
;;;1654   	
;;;1655   //	SSD1963Command_8(0xBa); 
;;;1656   //	SSD1963Data_8(0x0E);   //RESET=0
;;;1657   //	Delay(12);
;;;1658   //	SSD1963Command_8(0xBa); 
;;;1659   //	SSD1963Data_8(0x0F);   //RESET=1 
;;;1660   //	Delay(12);
;;;1661   	
;;;1662   //	SSD1963INITSSD2825();
;;;1663   //	OTP_initial();
;;;1664   
;;;1665   
;;;1666   	}
;;;1667   
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;115    /*******************************************************************************/
;;;116    int main(void)
000000  b084              SUB      sp,sp,#0x10
000002  f7fffffe          BL       RCC_DeInit
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4c9b              LDR      r4,|L34.640|
000014  2801              CMP      r0,#1
000016  7360              STRB     r0,[r4,#0xd]
000018  d124              BNE      |L34.100|
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L34.76|
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L34.76|
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L34.92|
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L34.92|
                  |L34.100|
000064  2101              MOVS     r1,#1
000066  f2440004          MOV      r0,#0x4004
00006a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;117    {   // uint testf;		//only for test 2014.1.27
;;;118    //	u8 mm=1;
;;;119    //	u32 rand_val;
;;;120    	u32 sdcap=1;
;;;121    	u8 READ_ID = 0;
;;;122    	u16 mm_KEYB1 = 1;
;;;123    
;;;124    //	u8 temp[9];
;;;125    
;;;126      #ifdef DEBUG
;;;127      debug();
;;;128      #endif
;;;129      /* System Clocks Configuration */
;;;130    	RCC_Configuration();	 	
;;;131      /* NVIC Configuration */
;;;132    	NVIC_Configuration();   //中断管理初始化   
00006e  f7fffffe          BL       NVIC_Configuration
000072  2004              MOVS     r0,#4
000074  f7fffffe          BL       SysTick_CLKSourceConfig
000078  4882              LDR      r0,|L34.644|
00007a  f7fffffe          BL       SysTick_SetReload
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       SysTick_ITConfig
000084  2001              MOVS     r0,#1
000086  f7fffffe          BL       SysTick_CounterCmd
;;;133    	SysTick_Config();		    //延时用  	
;;;134    	  
;;;135      //-------------------------------------------------
;;;136      /* Initialize the LCD */
;;;137    	STM32_SSD1963_Init();
00008a  f7fffffe          BL       STM32_SSD1963_Init
00008e  2101              MOVS     r1,#1
000090  2015              MOVS     r0,#0x15
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
000096  2040              MOVS     r0,#0x40
000098  f8ad0000          STRH     r0,[sp,#0]
00009c  2548              MOVS     r5,#0x48
00009e  f88d5003          STRB     r5,[sp,#3]
0000a2  4669              MOV      r1,sp
0000a4  4878              LDR      r0,|L34.648|
0000a6  f7fffffe          BL       GPIO_Init
0000aa  2080              MOVS     r0,#0x80
0000ac  f8ad0000          STRH     r0,[sp,#0]
0000b0  f88d5003          STRB     r5,[sp,#3]
0000b4  4669              MOV      r1,sp
0000b6  4875              LDR      r0,|L34.652|
0000b8  f7fffffe          BL       GPIO_Init
;;;138    
;;;139    	KEYGPIO_Init();
;;;140    	Sensor_GPIO_Config();
0000bc  f7fffffe          BL       Sensor_GPIO_Config
;;;141    	
;;;142    
;;;143    	
;;;144    ///SD  卡初始化部分。
;;;145    	if(SDConfigFlag == 0)
0000c0  7860              LDRB     r0,[r4,#1]  ; SDConfigFlag
;;;146    	{
;;;147    		SDShowFlag=1;
;;;148    	
;;;149    		Status =SD_InitAndConfig();  /*设置SD接口,初始化SD卡*/
;;;150    		sdcap=sd_Capacity>>20; //(sdcap=sd_Capacity/1024/1024)
;;;151    		All_Color(255,255,255)   ;
;;;152    
;;;153    			if(sdcap == 0)
;;;154    			{
;;;155    				FontR = 255;
0000c2  f8df81cc          LDR      r8,|L34.656|
;;;156    				FontB = 20;
0000c6  4e73              LDR      r6,|L34.660|
;;;157    				FontG = 20;
0000c8  4f73              LDR      r7,|L34.664|
0000ca  f04f0b14          MOV      r11,#0x14             ;156
0000ce  f04f09ff          MOV      r9,#0xff              ;151
0000d2  f04f0a01          MOV      r10,#1                ;120
0000d6  2800              CMP      r0,#0                 ;145
0000d8  d07e              BEQ      |L34.472|
                  |L34.218|
;;;158    //				LCD_DisplayStringLine_A(0,Line0,"SD ERROR!");	
;;;159    
;;;160    				FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
;;;161    //				while(1)
;;;162    //				{
;;;163    //					DelayKEY(100);
;;;164    //				}
;;;165    			}
;;;166    			else
;;;167    			{
;;;168    				FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
;;;169    				SDConfigFlag = 1;
;;;170    					
;;;171    			}
;;;172    	}
;;;173    
;;;174    
;;;175    	FontR = FontG = FontB = 255;			   //屏蔽字符
0000da  f8869000          STRB     r9,[r6,#0]
0000de  f8879000          STRB     r9,[r7,#0]
0000e2  f8889000          STRB     r9,[r8,#0]
;;;176    	  	if (FAT_Init())	//初始化FAT文件系统
0000e6  f7fffffe          BL       FAT_Init
0000ea  b150              CBZ      r0,|L34.258|
;;;177    		  {	
;;;178    		  		All_Color(255,255,255)   ;
0000ec  22ff              MOVS     r2,#0xff
0000ee  4611              MOV      r1,r2
0000f0  4610              MOV      r0,r2
0000f2  f7fffffe          BL       All_Color
;;;179    				FontR = 255;
0000f6  f8889000          STRB     r9,[r8,#0]
;;;180    				FontB = 20;
0000fa  f886b000          STRB     r11,[r6,#0]
;;;181    				FontG = 20;
0000fe  f887b000          STRB     r11,[r7,#0]
                  |L34.258|
;;;182    //				LCD_DisplayStringLine_A(0,Line0,"SD ERROR!");
;;;183    //				while(1)
;;;184    				{
;;;185    //					DelayKEY(100);
;;;186    				}
;;;187        
;;;188    		  }
;;;189              FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
000102  f8869000          STRB     r9,[r6,#0]
000106  f8879000          STRB     r9,[r7,#0]
00010a  f8889000          STRB     r9,[r8,#0]
;;;190    		LCD_DisplayStringLine(0,Line2,"Waiting....");
00010e  a263              ADR      r2,|L34.668|
000110  2130              MOVS     r1,#0x30
000112  2000              MOVS     r0,#0
000114  f7fffffe          BL       LCD_DisplayStringLine
;;;191    		
;;;192    			SearchInit();
000118  f7fffffe          BL       SearchInit
;;;193    
;;;194    		//////////////////show the project ----------------------------------------------------
;;;195    		
;;;196    
;;;197    
;;;198    
;;;199    
;;;200    	     
;;;201    	  	FontR = FontG = FontB = 0;
00011c  2500              MOVS     r5,#0
00011e  7035              STRB     r5,[r6,#0]
000120  703d              STRB     r5,[r7,#0]
000122  f8885000          STRB     r5,[r8,#0]
;;;202    		LCD_DisplayStringLine_A(10,160,"TFT035_A");	  /////2014/4/4   /////2014/4/4  M1461A0_C
000126  a260              ADR      r2,|L34.680|
000128  21a0              MOVS     r1,#0xa0
00012a  200a              MOVS     r0,#0xa
00012c  f7fffffe          BL       LCD_DisplayStringLine_A
;;;203    //		LCD_DisplayStringLine_A(30,360,"FGA7_20160426");
;;;204    		DelayKEY(100);
000130  2064              MOVS     r0,#0x64
000132  f7fffffe          BL       DelayKEY
;;;205    //		VCOM_GET();
;;;206    		
;;;207    		
;;;208    	FontR = FontG = FontB = 255;			   //屏蔽字符
000136  f8869000          STRB     r9,[r6,#0]
00013a  f8879000          STRB     r9,[r7,#0]
00013e  f8889000          STRB     r9,[r8,#0]
;;;209    	 
;;;210    
;;;211    		SDShowTimes = 0;
000142  70e5              STRB     r5,[r4,#3]
;;;212    
;;;213    		while (SDShowFlag) //开始BMP文件显示
000144  78a0              LDRB     r0,[r4,#2]  ; SDShowFlag
000146  b128              CBZ      r0,|L34.340|
;;;214    		{	  
;;;215    		 Disp_BMP() ;
000148  f7fffffe          BL       Disp_BMP
;;;216    		  Delay(1);
00014c  2001              MOVS     r0,#1
00014e  f7fffffe          BL       Delay
;;;217    		  SDShowFlag = 0;	
000152  70a5              STRB     r5,[r4,#2]
                  |L34.340|
;;;218    		}				   
;;;219    	
;;;220    //	ID_CHECK_A(10,100);  /////check ID ,if ID NG,,while(1);  if ID ok,DO nothing..	
;;;221    	
;;;222    	FontR = FontG = FontB = 0;			   //显示字符
000154  7035              STRB     r5,[r6,#0]
000156  703d              STRB     r5,[r7,#0]
000158  f8885000          STRB     r5,[r8,#0]
;;;223    
;;;224    
;;;225    	 
;;;226    		
;;;227    //	sdcap = KEYA7;
;;;228    
;;;229    
;;;230    ////	while(sdcap!=0)
;;;231    //	
;;;232    //	{sdcap = KEYA7;}
;;;233    
;;;234    //		 
;;;235    //		   if((sdcap==0)||(OTP_TIMES_BEFORE<=0))
;;;236    //		   {	
;;;237    //		   		Flicker_sub_pixel() ;	
;;;238    //			   ////////Re光感板是否放置到A定位置。
;;;239    //					sdcap = KEYA8;
;;;240    //					while(sdcap != 0)	
;;;241    //					{	
;;;242    //						LCD_DisplayStringLine(20,100,"Adjust sensor");	
;;;243    //						Delay(1);
;;;244    //						sdcap = KEYA8;	
;;;245    //					}
;;;246    
;;;247    //				Flicker_sub_pixel() ;
;;;248    //				LCD_WriteArea(3,20,10,790,255,0,0);		   ////start auto otp flow
;;;249    //		   		I2C_DATAL_COMPAREX();
;;;250    //				LCD_WriteArea(3,20,10,790,0,255,0);			  ////to show the best flicker。。。
;;;251    //				DelayKEY(1);
;;;252    //				Flicker_sub_pixel();	
;;;253    //				DelayKEY(1);
;;;254    //				if(DATA_SUM1[count2] <= 350)			 ///for check OTP is OK or NG....		 96
;;;255    //				{
;;;256    //						if(DATA_SUM1[count2] >= 5)
;;;257    //						{
;;;258    //							DelayKEY(1);
;;;259    //							sdcap = 1;
;;;260    //							LCD_CS(1);
;;;261    //							Delay(10);	
;;;262    //							sdcap = KEYA7;
;;;263    ////						    check_power();	   	 	Delay(150);	
;;;264    ////							sdcap = 0;
;;;265    ////							if(sdcap == 0)
;;;266    //						    {
;;;267    //								
;;;268    //								aat = 1;
;;;269    //								MTP_ID();
;;;270    //								FontR = FontG = FontB = 0;
;;;271    //					
;;;272    ////								Soft_reset();
;;;273    //					//			OTP_FLAG = 0;
;;;274    //								aat = 0;
;;;275    //							}
;;;276    //							LCD_CS(0);
;;;277    //							Delay(10);
;;;278    //							Soft_reset();
;;;279    //						    Flicker_sub_pixel();								
;;;280    //							FontR = 50; FontG = 255; FontB = 50;
;;;281    
;;;282    //							VCOM_GET();
;;;283    //							sdcap= MIPI_READ_DATA[4];
;;;284    //							if(sdcap != VCOMDC1)
;;;285    //							{
;;;286    //								OTP_ERROR(); while(1);
;;;287    //							}
;;;288    //							else
;;;289    //							{
;;;290    //								LCD_DisplayStringLine(20,100,"Flicker OTP ok");		
;;;291    //							}
;;;292    //							FontR = 255; FontG = 0; FontB = 0;
;;;293    //							LCD_DisplayStringLine(20,130,"Check flicker again!"); 	DelayKEY(100);
;;;294    //							
;;;295    //							FontR = 0; FontG = 0; FontB = 0;
;;;296    //							
;;;297    //						//	while(1);
;;;298    
;;;299    //						}
;;;300    //						else	   //////////if VCOM value not found perfect,goto error
;;;301    //						{
;;;302    //							OTP_ERROR(); while(1);
;;;303    //						}
;;;304    //				}
;;;305    //				else	   //////////if VCOM value not found perfect,goto error
;;;306    //				{
;;;307    //					OTP_ERROR(); while(1);
;;;308    //				}
;;;309    //				
;;;310    //				
;;;311    //		   }
;;;312    //	else
;;;313    //	{
;;;314    //		Soft_reset();    ///////复位后使用客户初始化code，以便拦检OTP漏烧产品。
;;;315    //	}
;;;316        Flicker_PIXEL();
00015c  f7fffffe          BL       Flicker_PIXEL
;;;317    	KEY_adjust();
000160  f7fffffe          BL       KEY_adjust
000164  f8df814c          LDR      r8,|L34.692|
                  |L34.360|
;;;318    //	Flicker_PIXEL();
;;;319    //	showid_vcom()	;								Delay(150);			mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;320    
;;;321    
;;;322    LCDTest:
;;;323    	
;;;324    		   	All_Color(255,0,0)   ; 							DelayKEY(100);
000168  2200              MOVS     r2,#0
00016a  4611              MOV      r1,r2
00016c  20ff              MOVS     r0,#0xff
00016e  f7fffffe          BL       All_Color
000172  2064              MOVS     r0,#0x64
000174  f7fffffe          BL       DelayKEY
;;;325    //
;;;326    /////////*-------enter sleep mode------- */ 
;;;327    //////  	enter_sleep_mode( ) ;
;;;328    //////	DelayKEY(250);
;;;329    //////	exit_sleep_mode( );
;;;330    //////*-------exit sleep mode------- */
;;;331    ////
;;;332      	All_Color(0,255,0)   ;					  		DelayKEY(100);
000178  2200              MOVS     r2,#0
00017a  21ff              MOVS     r1,#0xff
00017c  4610              MOV      r0,r2
00017e  f7fffffe          BL       All_Color
000182  2064              MOVS     r0,#0x64
000184  f7fffffe          BL       DelayKEY
;;;333    	All_Color(0,0,255)   ;					  		DelayKEY(100);
000188  2100              MOVS     r1,#0
00018a  22ff              MOVS     r2,#0xff
00018c  4608              MOV      r0,r1
00018e  f7fffffe          BL       All_Color
000192  2064              MOVS     r0,#0x64
000194  f7fffffe          BL       DelayKEY
;;;334    	All_Color(255,255,255)   ;				  	DelayKEY(100);
000198  22ff              MOVS     r2,#0xff
00019a  4611              MOV      r1,r2
00019c  4610              MOV      r0,r2
00019e  f7fffffe          BL       All_Color
0001a2  2064              MOVS     r0,#0x64
0001a4  f7fffffe          BL       DelayKEY
;;;335    	LCD_WriteArea(1,XDP-2,1,YDP-2,0,0,0);		DelayKEY(100);
0001a8  2201              MOVS     r2,#1
0001aa  9500              STR      r5,[sp,#0]
0001ac  9501              STR      r5,[sp,#4]
0001ae  23ee              MOVS     r3,#0xee
0001b0  f44f719f          MOV      r1,#0x13e
0001b4  4610              MOV      r0,r2
0001b6  9502              STR      r5,[sp,#8]
0001b8  f7fffffe          BL       LCD_WriteArea
0001bc  2064              MOVS     r0,#0x64
0001be  f7fffffe          BL       DelayKEY
;;;336    	All_Color(0,0,0)   ;				  		DelayKEY(100);
0001c2  2200              MOVS     r2,#0
0001c4  4611              MOV      r1,r2
0001c6  4610              MOV      r0,r2
0001c8  f7fffffe          BL       All_Color
0001cc  2064              MOVS     r0,#0x64
0001ce  f7fffffe          BL       DelayKEY
;;;337        All_Color(60,60,60)   ;				  		DelayKEY(100);
0001d2  223c              MOVS     r2,#0x3c
0001d4  4611              MOV      r1,r2
0001d6  e000              B        |L34.474|
                  |L34.472|
0001d8  e031              B        |L34.574|
                  |L34.474|
0001da  4610              MOV      r0,r2
0001dc  f7fffffe          BL       All_Color
0001e0  2064              MOVS     r0,#0x64
0001e2  f7fffffe          BL       DelayKEY
;;;338    	All_Color(127,127,127)   ;				  		DelayKEY(100);
0001e6  227f              MOVS     r2,#0x7f
0001e8  4611              MOV      r1,r2
0001ea  4610              MOV      r0,r2
0001ec  f7fffffe          BL       All_Color
0001f0  2064              MOVS     r0,#0x64
0001f2  f7fffffe          BL       DelayKEY
;;;339        RGB_color();                                    DelayKEY(100);
0001f6  f7fffffe          BL       RGB_color
0001fa  2064              MOVS     r0,#0x64
0001fc  f7fffffe          BL       DelayKEY
;;;340        Flicker_PIXEL();                                DelayKEY(100);
000200  f7fffffe          BL       Flicker_PIXEL
000204  2064              MOVS     r0,#0x64
000206  f7fffffe          BL       DelayKEY
00020a  f884a002          STRB     r10,[r4,#2]
00020e  f884a003          STRB     r10,[r4,#3]
;;;341    	SDPicShow(1);				 			   		DelayKEY(80);	
000212  2701              MOVS     r7,#1
000214  2600              MOVS     r6,#0
000216  f8a8a000          STRH     r10,[r8,#0]
                  |L34.538|
00021a  f7fffffe          BL       Disp_BMP
00021e  2001              MOVS     r0,#1
000220  f7fffffe          BL       DelayKEY
000224  f8b80000          LDRH     r0,[r8,#0]  ; image_count
000228  4287              CMP      r7,r0
00022a  bf98              IT       LS
00022c  2e01              CMPLS    r6,#1
00022e  d803              BHI      |L34.568|
000230  1c70              ADDS     r0,r6,#1
000232  f8a87000          STRH     r7,[r8,#0]
000236  b2c6              UXTB     r6,r0
                  |L34.568|
000238  b1de              CBZ      r6,|L34.626|
00023a  70a5              STRB     r5,[r4,#2]
00023c  e01c              B        |L34.632|
                  |L34.574|
00023e  f884a002          STRB     r10,[r4,#2]           ;147
000242  f7fffffe          BL       SD_InitAndConfig
000246  7020              STRB     r0,[r4,#0]            ;149
000248  6a60              LDR      r0,[r4,#0x24]         ;150  ; sd_Capacity
00024a  22ff              MOVS     r2,#0xff              ;151
00024c  0d05              LSRS     r5,r0,#20             ;150
00024e  4611              MOV      r1,r2                 ;151
000250  4610              MOV      r0,r2                 ;151
000252  f7fffffe          BL       All_Color
000256  2d00              CMP      r5,#0                 ;153
000258  bf08              IT       EQ                    ;155
00025a  f8889000          STRBEQ   r9,[r8,#0]            ;155
00025e  f8869000          STRB     r9,[r6,#0]            ;160
000262  f8879000          STRB     r9,[r7,#0]            ;160
000266  bf1c              ITT      NE                    ;168
000268  f8889000          STRBNE   r9,[r8,#0]            ;168
00026c  f884a001          STRBNE   r10,[r4,#1]           ;169
000270  e733              B        |L34.218|
                  |L34.626|
000272  78a0              LDRB     r0,[r4,#2]            ;153  ; SDShowFlag
000274  2800              CMP      r0,#0                 ;153
000276  d1d0              BNE      |L34.538|
                  |L34.632|
000278  2050              MOVS     r0,#0x50
00027a  f7fffffe          BL       DelayKEY
;;;342    
;;;343    
;;;344    		   
;;;345    //	RGB_color();									
;;;346    //	LCD_DisplayStringLine(40,820,"RED");	 LCD_DisplayStringLine(140,820,"GREEN");		LCD_DisplayStringLine(265,820,"BLUE");		  LCD_DisplayStringLine(380,820,"WHITE");
;;;347    //	DelayKEY(80);															mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;348    //	SDPicShow(2);				 			   		Delay(150);			  mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }//SD  1   pic 
;;;349    //	All_Color(255,0,0)   ; 							Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;350    //	All_Color(0,255,0)   ;					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;351    //	All_Color(0,0,255)   ;					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;352    //	All_Color(255,255,255)   ;					   
;;;353    //	LCD_WriteArea(147,147,169,169,160,255,255);				   ////zy暗c	   R160,G210,B0
;;;354    //	LCD_WriteArea(231,231,169,169,255,210,255);
;;;355    //	LCD_WriteArea(311,311,169,169,255,255,0);			  	Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;356    //	All_Color(0,0,0)   ;							
;;;357    //	LCD_WriteArea(147,147,169,169,53,0,0);				   ////zy亮c		 R49,G29,B69
;;;358    //	LCD_WriteArea(231,231,169,169,0,35,0);
;;;359    //	LCD_WriteArea(311,311,169,169,0,0,89);					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;360    // 	SDPicShow(1);				 			   		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   } //SD  1   pic
;;;361    //	Flicker_PIXEL();								Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;362    // 	showid_vcom()	;								Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;363      goto LCDTest;
00027e  e773              B        |L34.360|
;;;364    
;;;365    }
;;;366    
                          ENDP

                  |L34.640|
                          DCD      ||.data||
                  |L34.644|
                          DCD      0x00011940
                  |L34.648|
                          DCD      0x40011000
                  |L34.652|
                          DCD      0x40010800
                  |L34.656|
                          DCD      FontR
                  |L34.660|
                          DCD      FontB
                  |L34.664|
                          DCD      FontG
                  |L34.668|
00029c  57616974          DCB      "Waiting....",0
0002a0  696e672e
0002a4  2e2e2e00
                  |L34.680|
0002a8  54465430          DCB      "TFT035_A",0
0002ac  33355f41
0002b0  00      
0002b1  00                DCB      0
0002b2  00                DCB      0
0002b3  00                DCB      0
                  |L34.692|
                          DCD      image_count

                          AREA ||i.showid_vcom||, CODE, READONLY, ALIGN=2

                  showid_vcom PROC
;;;710    
;;;711    void showid_vcom(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;712    {
;;;713    	u8  vcom;
;;;714    
;;;715    	Flicker_PIXEL();		   DelayKEY(1);
000004  f7fffffe          BL       Flicker_PIXEL
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DelayKEY
;;;716    	
;;;717    	
;;;718    	READ_IC_A(0XD9,0x00);
00000e  2100              MOVS     r1,#0
000010  20d9              MOVS     r0,#0xd9
000012  f7fffffe          BL       READ_IC_A
;;;719    	FontR = 0; FontG = 0; FontB = 0;
000016  4e3c              LDR      r6,|L35.264|
000018  4f3c              LDR      r7,|L35.268|
00001a  2500              MOVS     r5,#0
00001c  f8df80f0          LDR      r8,|L35.272|
000020  7035              STRB     r5,[r6,#0]
;;;720    	vcom= MIPI_READ_DATA[0];
000022  f8df90f0          LDR      r9,|L35.276|
000026  703d              STRB     r5,[r7,#0]            ;719
000028  f8885000          STRB     r5,[r8,#0]            ;719
00002c  f8994000          LDRB     r4,[r9,#0]  ; MIPI_READ_DATA
;;;721    	LCD_DisplayStringLine(100,600,"VCOM");
000030  a239              ADR      r2,|L35.280|
000032  f44f7116          MOV      r1,#0x258
000036  2064              MOVS     r0,#0x64
000038  f7fffffe          BL       LCD_DisplayStringLine
;;;722    	SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
00003c  f44f7116          MOV      r1,#0x258
000040  f8992000          LDRB     r2,[r9,#0]  ; MIPI_READ_DATA
000044  1048              ASRS     r0,r1,#1
000046  f7fffffe          BL       SHOW_IC_VALUE_A
;;;723    	
;;;724    	while(ID_CHECK(20,700) == 1)
00004a  f44f712f          MOV      r1,#0x2bc
00004e  2014              MOVS     r0,#0x14
000050  f7fffffe          BL       ID_CHECK
000054  2801              CMP      r0,#1
000056  d126              BNE      |L35.166|
;;;725    	{
;;;726    		READ_ID++;
;;;727    		if(READ_ID >3)
;;;728    		{		while(1);	}
;;;729    		
;;;730    		temp = 1;
;;;731    		temp = KEYA7;
000058  f8dfa0c4          LDR      r10,|L35.288|
00005c  f8df90c4          LDR      r9,|L35.292|
000060  4683              MOV      r11,r0                ;715
                  |L35.98|
000062  f899000c          LDRB     r0,[r9,#0xc]          ;726  ; READ_ID
000066  1c40              ADDS     r0,r0,#1              ;726
000068  b2c0              UXTB     r0,r0                 ;726
00006a  f889000c          STRB     r0,[r9,#0xc]          ;726
00006e  2803              CMP      r0,#3                 ;727
000070  d900              BLS      |L35.116|
                  |L35.114|
000072  e7fe              B        |L35.114|
                  |L35.116|
000074  f8da0000          LDR      r0,[r10,#0]
000078  f0100080          ANDS     r0,r0,#0x80
00007c  f889000b          STRB     r0,[r9,#0xb]
;;;732    		//		temp = 0 ;
;;;733    		
;;;734    		if(temp == 0)
;;;735    		{
;;;736    			aat2 = 0;
;;;737    		//			ENTER_LP_mode();
;;;738    		//			MTP_ID();
;;;739    			aat2 = 1;
000080  bf08              IT       EQ
000082  f8a9b014          STRHEQ   r11,[r9,#0x14]
;;;740    		}
;;;741    		
;;;742    		FontR = FontG = FontB = 0;
000086  f8885000          STRB     r5,[r8,#0]
00008a  703d              STRB     r5,[r7,#0]
00008c  7035              STRB     r5,[r6,#0]
;;;743    		Soft_reset();
00008e  f7fffffe          BL       Soft_reset
;;;744    		Delay(10);	
000092  200a              MOVS     r0,#0xa
000094  f7fffffe          BL       Delay
000098  f44f712f          MOV      r1,#0x2bc             ;724
00009c  2014              MOVS     r0,#0x14              ;724
00009e  f7fffffe          BL       ID_CHECK
0000a2  2801              CMP      r0,#1                 ;724
0000a4  d0dd              BEQ      |L35.98|
                  |L35.166|
;;;745    	
;;;746    	}
;;;747    	
;;;748    	Delay(10);						
0000a6  200a              MOVS     r0,#0xa
0000a8  f7fffffe          BL       Delay
;;;749    	//	READ_IC_A(0XD9,0x00);
;;;750    	
;;;751    	//	Delay(10);
;;;752    	//   LCD_DisplayStringLine(100,600,"VCOM");
;;;753    	////   SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
;;;754    	//	SHOW_IC_VALUE_A(300,600,VCOMDC);
;;;755    	////
;;;756    	////  if(VCOMDC== MIPI_READ_DATA[0] )	
;;;757    	////	{
;;;758    	//		LCD_DisplayStringLine_A(50,700,"VCOMDC PASS");
;;;759    	//	}
;;;760    	//	else
;;;761    	//	{
;;;762    	//	
;;;763    	//		LCD_DisplayStringLine_A(50,700,"VCOMDC NG");
;;;764    	//			while(1);
;;;765    	//	}
;;;766    	//		
;;;767    	FontR = FontG = FontB = 0;
0000ac  f8885000          STRB     r5,[r8,#0]
0000b0  703d              STRB     r5,[r7,#0]
0000b2  7035              STRB     r5,[r6,#0]
;;;768    	LCD_DisplayChinese(20,700,cfont,2);
0000b4  2302              MOVS     r3,#2
0000b6  4a1c              LDR      r2,|L35.296|
0000b8  f44f712f          MOV      r1,#0x2bc
0000bc  2014              MOVS     r0,#0x14
0000be  f7fffffe          BL       LCD_DisplayChinese
;;;769    
;;;770    	if(vcom==0x39)
;;;771    	{
;;;772    		FontR =255; FontG =0; FontB = 0;
0000c2  20ff              MOVS     r0,#0xff
0000c4  2c39              CMP      r4,#0x39              ;770
0000c6  d011              BEQ      |L35.236|
;;;773    		LCD_DisplayChinese(270,700,cfont2,2);
;;;774    	}
;;;775    	else
;;;776    	{
;;;777    		FontR =0; FontG =255; FontB = 0;
0000c8  7035              STRB     r5,[r6,#0]
0000ca  7038              STRB     r0,[r7,#0]
0000cc  f8885000          STRB     r5,[r8,#0]
;;;778    		LCD_DisplayChinese(270,700,cfont1,2);
0000d0  2302              MOVS     r3,#2
0000d2  4a16              LDR      r2,|L35.300|
0000d4  f44f712f          MOV      r1,#0x2bc
0000d8  f44f7087          MOV      r0,#0x10e
0000dc  f7fffffe          BL       LCD_DisplayChinese
                  |L35.224|
;;;779    	}
;;;780    	
;;;781    	FontR = FontG = FontB = 0;
0000e0  f8885000          STRB     r5,[r8,#0]
0000e4  703d              STRB     r5,[r7,#0]
0000e6  7035              STRB     r5,[r6,#0]
;;;782    	
;;;783    
;;;784    }
0000e8  e8bd9ff0          POP      {r4-r12,pc}
                  |L35.236|
0000ec  7030              STRB     r0,[r6,#0]            ;772
0000ee  703d              STRB     r5,[r7,#0]            ;772
0000f0  f8885000          STRB     r5,[r8,#0]            ;772
0000f4  2302              MOVS     r3,#2                 ;773
0000f6  4a0e              LDR      r2,|L35.304|
0000f8  f44f712f          MOV      r1,#0x2bc             ;773
0000fc  f44f7087          MOV      r0,#0x10e             ;773
000100  f7fffffe          BL       LCD_DisplayChinese
000104  e7ec              B        |L35.224|
;;;785    
                          ENDP

000106  0000              DCW      0x0000
                  |L35.264|
                          DCD      FontR
                  |L35.268|
                          DCD      FontG
                  |L35.272|
                          DCD      FontB
                  |L35.276|
                          DCD      ||.bss||
                  |L35.280|
000118  56434f4d          DCB      "VCOM",0
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L35.288|
                          DCD      0x40010808
                  |L35.292|
                          DCD      ||.data||
                  |L35.296|
                          DCD      ||.data||+0x28
                  |L35.300|
                          DCD      ||.data||+0x1c
                  |L35.304|
                          DCD      ||.data||+0x20

                          AREA ||i.showid_vcom_A||, CODE, READONLY, ALIGN=2

                  showid_vcom_A PROC
;;;786    
;;;787    void showid_vcom_A(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;788    {
;;;789    	
;;;790    
;;;791    
;;;792       while(ID_CHECK(20,700) == 1)
000004  f44f712f          MOV      r1,#0x2bc
000008  2014              MOVS     r0,#0x14
00000a  f7fffffe          BL       ID_CHECK
;;;793    	{
;;;794    		READ_ID++;
00000e  4d18              LDR      r5,|L36.112|
000010  2801              CMP      r0,#1                 ;792
000012  d118              BNE      |L36.70|
;;;795    		if(READ_ID >3)
;;;796    		{		while(1);	}
;;;797    
;;;798    //		temp = 1;
;;;799    //		temp = KEYA7;
;;;800    //		temp = 0 ;
;;;801    //
;;;802    //		if(temp == 0)
;;;803    //		{
;;;804    //			aat2 = 0;
;;;805    //			ENTER_LP_mode();
;;;806    //			MTP_ID();
;;;807    //			aat2 = 1;
;;;808    //		}
;;;809    
;;;810    		FontR = FontG = FontB = 0;
000014  4e17              LDR      r6,|L36.116|
000016  4f18              LDR      r7,|L36.120|
000018  f8df8060          LDR      r8,|L36.124|
00001c  2400              MOVS     r4,#0                 ;792
                  |L36.30|
00001e  7b28              LDRB     r0,[r5,#0xc]          ;794  ; READ_ID
000020  1c40              ADDS     r0,r0,#1              ;794
000022  b2c0              UXTB     r0,r0                 ;794
000024  7328              STRB     r0,[r5,#0xc]          ;794
000026  2803              CMP      r0,#3                 ;795
000028  d900              BLS      |L36.44|
                  |L36.42|
00002a  e7fe              B        |L36.42|
                  |L36.44|
00002c  7034              STRB     r4,[r6,#0]
00002e  703c              STRB     r4,[r7,#0]
000030  f8884000          STRB     r4,[r8,#0]
;;;811    		Soft_reset();
000034  f7fffffe          BL       Soft_reset
000038  f44f712f          MOV      r1,#0x2bc             ;792
00003c  2014              MOVS     r0,#0x14              ;792
00003e  f7fffffe          BL       ID_CHECK
000042  2801              CMP      r0,#1                 ;792
000044  d0eb              BEQ      |L36.30|
                  |L36.70|
;;;812    
;;;813    
;;;814    	}
;;;815    
;;;816    	Delay(10);						
000046  200a              MOVS     r0,#0xa
000048  f7fffffe          BL       Delay
;;;817    //	READ_IC_A(0XD9,0x00);
;;;818    
;;;819    	Delay(10);
00004c  200a              MOVS     r0,#0xa
00004e  f7fffffe          BL       Delay
;;;820       LCD_DisplayStringLine(100,600,"VCOM");
000052  a20b              ADR      r2,|L36.128|
000054  f44f7116          MOV      r1,#0x258
000058  2064              MOVS     r0,#0x64
00005a  f7fffffe          BL       LCD_DisplayStringLine
;;;821    //   SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
;;;822    	SHOW_IC_VALUE_A(300,600,VCOMDC);
00005e  792a              LDRB     r2,[r5,#4]  ; VCOMDC
000060  e8bd41f0          POP      {r4-r8,lr}
000064  f44f7116          MOV      r1,#0x258
000068  1048              ASRS     r0,r1,#1
00006a  f7ffbffe          B.W      SHOW_IC_VALUE_A
;;;823    //
;;;824    //  if(VCOMDC== MIPI_READ_DATA[0] )	
;;;825    //	{
;;;826    //		LCD_DisplayStringLine_A(50,700,"VCOMDC PASS");
;;;827    //	}
;;;828    //	else
;;;829    //	{
;;;830    //	
;;;831    //		LCD_DisplayStringLine_A(50,700,"VCOMDC NG");
;;;832    //			while(1);
;;;833    //	}
;;;834    //		
;;;835    
;;;836    
;;;837    
;;;838    
;;;839    }
;;;840    
                          ENDP

00006e  0000              DCW      0x0000
                  |L36.112|
                          DCD      ||.data||
                  |L36.116|
                          DCD      FontB
                  |L36.120|
                          DCD      FontG
                  |L36.124|
                          DCD      FontR
                  |L36.128|
000080  56434f4d          DCB      "VCOM",0
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MIPI_READ_DATA
                          %        12
                  SDCardInfo
                          %        80
                  DATA_SUM1
                          %        60
                  SURE
                          %        60

                          AREA ||area_number.39||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.39||, ||.bss||
                  DATA_SUMY
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  Status
000000  2a                DCB      0x2a
                  SDConfigFlag
000001  00                DCB      0x00
                  SDShowFlag
000002  01                DCB      0x01
                  SDShowTimes
000003  01                DCB      0x01
                  VCOMDC
000004  15                DCB      0x15
                  STEP
000005  18                DCB      0x18
                  OTP_VALUE1
000006  00                DCB      0x00
                  OTP_VALUE2
000007  00                DCB      0x00
                  OTP_TIMES
000008  00                DCB      0x00
                  OTP_TIMES_BEFORE
000009  00                DCB      0x00
                  ID_OK
00000a  01                DCB      0x01
                  temp
00000b  01                DCB      0x01
                  READ_ID
00000c  00                DCB      0x00
                  HSEStartUpStatus
00000d  00                DCB      0x00
                  count1
00000e  0000              DCW      0x0000
                  count2
000010  0000              DCW      0x0000
                  aat
000012  0000              DCW      0x0000
                  aat2
000014  0001              DCW      0x0001
                  VCOMDC1
000016  0000              DCW      0x0000
                  TimingDelay
                          DCD      0x00000000
                  cfont1
00001c  11131400          DCB      0x11,0x13,0x14,0x00
                  cfont2
000020  12131400          DCB      0x12,0x13,0x14,0x00
                  sd_Capacity
                          DCD      0x00000000
                  cfont
000028  0d0e0f10          DCB      0x0d,0x0e,0x0f,0x10
00002c  00                DCB      0x00

                          AREA ||area_number.42||, DATA, ALIGN=1

                          EXPORTAS ||area_number.42||, ||.data||
                  vcomdc_value
000000  0000              DCW      0x0000

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  VCOM1
000000  15                DCB      0x15

                          AREA ||area_number.44||, DATA, ALIGN=1

                          EXPORTAS ||area_number.44||, ||.data||
                  GPIO_InitStructure
                          DCDU     0x00000000

                  __ARM_use_no_argv EQU 0
