; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Decrement_TimingDelay||, CODE, READONLY, ALIGN=2

                  Decrement_TimingDelay PROC
;;;1001   *******************************************************************************/
;;;1002   void Decrement_TimingDelay(void)
000000  4804              LDR      r0,|L1.20|
;;;1003   {
;;;1004     if (TimingDelay != 0x00)
000002  6981              LDR      r1,[r0,#0x18]  ; TimingDelay
000004  2900              CMP      r1,#0                 ;1003
;;;1005     {
;;;1006       TimingDelay--;
;;;1007     }
;;;1008   }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  6981              LDR      r1,[r0,#0x18]         ;1006  ; TimingDelay
00000c  1e49              SUBS     r1,r1,#1              ;1006
00000e  6181              STR      r1,[r0,#0x18]         ;1006  ; TimingDelay
000010  4770              BX       lr
;;;1009   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.data||

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=2

                  Delay PROC
;;;971    *******************************************************************************/
;;;972    void Delay(u32 nCount)				 //////delay  10ms
000000  b510              PUSH     {r4,lr}
;;;973    {
;;;974      TimingDelay = nCount*10;
000002  4c07              LDR      r4,|L2.32|
000004  eb000080          ADD      r0,r0,r0,LSL #2
000008  0040              LSLS     r0,r0,#1
00000a  61a0              STR      r0,[r4,#0x18]  ; TimingDelay
;;;975      /* Enable the SysTick Counter */
;;;976      //SysTick_CounterCmd(SysTick_Counter_Enable);	
;;;977      SysTick_ITConfig(ENABLE);//ENABLE DISABLE		
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       SysTick_ITConfig
                  |L2.18|
;;;978      while(TimingDelay != 0)
000012  69a0              LDR      r0,[r4,#0x18]  ; TimingDelay
000014  2800              CMP      r0,#0
000016  d1fc              BNE      |L2.18|
;;;979      {;;}
;;;980      SysTick_ITConfig(DISABLE);//ENABLE DISABLE 
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      SysTick_ITConfig
;;;981    }
;;;982    
                          ENDP

                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.DelayKEY||, CODE, READONLY, ALIGN=2

                  DelayKEY PROC
;;;1051   
;;;1052   void DelayKEY (u32 k)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1053   { 
000002  b083              SUB      sp,sp,#0xc
000004  0006              MOVS     r6,r0
;;;1054       volatile u16 m=1;
000006  f04f0001          MOV      r0,#1
00000a  f8ad0000          STRH     r0,[sp,#0]
;;;1055   	volatile u32 j;
;;;1056   
;;;1057         for (j=0; j<k; j++)
00000e  f04f0000          MOV      r0,#0
000012  9001              STR      r0,[sp,#4]            ;1053
;;;1058            {  
;;;1059   		 	m=KEYC6;	
;;;1060   			Delay(2);
;;;1061               while(m==0)
;;;1062                 {
;;;1063   			  	m=KEYC6; 
;;;1064   			  	Delay(2);
;;;1065   
;;;1066   			  }            
;;;1067            }	
;;;1068   
;;;1069   }
000014  bf04              ITT      EQ
000016  b003              ADDEQ    sp,sp,#0xc
000018  bdf0              POPEQ    {r4-r7,pc}
00001a  4f14              LDR      r7,|L3.108|
00001c  4c14              LDR      r4,|L3.112|
00001e  2514              MOVS     r5,#0x14              ;1059
                  |L3.32|
000020  68b8              LDR      r0,[r7,#8]            ;1059
000022  f0000040          AND      r0,r0,#0x40           ;1059
000026  f8ad0000          STRH     r0,[sp,#0]            ;1059
00002a  2002              MOVS     r0,#2                 ;1060
00002c  f7fffffe          BL       Delay
000030  f8bd0000          LDRH     r0,[sp,#0]            ;1061
000034  b990              CBNZ     r0,|L3.92|
                  |L3.54|
000036  68b8              LDR      r0,[r7,#8]            ;1063
000038  f0000040          AND      r0,r0,#0x40           ;1063
00003c  f8ad0000          STRH     r0,[sp,#0]            ;1063
000040  61a5              STR      r5,[r4,#0x18]         ;1063  ; TimingDelay
000042  2001              MOVS     r0,#1                 ;1063
000044  f7fffffe          BL       SysTick_ITConfig
                  |L3.72|
000048  69a1              LDR      r1,[r4,#0x18]         ;1063  ; TimingDelay
00004a  2900              CMP      r1,#0                 ;1063
00004c  d1fc              BNE      |L3.72|
00004e  2000              MOVS     r0,#0                 ;1063
000050  f7fffffe          BL       SysTick_ITConfig
000054  f8bd0000          LDRH     r0,[sp,#0]            ;1061
000058  2800              CMP      r0,#0                 ;1061
00005a  d0ec              BEQ      |L3.54|
                  |L3.92|
00005c  9801              LDR      r0,[sp,#4]            ;1057
00005e  1c40              ADDS     r0,r0,#1              ;1057
000060  9001              STR      r0,[sp,#4]            ;1057
000062  42b0              CMP      r0,r6                 ;1057
000064  d3dc              BCC      |L3.32|
000066  b003              ADD      sp,sp,#0xc
000068  bdf0              POP      {r4-r7,pc}
;;;1070   
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      0x40011000
                  |L3.112|
                          DCD      ||.data||

                          AREA ||i.I2C_DATAL_COMPARE||, CODE, READONLY, ALIGN=2

                  I2C_DATAL_COMPARE PROC
;;;1374   }
;;;1375   void I2C_DATAL_COMPARE(void)
000000  f8dfc030          LDR      r12,|L4.52|
;;;1376   {
000004  b430              PUSH     {r4,r5}
;;;1377   		int yy=1,zz=0;
000006  2101              MOVS     r1,#1
;;;1378   	while(yy<count1 && zz<count1)
000008  f8bc200e          LDRH     r2,[r12,#0xe]
;;;1379   	{
;;;1380   		if(	DATA_SUM1[zz]>DATA_SUM1[yy])
00000c  4b0a              LDR      r3,|L4.56|
00000e  2000              MOVS     r0,#0                 ;1377
                  |L4.16|
000010  4291              CMP      r1,r2                 ;1378
000012  bfb2              ITEE     LT                    ;1378
000014  4290              CMPLT    r0,r2                 ;1378
;;;1381   		{
;;;1382   			count2=yy;zz=zz+1;	
;;;1383   		}
;;;1384   		else
;;;1385   		{
;;;1386   			count2=zz;yy=yy+1;
;;;1387   		}
;;;1388   	}	
;;;1389   }
000016  bc30              POPGE    {r4,r5}
000018  4770              BXGE     lr
00001a  f8334010          LDRH     r4,[r3,r0,LSL #1]     ;1380
00001e  f8335011          LDRH     r5,[r3,r1,LSL #1]     ;1380
000022  42ac              CMP      r4,r5                 ;1380
000024  bf87              ITTEE    HI                    ;1382
000026  f8ac1010          STRHHI   r1,[r12,#0x10]        ;1382
00002a  1c40              ADDHI    r0,r0,#1              ;1382
00002c  f8ac0010          STRHLS   r0,[r12,#0x10]        ;1386
000030  1c49              ADDLS    r1,r1,#1              ;1386
000032  e7ed              B        |L4.16|
;;;1390   
                          ENDP

                  |L4.52|
                          DCD      ||.data||
                  |L4.56|
                          DCD      ||.bss||+0x5c

                          AREA ||i.I2C_DATAL_COMPAREX||, CODE, READONLY, ALIGN=2

                  I2C_DATAL_COMPAREX PROC
;;;1336   }
;;;1337   void I2C_DATAL_COMPAREX(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1338   {
000002  b083              SUB      sp,sp,#0xc
;;;1339   
;;;1340   //	TSL2583_init();			////must initial TSL2583,,,for AUTO OTP use..
;;;1341   //	while(1)
;;;1342   //	{
;;;1343   	GET_FLICKER();
000004  f7fffffe          BL       GET_FLICKER
;;;1344   	I2C_MEMSURE1(STEP , VCOMDC);   //最大找寻 20次，调整的阶数值保存于SURE数组中
000008  4c18              LDR      r4,|L5.108|
00000a  7921              LDRB     r1,[r4,#4]  ; VCOMDC
00000c  7960              LDRB     r0,[r4,#5]  ; STEP
00000e  f7fffffe          BL       I2C_MEMSURE1
000012  2101              MOVS     r1,#1
000014  4b16              LDR      r3,|L5.112|
000016  89e2              LDRH     r2,[r4,#0xe]
000018  2000              MOVS     r0,#0
                  |L5.26|
00001a  4291              CMP      r1,r2
00001c  bfb8              IT       LT
00001e  4290              CMPLT    r0,r2
000020  da0a              BGE      |L5.56|
000022  f833c010          LDRH     r12,[r3,r0,LSL #1]
000026  f8335011          LDRH     r5,[r3,r1,LSL #1]
00002a  45ac              CMP      r12,r5
00002c  bf87              ITTEE    HI
00002e  8221              STRHHI   r1,[r4,#0x10]
000030  1c40              ADDHI    r0,r0,#1
000032  8220              STRHLS   r0,[r4,#0x10]
000034  1c49              ADDLS    r1,r1,#1
000036  e7f0              B        |L5.26|
                  |L5.56|
;;;1345   	I2C_DATAL_COMPARE();      //  
;;;1346       count1=0;
000038  2000              MOVS     r0,#0
00003a  81e0              STRH     r0,[r4,#0xe]
;;;1347   
;;;1348   	
;;;1349   /*在最小值附近停下来。。。后续开启OTP功能即可。。*/
;;;1350   //		VCOMDC1 = SURE[count2];				 //挑选出最好的VCOM的值，下CODE，看效果。
;;;1351   //		SHOW_value(3,50,count2);
;;;1352   //		SHOW_value(3,50,VCOMDC1);
;;;1353   
;;;1354   
;;;1355   
;;;1356   //		VCOMDC1 = SURE[count2 ] + 7;
;;;1357   //		VCOMDC1 = SURE[count2];					///////////////2013-12-05
;;;1358   		VCOMDC1 = SURE[count2];					///////////////2013-12-15
00003c  480d              LDR      r0,|L5.116|
00003e  8a21              LDRH     r1,[r4,#0x10]  ; count2
;;;1359   //	  VCOMDC1 = SURE[count2]+0;  //2014.1.27 count2为最优vcom所在的序号，根据序号在SURE数组找到对应阶数
;;;1360   //		HX8369_cmd_4(0xb6,VCOMDC1,VCOMDC1,0X00);	   ////write the perfect    vcom value
;;;1361   
;;;1362   //			ENTER_LP_mode();
;;;1363   			MIPI_SPI_Write(0x05,0x39,0xB9,0xff,0x83,0x69); 
000040  23ff              MOVS     r3,#0xff
000042  22b9              MOVS     r2,#0xb9
000044  f8300011          LDRH     r0,[r0,r1,LSL #1]     ;1358
000048  82e0              STRH     r0,[r4,#0x16]         ;1358
00004a  2169              MOVS     r1,#0x69
00004c  2083              MOVS     r0,#0x83
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
000052  2139              MOVS     r1,#0x39
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       MIPI_SPI_Write
;;;1364   //				MIPI_SPI_Write(0x04,0x39,0xB6,VCOMDC1,0x28);
;;;1365   				MIPI_SPI_Write(0x04,0x39,0xB6,VCOMDC1,VCOMDC1);
00005a  8ae3              LDRH     r3,[r4,#0x16]  ; VCOMDC1
00005c  22b6              MOVS     r2,#0xb6
00005e  2139              MOVS     r1,#0x39
000060  2004              MOVS     r0,#4
000062  9300              STR      r3,[sp,#0]
000064  f7fffffe          BL       MIPI_SPI_Write
;;;1366   //				
;;;1367   //			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;1368   //        	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC1);
;;;1369   //			VIDEO_ON();
;;;1370   //	}
;;;1371   //		VCOMDC1 = DATA_SUM1[count2];		////挑选出最小的FLICKER值，显示出来。
;;;1372   //		SHOW_value(3,125,VCOMDC1);
;;;1373   
;;;1374   }
000068  b003              ADD      sp,sp,#0xc
00006a  bd30              POP      {r4,r5,pc}
;;;1375   void I2C_DATAL_COMPARE(void)
                          ENDP

                  |L5.108|
                          DCD      ||.data||
                  |L5.112|
                          DCD      ||.bss||+0x5c
                  |L5.116|
                          DCD      ||.bss||+0x98

                          AREA ||i.I2C_MEMSURE||, CODE, READONLY, ALIGN=2

                  I2C_MEMSURE PROC
;;;1290   }
;;;1291   void I2C_MEMSURE(void)
000000  252a              MOVS     r5,#0x2a
;;;1292   { 
;;;1293   		u16 mm_KEYA7 = 1;
;;;1294   	int temp;	  //temp 为加的阶数
;;;1295       u16 a=0x2A,b;
;;;1296   		SENSOR_Check(0x52);			/////S3		
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       SENSOR_Check
;;;1297   	SENSOR_Check(0x72);			/////S2
000008  2072              MOVS     r0,#0x72
00000a  f7fffffe          BL       SENSOR_Check
;;;1298      while(1)
;;;1299      {
;;;1300           	Delay(4);	
;;;1301      	  	mm_KEYA7 =  KEYA7;
00000e  4c14              LDR      r4,|L6.96|
                  |L6.16|
000010  2004              MOVS     r0,#4                 ;1300
000012  f7fffffe          BL       Delay
000016  6820              LDR      r0,[r4,#0]
000018  f0100f80          TST      r0,#0x80
;;;1302      if(mm_KEYA7 == 0)
00001c  d1f8              BNE      |L6.16|
                  |L6.30|
;;;1303   		{
;;;1304   	
;;;1305   			 while(!mm_KEYA7)
;;;1306   			 {		mm_KEYA7 =  KEYA7;}
00001e  6820              LDR      r0,[r4,#0]
000020  f0100f80          TST      r0,#0x80
000024  d0fb              BEQ      |L6.30|
;;;1307   
;;;1308   
;;;1309      
;;;1310   //	HX8369_cmd_4(0xb6,SURE[sss],SURE[sss],0X00);		  ////set vcom
;;;1311   	       MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  2139              MOVS     r1,#0x39
00002c  2003              MOVS     r0,#3
00002e  f7fffffe          BL       MIPI_SPI_Write
;;;1312           	MIPI_SPI_Write(0x03,0x39,0xD9,a);
000032  462b              MOV      r3,r5
000034  22d9              MOVS     r2,#0xd9
000036  2139              MOVS     r1,#0x39
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       MIPI_SPI_Write
;;;1313   		  Delay(5);
00003e  2005              MOVS     r0,#5
000040  f7fffffe          BL       Delay
;;;1314   //	 	 READ_IC_A(0XD9,0x00);
;;;1315   
;;;1316    //   LCD_DisplayStringLine(100,600,"VCOM");
;;;1317    SHOW_IC_VALUE_A(300,600,a);
000044  f44f7116          MOV      r1,#0x258
000048  b2ea              UXTB     r2,r5
00004a  1048              ASRS     r0,r1,#1
00004c  f7fffffe          BL       SHOW_IC_VALUE_A
;;;1318    	
;;;1319   //	SENSOR_Check(0x92);			/////S1
;;;1320   
;;;1321   	Delay(5);
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       Delay
;;;1322           b=	GET_FLICKER();	 ///get flicker value
000056  f7fffffe          BL       GET_FLICKER
;;;1323   //	  SHOW_IC_VALUE_A(300,600,b);
;;;1324   	if(b <= 180)
;;;1325   	{temp=1;  }
;;;1326   	else if((b>180)&&(b< 180*2))
;;;1327   	{temp=2; }
;;;1328   	else
;;;1329   	{ temp=3;}
;;;1330   	a=a+1;
00005a  1c68              ADDS     r0,r5,#1
00005c  b285              UXTH     r5,r0
00005e  e7d7              B        |L6.16|
;;;1331   			
;;;1332   	}
;;;1333   	
;;;1334   
;;;1335      }
;;;1336   }
;;;1337   void I2C_DATAL_COMPAREX(void)
                          ENDP

                  |L6.96|
                          DCD      0x40010808

                          AREA ||i.I2C_MEMSURE1||, CODE, READONLY, ALIGN=2

                  I2C_MEMSURE1 PROC
;;;1220   
;;;1221   void I2C_MEMSURE1(int kk  , int vcomdcdata)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1222   { int i=0,tep1=0,tep2=0,flag=0; //2014.1.27  HFZ
000004  f04f0500          MOV      r5,#0
000008  b083              SUB      sp,sp,#0xc
00000a  4689              MOV      r9,r1
00000c  f1b00800          SUBS     r8,r0,#0
000010  462c              MOV      r4,r5
;;;1223   	int sss=0,yyy=0,aaa=0,temp;	  //temp 为加的阶数
000012  462e              MOV      r6,r5
000014  46aa              MOV      r10,r5
000016  462f              MOV      r7,r5
;;;1224   	for (yyy=0;yyy<kk;yyy++)	 //Ω?
;;;1225   	{SURE[sss]=vcomdcdata+aaa;
;;;1226   
;;;1227   //	HX8369_cmd_4(0xb6,SURE[sss],SURE[sss],0X00);		  ////set vcom
;;;1228   	MIPI_SPI_Write(0x05,0x39,0xB9,0xff,0x83,0x69); 
;;;1229   //				MIPI_SPI_Write(0x04,0x39,0xB6,SURE[sss],0x28);
;;;1230   		MIPI_SPI_Write(0x04,0x39,0xB6,SURE[sss],SURE[sss]);
;;;1231   		
;;;1232   //		MIPI_SPI_Write(0x03,0x39,0x00,0x00);
;;;1233   //        	MIPI_SPI_Write(0x03,0x39,0xD9,SURE[sss]);
;;;1234   //	 SHOW_IC_VALUE_A(300,600,SURE[sss]);
;;;1235   		
;;;1236   	SENSOR_Check(0x52);			/////S3		
;;;1237   	SENSOR_Check(0x72);			/////S2
;;;1238   
;;;1239   	
;;;1240   //	SENSOR_Check(0x92);			/////S1
;;;1241   
;;;1242   	Delay(5);
;;;1243   	DATA_SUM1[count1] =	GET_FLICKER();	 ///get flicker value
;;;1244   ///////////////*------新增一部分光感ID检验功能，一旦光感失效，即停止在此处。-----*/
;;;1245     //------2014.1.27--HFZ-START-------
;;;1246   		if (flag==0)                             //判断是否找到了最低点
;;;1247   			{
;;;1248   				tep2=tep1=DATA_SUM1[count1];
;;;1249   				flag=1;
;;;1250   			}
;;;1251   		else
;;;1252   			{ 
;;;1253   				tep1=DATA_SUM1[count1];
;;;1254   					if(tep1<tep2)
;;;1255   					{
;;;1256   							tep2=tep1;
;;;1257   							 flag=1;  //此处flag再次赋值是为了在一旦再次出现更小值的情况，清除flag计数 令后续可以找到真正的最小值
;;;1258   					}
;;;1259   					else   // if (tep1>tep2)       //如果找到了最低点，则继续寻找两次(flag=1~3)
;;;1260   					  	flag++;
;;;1261   					
;;;1262   					if ((flag==3) & (tep2<300))    //判断是否是真的最低点，再确认是否小于预定值，如果是则停止寻找以节约时间。
;;;1263   					{
;;;1264   						for(i=(count1+1);i<STEP;i++)
;;;1265   							DATA_SUM1[i]=500;                     //填充剩下的数组，否则后续处理会出错
;;;1266   					
;;;1267   							yyy=kk;     //改变判断条件，使本函数提前结束
;;;1268   					}
;;;1269   			}
;;;1270   		  //
;;;1271   	 //------2014.1.27----HFZ--END------	
;;;1272   				
;;;1273   //	temp=1;			
;;;1274   	if(DATA_SUM1[count1] <180)
;;;1275   	{temp=1;  }
;;;1276   	else if((DATA_SUM1[count1]>=180)&&(DATA_SUM1[count1] < 200*2))
;;;1277   	{temp=2; }
;;;1278   	else if((DATA_SUM1[count1]>=400)&&(DATA_SUM1[count1] < 400*2))
;;;1279   	{ temp=4;}
;;;1280   	else
;;;1281   	{ temp=8;}
;;;1282   //	SHOW_value(3,125,DATA_SUM1[coufnt1]);
;;;1283   	count1=count1+1;
;;;1284   //	SHOW_value(3,90,sss);
;;;1285   //	SHOW_value(3,50,vcomdcdata+aaa); //DelayKEY(1);
;;;1286   
;;;1287   	aaa=aaa+temp;
;;;1288   	sss=sss+1;
;;;1289   	}
;;;1290   }
000018  bfdc              ITT      LE
00001a  b003              ADDLE    sp,sp,#0xc
00001c  e8bd8ff0          POPLE    {r4-r11,pc}
                  |L7.32|
000020  eb090007          ADD      r0,r9,r7              ;1225
000024  f8dfb0f4          LDR      r11,|L7.284|
000028  2169              MOVS     r1,#0x69              ;1228
00002a  23ff              MOVS     r3,#0xff              ;1228
00002c  f82b0016          STRH     r0,[r11,r6,LSL #1]    ;1225
000030  2083              MOVS     r0,#0x83              ;1228
000032  e9cd0100          STRD     r0,r1,[sp,#0]         ;1228
000036  22b9              MOVS     r2,#0xb9              ;1228
000038  2139              MOVS     r1,#0x39              ;1228
00003a  2005              MOVS     r0,#5                 ;1228
00003c  f7fffffe          BL       MIPI_SPI_Write
000040  f83b3016          LDRH     r3,[r11,r6,LSL #1]    ;1230
000044  22b6              MOVS     r2,#0xb6              ;1230
000046  2139              MOVS     r1,#0x39              ;1230
000048  2004              MOVS     r0,#4                 ;1230
00004a  9300              STR      r3,[sp,#0]            ;1230
00004c  f7fffffe          BL       MIPI_SPI_Write
000050  2052              MOVS     r0,#0x52              ;1236
000052  f7fffffe          BL       sensor_check
000056  b150              CBZ      r0,|L7.110|
000058  4a31              LDR      r2,|L7.288|
00005a  2150              MOVS     r1,#0x50              ;1236
00005c  2064              MOVS     r0,#0x64              ;1236
00005e  f7fffffe          BL       LCD_DisplayStringLine
000062  4a30              LDR      r2,|L7.292|
000064  2132              MOVS     r1,#0x32              ;1236
000066  2014              MOVS     r0,#0x14              ;1236
000068  f7fffffe          BL       LCD_DisplayStringLine
                  |L7.108|
00006c  e7fe              B        |L7.108|
                  |L7.110|
00006e  2072              MOVS     r0,#0x72              ;1237
000070  f7fffffe          BL       sensor_check
000074  b150              CBZ      r0,|L7.140|
000076  4a2c              LDR      r2,|L7.296|
000078  2150              MOVS     r1,#0x50              ;1237
00007a  208c              MOVS     r0,#0x8c              ;1237
00007c  f7fffffe          BL       LCD_DisplayStringLine
000080  4a28              LDR      r2,|L7.292|
000082  2132              MOVS     r1,#0x32              ;1237
000084  2014              MOVS     r0,#0x14              ;1237
000086  f7fffffe          BL       LCD_DisplayStringLine
                  |L7.138|
00008a  e7fe              B        |L7.138|
                  |L7.140|
00008c  2005              MOVS     r0,#5                 ;1242
00008e  f7fffffe          BL       Delay
000092  f7fffffe          BL       GET_FLICKER
000096  f8dfc098          LDR      r12,|L7.304|
00009a  4601              MOV      r1,r0                 ;1243
00009c  f8dfb08c          LDR      r11,|L7.300|
0000a0  f8bc000e          LDRH     r0,[r12,#0xe]         ;1243  ; count1
0000a4  f82b1010          STRH     r1,[r11,r0,LSL #1]    ;1243
0000a8  b10c              CBZ      r4,|L7.174|
0000aa  42a9              CMP      r1,r5                 ;1254
0000ac  da02              BGE      |L7.180|
                  |L7.174|
0000ae  460d              MOV      r5,r1                 ;1256
0000b0  2401              MOVS     r4,#1                 ;1257
0000b2  e013              B        |L7.220|
                  |L7.180|
0000b4  1c64              ADDS     r4,r4,#1              ;1257
0000b6  2c03              CMP      r4,#3                 ;1262
0000b8  d110              BNE      |L7.220|
0000ba  f5b57f96          CMP      r5,#0x12c             ;1262
0000be  da0d              BGE      |L7.220|
0000c0  f89c3005          LDRB     r3,[r12,#5]           ;1264  ; STEP
0000c4  1c42              ADDS     r2,r0,#1              ;1264
0000c6  429a              CMP      r2,r3                 ;1264
0000c8  bfb8              IT       LT                    ;1265
0000ca  f44f71fa          MOVLT    r1,#0x1f4             ;1265
0000ce  da04              BGE      |L7.218|
                  |L7.208|
0000d0  f82b1012          STRH     r1,[r11,r2,LSL #1]    ;1265
0000d4  1c52              ADDS     r2,r2,#1              ;1265
0000d6  429a              CMP      r2,r3                 ;1264
0000d8  dbfa              BLT      |L7.208|
                  |L7.218|
0000da  46c2              MOV      r10,r8                ;1267
                  |L7.220|
0000dc  f83b1010          LDRH     r1,[r11,r0,LSL #1]    ;1274
0000e0  29b4              CMP      r1,#0xb4              ;1274
0000e2  bf38              IT       CC                    ;1275
0000e4  2201              MOVCC    r2,#1                 ;1275
0000e6  d30c              BCC      |L7.258|
0000e8  f1a102b4          SUB      r2,r1,#0xb4           ;1276
0000ec  2adc              CMP      r2,#0xdc              ;1276
0000ee  bf38              IT       CC                    ;1277
0000f0  2202              MOVCC    r2,#2                 ;1277
0000f2  d306              BCC      |L7.258|
0000f4  f5a171c8          SUB      r1,r1,#0x190          ;1276
0000f8  f5b17fc8          CMP      r1,#0x190             ;1278
0000fc  bf34              ITE      CC                    ;1279
0000fe  2204              MOVCC    r2,#4                 ;1279
000100  2208              MOVCS    r2,#8                 ;1281
                  |L7.258|
000102  1c40              ADDS     r0,r0,#1              ;1281
000104  1c76              ADDS     r6,r6,#1              ;1287
000106  f10a0a01          ADD      r10,r10,#1            ;1287
00010a  f8ac000e          STRH     r0,[r12,#0xe]         ;1283
00010e  4417              ADD      r7,r7,r2              ;1287
000110  45c2              CMP      r10,r8                ;1224
000112  db85              BLT      |L7.32|
000114  b003              ADD      sp,sp,#0xc
000116  e8bd8ff0          POP      {r4-r11,pc}
;;;1291   void I2C_MEMSURE(void)
                          ENDP

00011a  0000              DCW      0x0000
                  |L7.284|
                          DCD      ||.bss||+0x98
                  |L7.288|
                          DCD      ||i.SENSOR_Check||+0x48
                  |L7.292|
                          DCD      ||i.SENSOR_Check||+0x54
                  |L7.296|
                          DCD      ||i.SENSOR_Check||+0x4c
                  |L7.300|
                          DCD      ||.bss||+0x5c
                  |L7.304|
                          DCD      ||.data||

                          AREA ||i.ID_CHECK||, CODE, READONLY, ALIGN=2

                  ID_CHECK PROC
;;;633    
;;;634    u8 ID_CHECK(u16 adx,u16 ady)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;635    {
;;;636    //	READ_IC(0XB6,0x00);
;;;637    FontR = 0; FontG = 0; FontB = 0;
000004  4e35              LDR      r6,|L8.220|
000006  2500              MOVS     r5,#0
000008  4f35              LDR      r7,|L8.224|
00000a  f8df80d8          LDR      r8,|L8.228|
00000e  7035              STRB     r5,[r6,#0]
000010  703d              STRB     r5,[r7,#0]
000012  f8885000          STRB     r5,[r8,#0]
;;;638    	READ_IC(0XDA,0x00);
000016  4629              MOV      r1,r5
000018  20da              MOVS     r0,#0xda
00001a  f7fffffe          BL       READ_IC
;;;639    	OTP_VALUE1 =   MIPI_READ_DATA[0];
00001e  f8df90c8          LDR      r9,|L8.232|
000022  4c32              LDR      r4,|L8.236|
;;;640    	READ_IC(0XDB,0x00);
000024  2100              MOVS     r1,#0
000026  f8990000          LDRB     r0,[r9,#0]            ;639  ; MIPI_READ_DATA
00002a  71a0              STRB     r0,[r4,#6]            ;639
00002c  20db              MOVS     r0,#0xdb
00002e  f7fffffe          BL       READ_IC
;;;641    	OTP_VALUE2 =   MIPI_READ_DATA[0];
000032  f8990000          LDRB     r0,[r9,#0]  ; MIPI_READ_DATA
000036  71e0              STRB     r0,[r4,#7]
;;;642    	READ_IC(0XDC,0x00);
000038  2100              MOVS     r1,#0
00003a  20dc              MOVS     r0,#0xdc
00003c  f7fffffe          BL       READ_IC
;;;643    	OTP_TIMES =   MIPI_READ_DATA[0];
000040  f8990000          LDRB     r0,[r9,#0]  ; MIPI_READ_DATA
000044  7220              STRB     r0,[r4,#8]
;;;644    //	READ_IC(0X04,0x00);
;;;645    
;;;646    	LCD_DisplayStringLine(100,100, "ID1");
000046  2164              MOVS     r1,#0x64
000048  a229              ADR      r2,|L8.240|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       LCD_DisplayStringLine
;;;647    	SHOW_IC_VALUE_A(200,100, OTP_VALUE1);
000050  79a2              LDRB     r2,[r4,#6]  ; OTP_VALUE1
000052  2164              MOVS     r1,#0x64
000054  20c8              MOVS     r0,#0xc8
000056  f7fffffe          BL       SHOW_IC_VALUE_A
;;;648    	 LCD_DisplayStringLine(100,200, "ID2");
00005a  a226              ADR      r2,|L8.244|
00005c  21c8              MOVS     r1,#0xc8
00005e  2064              MOVS     r0,#0x64
000060  f7fffffe          BL       LCD_DisplayStringLine
;;;649    	SHOW_IC_VALUE_A(200,200, OTP_VALUE2);
000064  21c8              MOVS     r1,#0xc8
000066  79e2              LDRB     r2,[r4,#7]  ; OTP_VALUE2
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       SHOW_IC_VALUE_A
;;;650    	 LCD_DisplayStringLine(100,300, "ID3");
00006e  a222              ADR      r2,|L8.248|
000070  f44f7196          MOV      r1,#0x12c
000074  2064              MOVS     r0,#0x64
000076  f7fffffe          BL       LCD_DisplayStringLine
;;;651    	SHOW_IC_VALUE_A(200,300, OTP_TIMES);
00007a  7a22              LDRB     r2,[r4,#8]  ; OTP_TIMES
00007c  f44f7196          MOV      r1,#0x12c
000080  20c8              MOVS     r0,#0xc8
000082  f7fffffe          BL       SHOW_IC_VALUE_A
;;;652    //	LCD_DisplayStringLine_A(adx,ady,"ID=");
;;;653    
;;;654    	if((OTP_VALUE1 == 0xD5)&&(OTP_VALUE2 == 0x97)&&(OTP_TIMES == 0xCA))
000086  79a1              LDRB     r1,[r4,#6]  ; OTP_VALUE1
;;;655    	{
;;;656    		ID_OK = 0;
;;;657    		FontR = 0; FontG = 255; FontB = 0;
000088  20ff              MOVS     r0,#0xff
00008a  29d5              CMP      r1,#0xd5              ;654
00008c  bf01              ITTTT    EQ                    ;654
00008e  79e1              LDRBEQ   r1,[r4,#7]            ;654  ; OTP_VALUE2
000090  2997              CMPEQ    r1,#0x97              ;654
000092  7a21              LDRBEQ   r1,[r4,#8]            ;654  ; OTP_TIMES
000094  29ca              CMPEQ    r1,#0xca              ;654
000096  d014              BEQ      |L8.194|
;;;658    //		LCD_DisplayStringLine_A(adx+150,ady,"OK");
;;;659    		LCD_DisplayStringLine_A(50,400,"ID CODE PASS");
;;;660    	}
;;;661    	else
;;;662    	{
;;;663    		ID_OK = 1;
000098  f04f0101          MOV      r1,#1
00009c  72a1              STRB     r1,[r4,#0xa]
;;;664    		FontR = 255; FontG = 0; FontB = 0;
00009e  7030              STRB     r0,[r6,#0]
0000a0  703d              STRB     r5,[r7,#0]
0000a2  f8885000          STRB     r5,[r8,#0]
;;;665    //		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;666    		LCD_DisplayStringLine_A( 50 ,400,"ID CODE NG");
0000a6  a215              ADR      r2,|L8.252|
0000a8  f44f71c8          MOV      r1,#0x190
0000ac  f04f0032          MOV      r0,#0x32
0000b0  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L8.180|
;;;667    	}
;;;668    	FontR = 0; FontG = 0; FontB = 0;
0000b4  7035              STRB     r5,[r6,#0]
0000b6  703d              STRB     r5,[r7,#0]
0000b8  f8885000          STRB     r5,[r8,#0]
;;;669    //	DelayKEY(15);
;;;670    
;;;671    	return ID_OK;
0000bc  7aa0              LDRB     r0,[r4,#0xa]  ; ID_OK
;;;672    }
0000be  e8bd87f0          POP      {r4-r10,pc}
                  |L8.194|
0000c2  72a5              STRB     r5,[r4,#0xa]          ;656
0000c4  7035              STRB     r5,[r6,#0]            ;657
0000c6  7038              STRB     r0,[r7,#0]            ;657
0000c8  f8885000          STRB     r5,[r8,#0]            ;657
0000cc  a20e              ADR      r2,|L8.264|
0000ce  f44f71c8          MOV      r1,#0x190             ;659
0000d2  2032              MOVS     r0,#0x32              ;659
0000d4  f7fffffe          BL       LCD_DisplayStringLine_A
0000d8  e7ec              B        |L8.180|
;;;673    
                          ENDP

0000da  0000              DCW      0x0000
                  |L8.220|
                          DCD      FontR
                  |L8.224|
                          DCD      FontG
                  |L8.228|
                          DCD      FontB
                  |L8.232|
                          DCD      ||.bss||
                  |L8.236|
                          DCD      ||.data||
                  |L8.240|
0000f0  49443100          DCB      "ID1",0
                  |L8.244|
0000f4  49443200          DCB      "ID2",0
                  |L8.248|
0000f8  49443300          DCB      "ID3",0
                  |L8.252|
0000fc  49442043          DCB      "ID CODE NG",0
000100  4f444520
000104  4e4700  
000107  00                DCB      0
                  |L8.264|
000108  49442043          DCB      "ID CODE PASS",0
00010c  4f444520
000110  50415353
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0

                          AREA ||i.ID_CHECK_A||, CODE, READONLY, ALIGN=2

                  ID_CHECK_A PROC
;;;673    
;;;674    u8 ID_CHECK_A(u16 adx,u16 ady)
000000  b570              PUSH     {r4-r6,lr}
;;;675    {
;;;676        READ_IC(0X5F,0x00);
000002  2100              MOVS     r1,#0
000004  205f              MOVS     r0,#0x5f
000006  f7fffffe          BL       READ_IC
;;;677    	OTP_TIMES =   MIPI_READ_DATA[0];
00000a  4d1c              LDR      r5,|L9.124|
00000c  4c1c              LDR      r4,|L9.128|
;;;678    	
;;;679    	READ_IC(0XDA,0x00);
00000e  2100              MOVS     r1,#0
000010  7828              LDRB     r0,[r5,#0]            ;677  ; MIPI_READ_DATA
000012  7220              STRB     r0,[r4,#8]            ;677
000014  20da              MOVS     r0,#0xda
000016  f7fffffe          BL       READ_IC
;;;680    	OTP_VALUE1 =   MIPI_READ_DATA[0];
00001a  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
00001c  71a0              STRB     r0,[r4,#6]
;;;681    	READ_IC(0XDB,0x00);
00001e  2100              MOVS     r1,#0
000020  20db              MOVS     r0,#0xdb
000022  f7fffffe          BL       READ_IC
;;;682    	OTP_VALUE2 =   MIPI_READ_DATA[0];
000026  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
000028  71e0              STRB     r0,[r4,#7]
;;;683    	READ_IC(0XDC,0x00);
00002a  2100              MOVS     r1,#0
00002c  20dc              MOVS     r0,#0xdc
00002e  f7fffffe          BL       READ_IC
;;;684    	OTP_TIMES =   MIPI_READ_DATA[0];
000032  7828              LDRB     r0,[r5,#0]  ; MIPI_READ_DATA
000034  7220              STRB     r0,[r4,#8]
;;;685    
;;;686    //	LCD_DisplayStringLine_A(adx,ady,"ID=");
;;;687    
;;;688    	if((OTP_VALUE1 == 0xD5)&&(OTP_VALUE2 == 0x97)&&(OTP_TIMES == 0xCA))
000036  79a6              LDRB     r6,[r4,#6]  ; OTP_VALUE1
000038  2100              MOVS     r1,#0
;;;689    	{
;;;690    		ID_OK = 0;
;;;691    		FontR = 0; FontG = 255; FontB = 0;
00003a  4a12              LDR      r2,|L9.132|
00003c  23ff              MOVS     r3,#0xff
00003e  f8dfc048          LDR      r12,|L9.136|
000042  4d12              LDR      r5,|L9.140|
000044  2ed5              CMP      r6,#0xd5              ;688
000046  bf02              ITTT     EQ                    ;688
000048  79e6              LDRBEQ   r6,[r4,#7]            ;688  ; OTP_VALUE2
00004a  2e97              CMPEQ    r6,#0x97              ;688
00004c  28ca              CMPEQ    r0,#0xca              ;688
00004e  d00f              BEQ      |L9.112|
;;;692    //		LCD_DisplayStringLine_A(adx+150,ady,"OK");
;;;693    	}
;;;694    	else
;;;695    	{
;;;696    		ID_OK = 1;
000050  f04f0001          MOV      r0,#1
000054  72a0              STRB     r0,[r4,#0xa]
;;;697    		FontR = 255; FontG = 0; FontB = 0;
000056  7013              STRB     r3,[r2,#0]
000058  f88c1000          STRB     r1,[r12,#0]
00005c  7029              STRB     r1,[r5,#0]
;;;698    		LCD_DisplayStringLine_A( 50 ,400,"ID CODE NG");
00005e  a20c              ADR      r2,|L9.144|
000060  f44f71c8          MOV      r1,#0x190
000064  f04f0032          MOV      r0,#0x32
000068  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L9.108|
;;;699    //		while(1);
;;;700    //		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;701    	}
;;;702    
;;;703    
;;;704    	return ID_OK;
00006c  7aa0              LDRB     r0,[r4,#0xa]  ; ID_OK
;;;705    }
00006e  bd70              POP      {r4-r6,pc}
                  |L9.112|
000070  72a1              STRB     r1,[r4,#0xa]          ;690
000072  7011              STRB     r1,[r2,#0]            ;691
000074  f88c3000          STRB     r3,[r12,#0]           ;691
000078  7029              STRB     r1,[r5,#0]            ;691
00007a  e7f7              B        |L9.108|
;;;706    
                          ENDP

                  |L9.124|
                          DCD      ||.bss||
                  |L9.128|
                          DCD      ||.data||
                  |L9.132|
                          DCD      FontR
                  |L9.136|
                          DCD      FontG
                  |L9.140|
                          DCD      FontB
                  |L9.144|
000090  49442043          DCB      "ID CODE NG",0
000094  4f444520
000098  4e4700  
00009b  00                DCB      0

                          AREA ||i.InterruptConfig||, CODE, READONLY, ALIGN=2

                  InterruptConfig PROC
;;;949    *******************************************************************************/
;;;950    void InterruptConfig(void)
000000  b510              PUSH     {r4,lr}
;;;951    { 
;;;952      /* Deinitializes the NVIC */
;;;953      NVIC_DeInit();
000002  f7fffffe          BL       NVIC_DeInit
;;;954    
;;;955      NVIC_Configuration();
000006  f7fffffe          BL       NVIC_Configuration
;;;956    
;;;957      /* Configure the Priority Group to 2 bits */
;;;958      //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);		
;;;959    
;;;960      /* Configure the SysTick handler priority */
;;;961      //为了使用SDIO中断，下面的中断优先级被我改低了
;;;962      NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 1, 1);
00000a  2201              MOVS     r2,#1
00000c  e8bd4010          POP      {r4,lr}
000010  4611              MOV      r1,r2
000012  4801              LDR      r0,|L10.24|
000014  f7ffbffe          B.W      NVIC_SystemHandlerPriorityConfig
;;;963    }
;;;964    
                          ENDP

                  |L10.24|
                          DCD      0x0002c39a

                          AREA ||i.KEYGPIO_Init||, CODE, READONLY, ALIGN=2

                  KEYGPIO_Init PROC
;;;1032   
;;;1033   void KEYGPIO_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1034   {
;;;1035    GPIO_InitTypeDef GPIO_InitStructure; 
;;;1036    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2015              MOVS     r0,#0x15
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1037     
;;;1038     /*[把KEYGPIO KEY7/8配置成输入模式] */
;;;1039     GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_6;
00000a  2040              MOVS     r0,#0x40
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;1040     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
000010  2448              MOVS     r4,#0x48
000012  f88d4003          STRB     r4,[sp,#3]
;;;1041     GPIO_Init(GPIOC, &GPIO_InitStructure);  
000016  4669              MOV      r1,sp
000018  4806              LDR      r0,|L11.52|
00001a  f7fffffe          BL       GPIO_Init
;;;1042   
;;;1043     GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_7 ;
00001e  2080              MOVS     r0,#0x80
000020  f8ad0000          STRH     r0,[sp,#0]
;;;1044     GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
000024  f88d4003          STRB     r4,[sp,#3]
;;;1045     GPIO_Init(GPIOA, &GPIO_InitStructure); 
000028  4669              MOV      r1,sp
00002a  4803              LDR      r0,|L11.56|
00002c  f7fffffe          BL       GPIO_Init
;;;1046       
;;;1047   //    GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_8;
;;;1048   //  GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_IPU;    // 
;;;1049   //  GPIO_Init(GPIOA, &GPIO_InitStructure); 
;;;1050   }
000030  bd38              POP      {r3-r5,pc}
;;;1051   
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40011000
                  |L11.56|
                          DCD      0x40010800

                          AREA ||i.KEY_adjust||, CODE, READONLY, ALIGN=2

                  KEY_adjust PROC
;;;427    
;;;428    void KEY_adjust(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;429    {
;;;430    	u16 mm_KEYA7 = 1 ;
;;;431    	u16 mm_KEYA8 = 1 ;
;;;432    	u16 mm_KEYC6 = 1;
;;;433    	u8 OTP_FLAG = 1;
000004  2401              MOVS     r4,#1
;;;434    
;;;435    
;;;436       while(OTP_FLAG)
;;;437       {
;;;438    		mm_KEYA7 = 	KEYA7;
000006  f8df80e8          LDR      r8,|L12.240|
;;;439    		mm_KEYA8 =  KEYA8;
;;;440    		mm_KEYC6 = 	KEYC6;
00000a  f8df90e8          LDR      r9,|L12.244|
;;;441    		
;;;442    		if(mm_KEYA7 == 0)
;;;443    		{
;;;444    		
;;;445    			 while(!mm_KEYA7)
;;;446    			{	mm_KEYA7 =  KEYA7;}
;;;447    
;;;448    			VCOMDC++;
00000e  4d3a              LDR      r5,|L12.248|
000010  f04f0a00          MOV      r10,#0                ;440
000014  46a3              MOV      r11,r4                ;430
                  |L12.22|
000016  f8d80000          LDR      r0,[r8,#0]            ;438
00001a  f8d81000          LDR      r1,[r8,#0]            ;439
00001e  f0100f80          TST      r0,#0x80              ;438
000022  f4017680          AND      r6,r1,#0x100          ;439
000026  f8d91008          LDR      r1,[r9,#8]            ;440
00002a  f0010740          AND      r7,r1,#0x40           ;440
00002e  d11e              BNE      |L12.110|
                  |L12.48|
000030  f8d80000          LDR      r0,[r8,#0]            ;446
000034  f0100f80          TST      r0,#0x80              ;446
000038  d0fa              BEQ      |L12.48|
00003a  7928              LDRB     r0,[r5,#4]  ; VCOMDC
00003c  1c40              ADDS     r0,r0,#1
00003e  7128              STRB     r0,[r5,#4]
;;;449    			ENTER_LP_mode();
000040  f7fffffe          BL       ENTER_LP_mode
;;;450    			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000044  2300              MOVS     r3,#0
000046  461a              MOV      r2,r3
000048  2139              MOVS     r1,#0x39
00004a  2003              MOVS     r0,#3
00004c  f7fffffe          BL       MIPI_SPI_Write
;;;451            	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC);
000050  792b              LDRB     r3,[r5,#4]  ; VCOMDC
000052  22d9              MOVS     r2,#0xd9
000054  2139              MOVS     r1,#0x39
000056  2003              MOVS     r0,#3
000058  f7fffffe          BL       MIPI_SPI_Write
;;;452    			SHOW_IC_VALUE_A(270,800, VCOMDC);
00005c  792a              LDRB     r2,[r5,#4]  ; VCOMDC
00005e  f44f7148          MOV      r1,#0x320
000062  f44f7087          MOV      r0,#0x10e
000066  f7fffffe          BL       SHOW_IC_VALUE_A
;;;453    			VIDEO_ON();
00006a  f7fffffe          BL       VIDEO_ON
                  |L12.110|
;;;454    		}
;;;455    		if(mm_KEYA8 == 0)
00006e  b9f6              CBNZ     r6,|L12.174|
                  |L12.112|
;;;456    		{
;;;457    		  
;;;458    			 while(!mm_KEYA8)
;;;459    			  {	mm_KEYA8 =  KEYA8;}
000070  f8d80000          LDR      r0,[r8,#0]
000074  f4107f80          TST      r0,#0x100
000078  d0fa              BEQ      |L12.112|
;;;460    			VCOMDC--;
00007a  7928              LDRB     r0,[r5,#4]  ; VCOMDC
00007c  1e40              SUBS     r0,r0,#1
00007e  7128              STRB     r0,[r5,#4]
;;;461    			ENTER_LP_mode();
000080  f7fffffe          BL       ENTER_LP_mode
;;;462    			MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000084  2300              MOVS     r3,#0
000086  461a              MOV      r2,r3
000088  2139              MOVS     r1,#0x39
00008a  2003              MOVS     r0,#3
00008c  f7fffffe          BL       MIPI_SPI_Write
;;;463            	MIPI_SPI_Write(0x03,0x39,0xD9,VCOMDC);
000090  792b              LDRB     r3,[r5,#4]  ; VCOMDC
000092  22d9              MOVS     r2,#0xd9
000094  2139              MOVS     r1,#0x39
000096  2003              MOVS     r0,#3
000098  f7fffffe          BL       MIPI_SPI_Write
;;;464    			SHOW_IC_VALUE_A(270,800, VCOMDC);
00009c  792a              LDRB     r2,[r5,#4]  ; VCOMDC
00009e  f44f7148          MOV      r1,#0x320
0000a2  f44f7087          MOV      r0,#0x10e
0000a6  f7fffffe          BL       SHOW_IC_VALUE_A
;;;465    			VIDEO_ON();
0000aa  f7fffffe          BL       VIDEO_ON
                  |L12.174|
;;;466    		}
;;;467    		if(mm_KEYC6 == 0)
0000ae  b9c7              CBNZ     r7,|L12.226|
                  |L12.176|
;;;468    		{
;;;469    	
;;;470    			 while(!mm_KEYC6)
;;;471    			 {		mm_KEYC6 =  KEYC6;}
0000b0  f8d90008          LDR      r0,[r9,#8]
0000b4  f0100f40          TST      r0,#0x40
0000b8  d0fa              BEQ      |L12.176|
;;;472    			aat = 1;
0000ba  f8a5b012          STRH     r11,[r5,#0x12]
;;;473    			ENTER_LP_mode();
0000be  f7fffffe          BL       ENTER_LP_mode
;;;474    			MTP_ID();
0000c2  f7fffffe          BL       MTP_ID
;;;475    			FontR = FontG = FontB = 0;
0000c6  480d              LDR      r0,|L12.252|
0000c8  f880a000          STRB     r10,[r0,#0]
0000cc  480c              LDR      r0,|L12.256|
0000ce  f880a000          STRB     r10,[r0,#0]
0000d2  480c              LDR      r0,|L12.260|
0000d4  f880a000          STRB     r10,[r0,#0]
;;;476    
;;;477    			Soft_reset();
0000d8  f7fffffe          BL       Soft_reset
;;;478    			OTP_FLAG = 0;
0000dc  2400              MOVS     r4,#0
;;;479    			aat = 0;
0000de  f8a5a012          STRH     r10,[r5,#0x12]
                  |L12.226|
;;;480    		}
;;;481    		Delay(25);	
0000e2  2019              MOVS     r0,#0x19
0000e4  f7fffffe          BL       Delay
0000e8  2c00              CMP      r4,#0                 ;436
0000ea  d194              BNE      |L12.22|
;;;482    		
;;;483    		
;;;484    	}
;;;485    }
0000ec  e8bd9ff0          POP      {r4-r12,pc}
;;;486    
                          ENDP

                  |L12.240|
                          DCD      0x40010808
                  |L12.244|
                          DCD      0x40011000
                  |L12.248|
                          DCD      ||.data||
                  |L12.252|
                          DCD      FontB
                  |L12.256|
                          DCD      FontG
                  |L12.260|
                          DCD      FontR

                          AREA ||i.MDelay||, CODE, READONLY, ALIGN=2

                  MDelay PROC
;;;984    
;;;985    void MDelay(u32 nCount)						 ////delay 1ms		for auto OTP use
000000  b510              PUSH     {r4,lr}
;;;986    {
;;;987      TimingDelay = nCount;
000002  4c06              LDR      r4,|L13.28|
000004  61a0              STR      r0,[r4,#0x18]  ; TimingDelay
;;;988      /* Enable the SysTick Counter */
;;;989      //SysTick_CounterCmd(SysTick_Counter_Enable);	
;;;990      SysTick_ITConfig(ENABLE);//ENABLE DISABLE		
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       SysTick_ITConfig
                  |L13.12|
;;;991      while(TimingDelay != 0)
00000c  69a0              LDR      r0,[r4,#0x18]  ; TimingDelay
00000e  2800              CMP      r0,#0
000010  d1fc              BNE      |L13.12|
;;;992      {;;}
;;;993      SysTick_ITConfig(DISABLE);//ENABLE DISABLE 
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      SysTick_ITConfig
;;;994    }
;;;995    /*******************************************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      ||.data||

                          AREA ||i.MTP||, CODE, READONLY, ALIGN=1

                  MTP PROC
;;;1390   
;;;1391   void MTP(void)
000000  b510              PUSH     {r4,lr}
;;;1392   {
;;;1393   	///display off
;;;1394   			SSD1963GPIOOUTCOM(0xBC);		                
000002  20bc              MOVS     r0,#0xbc
000004  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1395   	SSD1963GPIOOUTDATA_16(0x0001);					
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1396   			SSD1963GPIOOUTCOM(0xbf);
00000e  20bf              MOVS     r0,#0xbf
000010  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1397   	SSD1963GPIOOUTDATA_18(0x28);	  //
000014  2028              MOVS     r0,#0x28
000016  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1398   	Delay(5);			 //delay 40ms
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       Delay
;;;1399   
;;;1400   			SSD1963GPIOOUTCOM(0xBC);		                
000020  20bc              MOVS     r0,#0xbc
000022  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1401   	SSD1963GPIOOUTDATA_16(0x0002);					
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1402   			SSD1963GPIOOUTCOM(0xbf);
00002c  20bf              MOVS     r0,#0xbf
00002e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1403   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000032  20b7              MOVS     r0,#0xb7
000034  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1404   	SSD1963GPIOOUTDATA_18(0x5a);
000038  205a              MOVS     r0,#0x5a
00003a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1405   	MDelay(20);			   ////delay 1ms
00003e  2014              MOVS     r0,#0x14
000040  f7fffffe          BL       MDelay
;;;1406   
;;;1407   	//////////set otp_index[8:0]
;;;1408   			SSD1963GPIOOUTCOM(0xBC);		                
000044  20bc              MOVS     r0,#0xbc
000046  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1409   	SSD1963GPIOOUTDATA_16(0x0006);					
00004a  2006              MOVS     r0,#6
00004c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1410   			SSD1963GPIOOUTCOM(0xbf);
000050  20bf              MOVS     r0,#0xbf
000052  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1411   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000056  20b7              MOVS     r0,#0xb7
000058  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1412   	SSD1963GPIOOUTDATA_18(0x5a);
00005c  205a              MOVS     r0,#0x5a
00005e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1413   	SSD1963GPIOOUTDATA_18(0x00);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1414   	SSD1963GPIOOUTDATA_18(0x00);
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1415   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
00006e  200d              MOVS     r0,#0xd
000070  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1416   	SSD1963GPIOOUTDATA_18(0x00);
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1417   	MDelay(10);	
00007a  200a              MOVS     r0,#0xa
00007c  f7fffffe          BL       MDelay
;;;1418   	
;;;1419   	///////////////set otp_mask[7:0]
;;;1420   			SSD1963GPIOOUTCOM(0xBC);		               
000080  20bc              MOVS     r0,#0xbc
000082  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1421   	SSD1963GPIOOUTDATA_16(0x0006);						 
000086  2006              MOVS     r0,#6
000088  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1422   			SSD1963GPIOOUTCOM(0xbf);
00008c  20bf              MOVS     r0,#0xbf
00008e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1423   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000092  20b7              MOVS     r0,#0xb7
000094  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1424   	SSD1963GPIOOUTDATA_18(0x5a);
000098  205a              MOVS     r0,#0x5a
00009a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1425   	SSD1963GPIOOUTDATA_18(0x00);
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1426   	SSD1963GPIOOUTDATA_18(0x00);
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1427   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
0000aa  200d              MOVS     r0,#0xd
0000ac  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1428   	SSD1963GPIOOUTDATA_18(0x00);
0000b0  2000              MOVS     r0,#0
0000b2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1429   	MDelay(10);		
0000b6  200a              MOVS     r0,#0xa
0000b8  f7fffffe          BL       MDelay
;;;1430   
;;;1431   	/////////////set otp address
;;;1432   			SSD1963GPIOOUTCOM(0xBC);		              
0000bc  20bc              MOVS     r0,#0xbc
0000be  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1433   	SSD1963GPIOOUTDATA_16(0x0006);						 
0000c2  2006              MOVS     r0,#6
0000c4  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1434   			SSD1963GPIOOUTCOM(0xbf);
0000c8  20bf              MOVS     r0,#0xbf
0000ca  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1435   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0000ce  20b7              MOVS     r0,#0xb7
0000d0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1436   	SSD1963GPIOOUTDATA_18(0x5a);
0000d4  205a              MOVS     r0,#0x5a
0000d6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1437   	SSD1963GPIOOUTDATA_18(0x00);
0000da  2000              MOVS     r0,#0
0000dc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1438   	SSD1963GPIOOUTDATA_18(0x00);
0000e0  2000              MOVS     r0,#0
0000e2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1439   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
0000e6  200d              MOVS     r0,#0xd
0000e8  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1440   	SSD1963GPIOOUTDATA_18(0x00);
0000ec  2000              MOVS     r0,#0
0000ee  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1441   	MDelay(10);
0000f2  200a              MOVS     r0,#0xa
0000f4  f7fffffe          BL       MDelay
;;;1442   
;;;1443   	/////////////set otp_prog = 1;
;;;1444   			SSD1963GPIOOUTCOM(0xBC);		             
0000f8  20bc              MOVS     r0,#0xbc
0000fa  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1445   	SSD1963GPIOOUTDATA_16(0x0006);						 
0000fe  2006              MOVS     r0,#6
000100  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1446   			SSD1963GPIOOUTCOM(0xbf);
000104  20bf              MOVS     r0,#0xbf
000106  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1447   	SSD1963GPIOOUTDATA_18(0xb7);	  //
00010a  20b7              MOVS     r0,#0xb7
00010c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1448   	SSD1963GPIOOUTDATA_18(0x5a);
000110  205a              MOVS     r0,#0x5a
000112  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1449   	SSD1963GPIOOUTDATA_18(0x00);
000116  2000              MOVS     r0,#0
000118  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1450   	SSD1963GPIOOUTDATA_18(0x00);
00011c  2000              MOVS     r0,#0
00011e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1451   	SSD1963GPIOOUTDATA_18(0x0d);		   /////烧录otp的0x0d的VCOM_F1
000122  200d              MOVS     r0,#0xd
000124  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1452   	SSD1963GPIOOUTDATA_18(0x01);
000128  2001              MOVS     r0,#1
00012a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1453   	MDelay(45);		 		///DELAY 11ms
00012e  202d              MOVS     r0,#0x2d
000130  f7fffffe          BL       MDelay
;;;1454   
;;;1455   	/////////////set otp_index[8:0]
;;;1456   			SSD1963GPIOOUTCOM(0xBC);		              
000134  20bc              MOVS     r0,#0xbc
000136  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1457   	SSD1963GPIOOUTDATA_16(0x0006);						 
00013a  2006              MOVS     r0,#6
00013c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1458   			SSD1963GPIOOUTCOM(0xbf);
000140  20bf              MOVS     r0,#0xbf
000142  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1459   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000146  20b7              MOVS     r0,#0xb7
000148  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1460   	SSD1963GPIOOUTDATA_18(0x5a);
00014c  205a              MOVS     r0,#0x5a
00014e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1461   	SSD1963GPIOOUTDATA_18(0x00);
000152  2000              MOVS     r0,#0
000154  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1462   	SSD1963GPIOOUTDATA_18(0x00);
000158  2000              MOVS     r0,#0
00015a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1463   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
00015e  200e              MOVS     r0,#0xe
000160  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1464   	SSD1963GPIOOUTDATA_18(0x00);
000164  2000              MOVS     r0,#0
000166  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1465   	MDelay(10);
00016a  200a              MOVS     r0,#0xa
00016c  f7fffffe          BL       MDelay
;;;1466   
;;;1467   	/////////////set otp_mask[7:0]
;;;1468   			SSD1963GPIOOUTCOM(0xBC);		                
000170  20bc              MOVS     r0,#0xbc
000172  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1469   	SSD1963GPIOOUTDATA_16(0x0006);						
000176  2006              MOVS     r0,#6
000178  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1470   			SSD1963GPIOOUTCOM(0xbf);
00017c  20bf              MOVS     r0,#0xbf
00017e  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1471   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000182  20b7              MOVS     r0,#0xb7
000184  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1472   	SSD1963GPIOOUTDATA_18(0x5a);
000188  205a              MOVS     r0,#0x5a
00018a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1473   	SSD1963GPIOOUTDATA_18(0x00);
00018e  2000              MOVS     r0,#0
000190  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1474   	SSD1963GPIOOUTDATA_18(0x00);
000194  2000              MOVS     r0,#0
000196  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1475   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
00019a  200e              MOVS     r0,#0xe
00019c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1476   	SSD1963GPIOOUTDATA_18(0x00);
0001a0  2000              MOVS     r0,#0
0001a2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1477   	MDelay(10);
0001a6  200a              MOVS     r0,#0xa
0001a8  f7fffffe          BL       MDelay
;;;1478   
;;;1479   	/////////////set otp address
;;;1480   			SSD1963GPIOOUTCOM(0xBC);		                 
0001ac  20bc              MOVS     r0,#0xbc
0001ae  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1481   	SSD1963GPIOOUTDATA_16(0x0006);					
0001b2  2006              MOVS     r0,#6
0001b4  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1482   			SSD1963GPIOOUTCOM(0xbf);
0001b8  20bf              MOVS     r0,#0xbf
0001ba  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1483   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0001be  20b7              MOVS     r0,#0xb7
0001c0  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1484   	SSD1963GPIOOUTDATA_18(0x5a);
0001c4  205a              MOVS     r0,#0x5a
0001c6  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1485   	SSD1963GPIOOUTDATA_18(0x00);
0001ca  2000              MOVS     r0,#0
0001cc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1486   	SSD1963GPIOOUTDATA_18(0x00);
0001d0  2000              MOVS     r0,#0
0001d2  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1487   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
0001d6  200e              MOVS     r0,#0xe
0001d8  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1488   	SSD1963GPIOOUTDATA_18(0x00);
0001dc  2000              MOVS     r0,#0
0001de  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1489   	MDelay(10);
0001e2  200a              MOVS     r0,#0xa
0001e4  f7fffffe          BL       MDelay
;;;1490   
;;;1491   	/////////////set otp_prog = 1;
;;;1492   			SSD1963GPIOOUTCOM(0xBC);		                 
0001e8  20bc              MOVS     r0,#0xbc
0001ea  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1493   	SSD1963GPIOOUTDATA_16(0x0006);						  
0001ee  2006              MOVS     r0,#6
0001f0  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1494   			SSD1963GPIOOUTCOM(0xbf);
0001f4  20bf              MOVS     r0,#0xbf
0001f6  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1495   	SSD1963GPIOOUTDATA_18(0xb7);	  //
0001fa  20b7              MOVS     r0,#0xb7
0001fc  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1496   	SSD1963GPIOOUTDATA_18(0x5a);
000200  205a              MOVS     r0,#0x5a
000202  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1497   	SSD1963GPIOOUTDATA_18(0x00);
000206  2000              MOVS     r0,#0
000208  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1498   	SSD1963GPIOOUTDATA_18(0x00);
00020c  2000              MOVS     r0,#0
00020e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1499   	SSD1963GPIOOUTDATA_18(0x0e);				/////烧录otp的0x0E的VCOM_B1
000212  200e              MOVS     r0,#0xe
000214  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1500   	SSD1963GPIOOUTDATA_18(0x01);
000218  2001              MOVS     r0,#1
00021a  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1501   	MDelay(45);		 		///DELAY 11ms
00021e  202d              MOVS     r0,#0x2d
000220  f7fffffe          BL       MDelay
;;;1502   
;;;1503      	//////MTP   OVER ,,,OTP  Disable
;;;1504   			SSD1963GPIOOUTCOM(0xBC);		                 
000224  20bc              MOVS     r0,#0xbc
000226  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1505   	SSD1963GPIOOUTDATA_16(0x0002);						  
00022a  2002              MOVS     r0,#2
00022c  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1506   			SSD1963GPIOOUTCOM(0xbf);
000230  20bf              MOVS     r0,#0xbf
000232  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1507   	SSD1963GPIOOUTDATA_18(0xb7);	  //
000236  20b7              MOVS     r0,#0xb7
000238  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1508   	SSD1963GPIOOUTDATA_18(0xff);
00023c  20ff              MOVS     r0,#0xff
00023e  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1509   	MDelay(10);
000242  200a              MOVS     r0,#0xa
000244  f7fffffe          BL       MDelay
;;;1510   
;;;1511   	///display on
;;;1512   			SSD1963GPIOOUTCOM(0xBC);		                
000248  20bc              MOVS     r0,#0xbc
00024a  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1513   	SSD1963GPIOOUTDATA_16(0x0001);					
00024e  2001              MOVS     r0,#1
000250  f7fffffe          BL       SSD1963GPIOOUTDATA_16
;;;1514   			SSD1963GPIOOUTCOM(0xbf);
000254  20bf              MOVS     r0,#0xbf
000256  f7fffffe          BL       SSD1963GPIOOUTCOM
;;;1515   	SSD1963GPIOOUTDATA_18(0x29);	  //
00025a  2029              MOVS     r0,#0x29
00025c  f7fffffe          BL       SSD1963GPIOOUTDATA_18
;;;1516   	Delay(5);			 //delay 40ms
000260  e8bd4010          POP      {r4,lr}
000264  2005              MOVS     r0,#5
000266  f7ffbffe          B.W      Delay
;;;1517   }
;;;1518   
                          ENDP


                          AREA ||i.MTP_ID||, CODE, READONLY, ALIGN=2

                  MTP_ID PROC
;;;1666   
;;;1667   void MTP_ID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1668   {
000002  b084              SUB      sp,sp,#0x10
;;;1669   	MIPI_SPI_Write(0x05,0x39, 0xB9,0xFF,0x83,0x69);//EXTC Command Set enable register
000004  2169              MOVS     r1,#0x69
000006  2083              MOVS     r0,#0x83
000008  e9cd0100          STRD     r0,r1,[sp,#0]
00000c  23ff              MOVS     r3,#0xff
00000e  22b9              MOVS     r2,#0xb9
000010  2139              MOVS     r1,#0x39
000012  2005              MOVS     r0,#5
000014  f7fffffe          BL       MIPI_SPI_Write
;;;1670   
;;;1671   //	MIPI_SPI_Write(0x05,0x39, 0xBF,0xE0,0x00,0x00);
;;;1672   	
;;;1673   //	OPEN_OTP_Voltage;//Open 7.5V
;;;1674   	Delay(50);//Wait 500ms for PVSS stable	8369 no delay time
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       Delay
;;;1675   	
;;;1676   //	MIPI_SPI_Write(0x05,0x39, 0xB6,VCOMDC,0x28);//This command is used to set VCOM Voltage include VCOM Low and VCOM High Voltage.
;;;1677   	MIPI_SPI_Write(0x04,0x39, 0xB6,VCOMDC1,VCOMDC1);
00001e  4833              LDR      r0,|L15.236|
000020  22b6              MOVS     r2,#0xb6
000022  2139              MOVS     r1,#0x39
000024  8ac3              LDRH     r3,[r0,#0x16]  ; VCOMDC1
000026  2004              MOVS     r0,#4
000028  9300              STR      r3,[sp,#0]
00002a  f7fffffe          BL       MIPI_SPI_Write
;;;1678   	
;;;1679   	MIPI_SPI_Write(0x05,0x39, 0xE9,0xAA,0x55);// This command is used to set OTP key to enter or leave OTP program mode.
00002e  2055              MOVS     r0,#0x55
000030  9000              STR      r0,[sp,#0]
000032  23aa              MOVS     r3,#0xaa
000034  22e9              MOVS     r2,#0xe9
000036  2139              MOVS     r1,#0x39
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       MIPI_SPI_Write
;;;1680   	Delay(50);//Wait 500ms for PVSS stable 8369 no delay time
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       Delay
;;;1681   
;;;1682   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x00);
000044  2400              MOVS     r4,#0
000046  251c              MOVS     r5,#0x1c
000048  e9cd4500          STRD     r4,r5,[sp,#0]
00004c  4623              MOV      r3,r4
00004e  22bb              MOVS     r2,#0xbb
000050  2139              MOVS     r1,#0x39
000052  2006              MOVS     r0,#6
000054  9402              STR      r4,[sp,#8]
000056  f7fffffe          BL       MIPI_SPI_Write
;;;1683   
;;;1684   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x01);
00005a  2601              MOVS     r6,#1
00005c  2300              MOVS     r3,#0
00005e  22bb              MOVS     r2,#0xbb
000060  2139              MOVS     r1,#0x39
000062  2006              MOVS     r0,#6
000064  9602              STR      r6,[sp,#8]
000066  e9cd4500          STRD     r4,r5,[sp,#0]
00006a  f7fffffe          BL       MIPI_SPI_Write
;;;1685   	Delay(5);
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       Delay
000074  e9cd4500          STRD     r4,r5,[sp,#0]
;;;1686   
;;;1687   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1C,0x00);
000078  2300              MOVS     r3,#0
00007a  22bb              MOVS     r2,#0xbb
00007c  2139              MOVS     r1,#0x39
00007e  2006              MOVS     r0,#6
000080  9402              STR      r4,[sp,#8]
000082  f7fffffe          BL       MIPI_SPI_Write
;;;1688   	Delay(5);
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       Delay
;;;1689   
;;;1690   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x00);
00008c  251d              MOVS     r5,#0x1d
00008e  e9cd4500          STRD     r4,r5,[sp,#0]
000092  2300              MOVS     r3,#0
000094  22bb              MOVS     r2,#0xbb
000096  2139              MOVS     r1,#0x39
000098  2006              MOVS     r0,#6
00009a  9402              STR      r4,[sp,#8]
00009c  f7fffffe          BL       MIPI_SPI_Write
;;;1691   	Delay(5);
0000a0  2005              MOVS     r0,#5
0000a2  f7fffffe          BL       Delay
;;;1692   
;;;1693   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x01);
0000a6  2300              MOVS     r3,#0
0000a8  22bb              MOVS     r2,#0xbb
0000aa  2139              MOVS     r1,#0x39
0000ac  2006              MOVS     r0,#6
0000ae  9602              STR      r6,[sp,#8]
0000b0  e9cd4500          STRD     r4,r5,[sp,#0]
0000b4  f7fffffe          BL       MIPI_SPI_Write
;;;1694   	Delay(5);
0000b8  2005              MOVS     r0,#5
0000ba  f7fffffe          BL       Delay
0000be  e9cd4500          STRD     r4,r5,[sp,#0]
;;;1695   
;;;1696   	MIPI_SPI_Write(0x06,0x39, 0xBB,0x00,0x00,0x1D,0x00);
0000c2  2300              MOVS     r3,#0
0000c4  22bb              MOVS     r2,#0xbb
0000c6  2139              MOVS     r1,#0x39
0000c8  2006              MOVS     r0,#6
0000ca  9402              STR      r4,[sp,#8]
0000cc  f7fffffe          BL       MIPI_SPI_Write
;;;1697   	Delay(5);
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       Delay
;;;1698   
;;;1699   	initial_OTP();
0000d6  f7fffffe          BL       initial_OTP
;;;1700   
;;;1701   	MIPI_SPI_Write(0x06,0x39, 0xE9,0x00,0x00);//set OTP off
0000da  2300              MOVS     r3,#0
0000dc  22e9              MOVS     r2,#0xe9
0000de  2139              MOVS     r1,#0x39
0000e0  2006              MOVS     r0,#6
0000e2  9400              STR      r4,[sp,#0]
0000e4  f7fffffe          BL       MIPI_SPI_Write
;;;1702   
;;;1703   //	CLOSE_OTP_Voltage;//Close 7.5V 
;;;1704   //	Delay(10);//Wait 10ms	8369 no delay time
;;;1705   //	
;;;1706   //	SSD1963Command_8(0xBa); 
;;;1707   //	SSD1963Data_8(0x0E);   //RESET=0
;;;1708   //	Delay(12);
;;;1709   //	SSD1963Command_8(0xBa); 
;;;1710   //	SSD1963Data_8(0x0F);   //RESET=1 
;;;1711   //	Delay(12);
;;;1712   //	
;;;1713   //	SSD1963INITSSD2825();
;;;1714   //	OTP_initial();//GPI009A0 (HX8369-A01) initial code
;;;1715   	
;;;1716   	
;;;1717   }
0000e8  b004              ADD      sp,sp,#0x10
0000ea  bd70              POP      {r4-r6,pc}
;;;1718   
                          ENDP

                  |L15.236|
                          DCD      ||.data||

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;911    *******************************************************************************/
;;;912    void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;913    {
;;;914    //------------zp2000--------------------------------
;;;915      NVIC_InitTypeDef NVIC_InitStructure;
;;;916    
;;;917      /* Configure the NVIC Preemption Priority Bits */
;;;918      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);//该函数调用了两次
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;919    
;;;920      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQChannel;
00000a  2031              MOVS     r0,#0x31
00000c  f88d0000          STRB     r0,[sp,#0]
;;;921      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2400              MOVS     r4,#0
000012  f88d4001          STRB     r4,[sp,#1]
;;;922      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  f88d4002          STRB     r4,[sp,#2]
;;;923      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2501              MOVS     r5,#1
00001c  f88d5003          STRB     r5,[sp,#3]
;;;924      NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;925    
;;;926      /* Enable the RTC Interrupt */
;;;927      NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
000026  2003              MOVS     r0,#3
000028  f88d0000          STRB     r0,[sp,#0]
;;;928      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002c  f88d5001          STRB     r5,[sp,#1]
;;;929      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000030  f88d4002          STRB     r4,[sp,#2]
;;;930      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000034  f88d5003          STRB     r5,[sp,#3]
;;;931      NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;932    
;;;933    #ifdef  VECT_TAB_RAM  
;;;934      /* Set the Vector Table base location at 0x20000000 */ 
;;;935      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;936    #else  /* VECT_TAB_FLASH  */
;;;937      /* Set the Vector Table base location at 0x08000000 */ 
;;;938      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
00003e  2100              MOVS     r1,#0
000040  06e8              LSLS     r0,r5,#27
000042  f7fffffe          BL       NVIC_SetVectorTable
;;;939    #endif
;;;940    
;;;941    }
000046  bd38              POP      {r3-r5,pc}
;;;942    
                          ENDP


                          AREA ||i.OTP_ERROR||, CODE, READONLY, ALIGN=2

                  OTP_ERROR PROC
;;;488    
;;;489    void OTP_ERROR(void)
000000  4c0b              LDR      r4,|L17.48|
;;;490    {
;;;491    		
;;;492    	FontR = 50; FontG = 255; FontB = 50;
000002  4e0c              LDR      r6,|L17.52|
000004  2032              MOVS     r0,#0x32
000006  4f0c              LDR      r7,|L17.56|
000008  7020              STRB     r0,[r4,#0]
00000a  25ff              MOVS     r5,#0xff
00000c  7035              STRB     r5,[r6,#0]
00000e  7038              STRB     r0,[r7,#0]
;;;493    	LCD_DisplayStringLine(20,100,"Flicker OTP NG");		
000010  a20a              ADR      r2,|L17.60|
000012  2164              MOVS     r1,#0x64
000014  2014              MOVS     r0,#0x14
000016  f7fffffe          BL       LCD_DisplayStringLine
;;;494    	FontR = 255; FontG = 0; FontB = 0;
00001a  7025              STRB     r5,[r4,#0]
00001c  2000              MOVS     r0,#0
00001e  7030              STRB     r0,[r6,#0]
000020  7038              STRB     r0,[r7,#0]
;;;495    	LCD_DisplayStringLine(20,130,"Reset do flicker OTP again!"); //	DelayKEY(100);
000022  a20a              ADR      r2,|L17.76|
000024  2182              MOVS     r1,#0x82
000026  2014              MOVS     r0,#0x14
000028  f7fffffe          BL       LCD_DisplayStringLine
                  |L17.44|
;;;496    	while(1);
00002c  e7fe              B        |L17.44|
;;;497    }
;;;498    
                          ENDP

00002e  0000              DCW      0x0000
                  |L17.48|
                          DCD      FontR
                  |L17.52|
                          DCD      FontG
                  |L17.56|
                          DCD      FontB
                  |L17.60|
00003c  466c6963          DCB      "Flicker OTP NG",0
000040  6b657220
000044  4f545020
000048  4e4700  
00004b  00                DCB      0
                  |L17.76|
00004c  52657365          DCB      "Reset do flicker OTP again!",0
000050  7420646f
000054  20666c69
000058  636b6572
00005c  204f5450
000060  20616761
000064  696e2100

                          AREA ||i.OTP_NO||, CODE, READONLY, ALIGN=2

                  OTP_NO PROC
;;;498    
;;;499    void OTP_NO(void)
000000  4e0e              LDR      r6,|L18.60|
;;;500    {
;;;501    	while(1)
;;;502    	{
;;;503    		
;;;504    		LCD_DisplayStringLine_A(10,700,"OTP");
;;;505    		FontR = 255; FontG = FontB = 0;
000002  4d0f              LDR      r5,|L18.64|
000004  4f0f              LDR      r7,|L18.68|
000006  2400              MOVS     r4,#0                 ;500
000008  f04f08ff          MOV      r8,#0xff
                  |L18.12|
00000c  a20e              ADR      r2,|L18.72|
00000e  f44f712f          MOV      r1,#0x2bc             ;504
000012  200a              MOVS     r0,#0xa               ;504
000014  f7fffffe          BL       LCD_DisplayStringLine_A
000018  f8868000          STRB     r8,[r6,#0]
00001c  702c              STRB     r4,[r5,#0]
00001e  703c              STRB     r4,[r7,#0]
;;;506    		LCD_DisplayStringLine_A(160,700,"NO");
000020  a20a              ADR      r2,|L18.76|
000022  f44f712f          MOV      r1,#0x2bc
000026  20a0              MOVS     r0,#0xa0
000028  f7fffffe          BL       LCD_DisplayStringLine_A
;;;507    		Delay(100);
00002c  2064              MOVS     r0,#0x64
00002e  f7fffffe          BL       Delay
;;;508    		FontR = FontG = FontB = 0;	
000032  702c              STRB     r4,[r5,#0]
000034  703c              STRB     r4,[r7,#0]
000036  7034              STRB     r4,[r6,#0]
000038  e7e8              B        |L18.12|
;;;509    	}
;;;510    }
;;;511    
                          ENDP

00003a  0000              DCW      0x0000
                  |L18.60|
                          DCD      FontR
                  |L18.64|
                          DCD      FontB
                  |L18.68|
                          DCD      FontG
                  |L18.72|
000048  4f545000          DCB      "OTP",0
                  |L18.76|
00004c  4e4f00            DCB      "NO",0
00004f  00                DCB      0

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;853    *******************************************************************************/
;;;854    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;855    {   
;;;856      /* RCC system reset(for debug purpose) */
;;;857      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;858    
;;;859      /* Enable HSE */
;;;860      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;861    
;;;862      /* Wait till HSE is ready */
;;;863      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4918              LDR      r1,|L19.116|
;;;864    
;;;865      if(HSEStartUpStatus == SUCCESS)
000014  2801              CMP      r0,#1
000016  7348              STRB     r0,[r1,#0xd]          ;863
000018  d124              BNE      |L19.100|
;;;866      {
;;;867        /* Enable Prefetch Buffer */
;;;868        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;869    
;;;870        /* Flash 2 wait state */
;;;871        FLASH_SetLatency(FLASH_Latency_2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
;;;872     	
;;;873        /* HCLK = SYSCLK */
;;;874        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
;;;875      
;;;876        /* PCLK2 = HCLK */
;;;877        RCC_PCLK2Config(RCC_HCLK_Div1); 
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
;;;878    
;;;879        /* PCLK1 = HCLK/2 */
;;;880        RCC_PCLK1Config(RCC_HCLK_Div2);
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
;;;881    
;;;882        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;883        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
;;;884    
;;;885        /* Enable PLL */ 
;;;886        RCC_PLLCmd(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L19.76|
;;;887    
;;;888        /* Wait till PLL is ready */
;;;889        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L19.76|
;;;890        {
;;;891        }
;;;892    
;;;893        /* Select PLL as system clock source */
;;;894        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L19.92|
;;;895    
;;;896        /* Wait till PLL is used as system clock source */
;;;897        while(RCC_GetSYSCLKSource() != 0x08)
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L19.92|
                  |L19.100|
;;;898        {
;;;899        }
;;;900      }
;;;901      /* Enable USART1 and GPIOA clock */
;;;902      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
000064  e8bd4010          POP      {r4,lr}
000068  2101              MOVS     r1,#1
00006a  f2440004          MOV      r0,#0x4004
00006e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;903    }
;;;904    
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      ||.data||

                          AREA ||i.READ_SSD2825||, CODE, READONLY, ALIGN=2

                  READ_SSD2825 PROC
;;;527    
;;;528    void READ_SSD2825(u8 cmd)
000000  b500              PUSH     {lr}
;;;529    {
000002  b083              SUB      sp,sp,#0xc
;;;530    	u16 R_data=0;
;;;531    	u32 sdcap=0;
;;;532    	u8 TCH[6];
;;;533    
;;;534    	R_data = SSD2825_READ(cmd);
000004  f7fffffe          BL       SSD2825_READ
;;;535    
;;;536    
;;;537    	sdcap=R_data;
;;;538    	   TCH[5]=0;
000008  2100              MOVS     r1,#0
;;;539    	   TCH[4]=(sdcap%10+0x30);sdcap/=10;
00000a  4b22              LDR      r3,|L20.148|
00000c  f88d1005          STRB     r1,[sp,#5]            ;538
000010  fba32100          UMULL    r2,r1,r3,r0
000014  08c9              LSRS     r1,r1,#3
000016  424a              RSBS     r2,r1,#0
000018  eb020282          ADD      r2,r2,r2,LSL #2
00001c  eb000042          ADD      r0,r0,r2,LSL #1
000020  3030              ADDS     r0,r0,#0x30
000022  f88d0004          STRB     r0,[sp,#4]
;;;540    	   TCH[3]=(sdcap%10+0x30);sdcap/=10;
000026  fba32001          UMULL    r2,r0,r3,r1
00002a  08c2              LSRS     r2,r0,#3
00002c  4250              RSBS     r0,r2,#0
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  eb010040          ADD      r0,r1,r0,LSL #1
000036  3030              ADDS     r0,r0,#0x30
000038  f88d0003          STRB     r0,[sp,#3]
;;;541    	   TCH[2]=(sdcap%10+0x30);sdcap/=10;
00003c  fba31002          UMULL    r1,r0,r3,r2
000040  08c0              LSRS     r0,r0,#3
000042  4241              RSBS     r1,r0,#0
000044  eb010181          ADD      r1,r1,r1,LSL #2
000048  eb020141          ADD      r1,r2,r1,LSL #1
00004c  3130              ADDS     r1,r1,#0x30
00004e  f88d1002          STRB     r1,[sp,#2]
;;;542    	   TCH[1]=(sdcap%10+0x30);sdcap/=10;
000052  fba32100          UMULL    r2,r1,r3,r0
000056  08c9              LSRS     r1,r1,#3
000058  424a              RSBS     r2,r1,#0
00005a  eb020282          ADD      r2,r2,r2,LSL #2
00005e  eb000042          ADD      r0,r0,r2,LSL #1
000062  3030              ADDS     r0,r0,#0x30
000064  f88d0001          STRB     r0,[sp,#1]
;;;543    	   TCH[0]=(sdcap%10+0x30);
000068  fba32001          UMULL    r2,r0,r3,r1
00006c  08c0              LSRS     r0,r0,#3
00006e  4240              RSBS     r0,r0,#0
000070  eb000080          ADD      r0,r0,r0,LSL #2
000074  eb010040          ADD      r0,r1,r0,LSL #1
000078  3030              ADDS     r0,r0,#0x30
00007a  f88d0000          STRB     r0,[sp,#0]
;;;544    	    
;;;545    	   LCD_DisplayStringLine(95,40,TCH);
00007e  466a              MOV      r2,sp
000080  2128              MOVS     r1,#0x28
000082  205f              MOVS     r0,#0x5f
000084  f7fffffe          BL       LCD_DisplayStringLine
;;;546    	   DelayKEY(30);
000088  201e              MOVS     r0,#0x1e
00008a  f7fffffe          BL       DelayKEY
;;;547    }
00008e  b003              ADD      sp,sp,#0xc
000090  bd00              POP      {pc}
;;;548    
                          ENDP

000092  0000              DCW      0x0000
                  |L20.148|
                          DCD      0xcccccccd

                          AREA ||i.SDPicShow||, CODE, READONLY, ALIGN=2

                  SDPicShow PROC
;;;549    
;;;550    void SDPicShow(u8 pic)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;551    {
;;;552    	u8 k;
;;;553    	k = 0;
;;;554    		SDShowFlag = 1;
000004  4f0f              LDR      r7,|L21.68|
000006  4605              MOV      r5,r0                 ;551
000008  2001              MOVS     r0,#1
;;;555    		SDShowTimes = 1;
;;;556    
;;;557    		image_count = pic;
00000a  4e0f              LDR      r6,|L21.72|
00000c  70b8              STRB     r0,[r7,#2]            ;554
00000e  70f8              STRB     r0,[r7,#3]            ;555
000010  2400              MOVS     r4,#0                 ;553
000012  8035              STRH     r5,[r6,#0]
                  |L21.20|
;;;558    
;;;559    		while(SDShowFlag) 
;;;560    	{	  
;;;561    	  Disp_BMP() ;
000014  f7fffffe          BL       Disp_BMP
;;;562    	  DelayKEY(1);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       DelayKEY
;;;563    
;;;564       		if((image_count >= pic)&&(k <= 1))
00001e  8830              LDRH     r0,[r6,#0]  ; image_count
000020  4285              CMP      r5,r0
000022  bf98              IT       LS
000024  2c01              CMPLS    r4,#1
000026  d802              BHI      |L21.46|
;;;565    		{
;;;566    			image_count = pic;
;;;567    			k++;
000028  1c60              ADDS     r0,r4,#1
00002a  8035              STRH     r5,[r6,#0]            ;566
00002c  b2c4              UXTB     r4,r0
                  |L21.46|
;;;568    		}
;;;569    
;;;570    			  //此段为了使用SD卡的指定图片调用；；
;;;571    		if(k >= 1)
00002e  b11c              CBZ      r4,|L21.56|
;;;572    		{
;;;573    			SDShowFlag=0;	
000030  2000              MOVS     r0,#0
000032  70b8              STRB     r0,[r7,#2]
;;;574    		} 
;;;575    
;;;576    	}
;;;577    
;;;578    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L21.56|
000038  78b8              LDRB     r0,[r7,#2]            ;559  ; SDShowFlag
00003a  2800              CMP      r0,#0                 ;559
00003c  d1ea              BNE      |L21.20|
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;579    
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
                          DCD      ||.data||
                  |L21.72|
                          DCD      image_count

                          AREA ||i.SD_InitAndConfig||, CODE, READONLY, ALIGN=2

                  SD_InitAndConfig PROC
;;;1137   /* Private functions ---------------------------------------------------------*/
;;;1138   SD_Error SD_InitAndConfig(void)
000000  b510              PUSH     {r4,lr}
;;;1139   {
;;;1140     Status = SD_Init();
000002  f7fffffe          BL       SD_Init
000006  4c10              LDR      r4,|L22.72|
;;;1141   
;;;1142     if (Status == SD_OK)
000008  282a              CMP      r0,#0x2a
00000a  7020              STRB     r0,[r4,#0]            ;1140
00000c  d119              BNE      |L22.66|
;;;1143     {
;;;1144       /*----------------- Read CSD/CID MSD registers ------------------*/
;;;1145       Status = SD_GetCardInfo(&SDCardInfo);
00000e  480f              LDR      r0,|L22.76|
000010  f7fffffe          BL       SD_GetCardInfo
000014  7020              STRB     r0,[r4,#0]
;;;1146     }
;;;1147     
;;;1148     if (Status == SD_OK)
000016  282a              CMP      r0,#0x2a
000018  d113              BNE      |L22.66|
;;;1149     {
;;;1150       /*----------------- Select Card --------------------------------*/
;;;1151       Status = SD_SelectDeselect((u32) (SDCardInfo.RCA << 16));
00001a  480c              LDR      r0,|L22.76|
00001c  f8b0004c          LDRH     r0,[r0,#0x4c]  ; SDCardInfo
000020  0400              LSLS     r0,r0,#16
000022  f7fffffe          BL       SD_SelectDeselect
000026  7020              STRB     r0,[r4,#0]
;;;1152     }
;;;1153     
;;;1154     if (Status == SD_OK)
000028  282a              CMP      r0,#0x2a
00002a  d10a              BNE      |L22.66|
;;;1155     {
;;;1156       /*----------------- Set BusWidth ------------------------------*/
;;;1157       Status = SD_EnableWideBusOperation(SDIO_BusWide_4b);
00002c  f44f6000          MOV      r0,#0x800
000030  f7fffffe          BL       SD_EnableWideBusOperation
000034  7020              STRB     r0,[r4,#0]
;;;1158     }
;;;1159     
;;;1160     /* Set Device Transfer Mode to INTERRUPT to DMA */
;;;1161     if (Status == SD_OK)
000036  282a              CMP      r0,#0x2a
000038  d103              BNE      |L22.66|
;;;1162     {  
;;;1163       Status = SD_SetDeviceMode(SD_DMA_MODE);//SD_DMA_MODE,SD_INTERRUPT_MODE
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       SD_SetDeviceMode
000040  7020              STRB     r0,[r4,#0]
                  |L22.66|
;;;1164     }
;;;1165     return Status;
000042  b2c0              UXTB     r0,r0
;;;1166   }
000044  bd10              POP      {r4,pc}
;;;1167   
                          ENDP

000046  0000              DCW      0x0000
                  |L22.72|
                          DCD      ||.data||
                  |L22.76|
                          DCD      ||.bss||+0xc

                          AREA ||i.SENSOR_Check||, CODE, READONLY, ALIGN=2

                  SENSOR_Check PROC
;;;1190   
;;;1191   void SENSOR_Check(u8 Device_N)
000000  b510              PUSH     {r4,lr}
;;;1192   {
000002  4604              MOV      r4,r0
;;;1193   	u16 temp1 =0;
;;;1194   //	temp1 = I2C_READ_BYTE(Device_N,0x9e);  /////ADC channel 0 data0low
;;;1195   	temp1 = sensor_check(Device_N);
000004  f7fffffe          BL       sensor_check
;;;1196   	if(temp1 == 0)	  
000008  2800              CMP      r0,#0
;;;1197   	{	
;;;1198   //		Delay(1);	
;;;1199   		;
;;;1200   	}
;;;1201   //	else if	(temp1 == 0)	 	
;;;1202   //	{
;;;1203   //		;	
;;;1204   ////		Delay(1);	
;;;1205   //	}
;;;1206   	else
;;;1207   	{
;;;1208   		while(1)
;;;1209   		{
;;;1210   			if(Device_N == S3_addr)	  {		LCD_DisplayStringLine(100,80,"S3");		}
;;;1211   			if(Device_N == S2_addr)	  {		LCD_DisplayStringLine(140,80,"S2");		}
;;;1212   			if(Device_N == S1_addr)	  {		LCD_DisplayStringLine(180,80,"S1");		}
;;;1213   
;;;1214   			LCD_DisplayStringLine(20,50,"sensor  error");		//红色高亮显示sensor error，警示光感失灵，暂停在此处。
;;;1215   			while(1);
;;;1216   		}
;;;1217   	}	
;;;1218   }
00000a  bf08              IT       EQ
00000c  bd10              POPEQ    {r4,pc}
00000e  2c52              CMP      r4,#0x52              ;1210
000010  d004              BEQ      |L23.28|
000012  2c72              CMP      r4,#0x72              ;1211
000014  d006              BEQ      |L23.36|
000016  2c92              CMP      r4,#0x92              ;1212
000018  d00a              BEQ      |L23.48|
00001a  e00e              B        |L23.58|
                  |L23.28|
00001c  2150              MOVS     r1,#0x50              ;1210
00001e  a20a              ADR      r2,|L23.72|
000020  2064              MOVS     r0,#0x64              ;1210
000022  e002              B        |L23.42|
                  |L23.36|
000024  a209              ADR      r2,|L23.76|
000026  2150              MOVS     r1,#0x50              ;1211
000028  208c              MOVS     r0,#0x8c              ;1211
                  |L23.42|
00002a  f7fffffe          BL       LCD_DisplayStringLine
00002e  e004              B        |L23.58|
                  |L23.48|
000030  a207              ADR      r2,|L23.80|
000032  2150              MOVS     r1,#0x50              ;1212
000034  20b4              MOVS     r0,#0xb4              ;1212
000036  f7fffffe          BL       LCD_DisplayStringLine
                  |L23.58|
00003a  a206              ADR      r2,|L23.84|
00003c  2132              MOVS     r1,#0x32              ;1214
00003e  2014              MOVS     r0,#0x14              ;1214
000040  f7fffffe          BL       LCD_DisplayStringLine
                  |L23.68|
000044  e7fe              B        |L23.68|
;;;1219   
                          ENDP

000046  0000              DCW      0x0000
                  |L23.72|
000048  533300            DCB      "S3",0
00004b  00                DCB      0
                  |L23.76|
00004c  533200            DCB      "S2",0
00004f  00                DCB      0
                  |L23.80|
000050  533100            DCB      "S1",0
000053  00                DCB      0
                  |L23.84|
000054  73656e73          DCB      "sensor  error",0
000058  6f722020
00005c  6572726f
000060  7200    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.SHOW_IC_VALUE||, CODE, READONLY, ALIGN=2

                  SHOW_IC_VALUE PROC
;;;580    
;;;581    void SHOW_IC_VALUE(u16 adx,u16 ady,u32 cmd)
000000  b510              PUSH     {r4,lr}
;;;582    {
000002  b082              SUB      sp,sp,#8
;;;583    	
;;;584    //	u16 R_data=0;
;;;585    	u32 sdcap=0;
;;;586    	u8 TCH[7];
;;;587    
;;;588    	sdcap=cmd;
;;;589    	if(sdcap == 0x55)
000004  2a55              CMP      r2,#0x55
;;;590    	{	LCD_DisplayStringLine(adx,ady,"0x55");	}	 			//ID1 = 0X55
000006  bf08              IT       EQ
000008  a227              ADREQ    r2,|L24.168|
00000a  d049              BEQ      |L24.160|
;;;591    	else if(sdcap == 0x44)
00000c  2a44              CMP      r2,#0x44
;;;592    	{	LCD_DisplayStringLine(adx,ady,"0x44");	}			    //ID2 = 0X44
00000e  bf08              IT       EQ
000010  a227              ADREQ    r2,|L24.176|
000012  d045              BEQ      |L24.160|
;;;593    	else if(sdcap == 0xF0)
000014  2af0              CMP      r2,#0xf0
;;;594    	{	LCD_DisplayStringLine(adx,ady,"0xF0");	}			    //ID3 = 0XF0
000016  bf08              IT       EQ
000018  a227              ADREQ    r2,|L24.184|
00001a  d041              BEQ      |L24.160|
;;;595    	else
;;;596    	{
;;;597    	   TCH[6]=0;
00001c  2300              MOVS     r3,#0
00001e  f88d3006          STRB     r3,[sp,#6]
;;;598    	   TCH[5]=0;
;;;599    	   TCH[4]=(sdcap%10+0x30);sdcap/=10;
000022  4c27              LDR      r4,|L24.192|
000024  f88d3005          STRB     r3,[sp,#5]            ;598
000028  fba4c302          UMULL    r12,r3,r4,r2
00002c  08db              LSRS     r3,r3,#3
00002e  f1c30c00          RSB      r12,r3,#0
000032  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000036  eb02024c          ADD      r2,r2,r12,LSL #1
00003a  3230              ADDS     r2,r2,#0x30
00003c  f88d2004          STRB     r2,[sp,#4]
;;;600    	   TCH[3]=(sdcap%10+0x30);sdcap/=10;
000040  fba4c203          UMULL    r12,r2,r4,r3
000044  ea4f0cd2          LSR      r12,r2,#3
000048  f1cc0200          RSB      r2,r12,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb030242          ADD      r2,r3,r2,LSL #1
000054  3230              ADDS     r2,r2,#0x30
000056  f88d2003          STRB     r2,[sp,#3]
;;;601    	   TCH[2]=(sdcap%10+0x30);sdcap/=10;
00005a  fba4320c          UMULL    r3,r2,r4,r12
00005e  08d2              LSRS     r2,r2,#3
000060  4253              RSBS     r3,r2,#0
000062  eb030383          ADD      r3,r3,r3,LSL #2
000066  eb0c0343          ADD      r3,r12,r3,LSL #1
00006a  3330              ADDS     r3,r3,#0x30
00006c  f88d3002          STRB     r3,[sp,#2]
;;;602    	   TCH[1]=(sdcap%10+0x30);sdcap/=10;
000070  fba4c302          UMULL    r12,r3,r4,r2
000074  08db              LSRS     r3,r3,#3
000076  f1c30c00          RSB      r12,r3,#0
00007a  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00007e  eb02024c          ADD      r2,r2,r12,LSL #1
000082  3230              ADDS     r2,r2,#0x30
000084  f88d2001          STRB     r2,[sp,#1]
;;;603    	   TCH[0]=(sdcap%10+0x30);
000088  fba4c203          UMULL    r12,r2,r4,r3
00008c  08d2              LSRS     r2,r2,#3
00008e  4252              RSBS     r2,r2,#0
000090  eb020282          ADD      r2,r2,r2,LSL #2
000094  eb030242          ADD      r2,r3,r2,LSL #1
000098  3230              ADDS     r2,r2,#0x30
00009a  f88d2000          STRB     r2,[sp,#0]
;;;604    	    
;;;605    	   LCD_DisplayStringLine(adx,ady,TCH);
00009e  466a              MOV      r2,sp
                  |L24.160|
0000a0  f7fffffe          BL       LCD_DisplayStringLine
;;;606    	}
;;;607    }
0000a4  b002              ADD      sp,sp,#8
0000a6  bd10              POP      {r4,pc}
;;;608    
                          ENDP

                  |L24.168|
0000a8  30783535          DCB      "0x55",0
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L24.176|
0000b0  30783434          DCB      "0x44",0
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L24.184|
0000b8  30784630          DCB      "0xF0",0
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L24.192|
                          DCD      0xcccccccd

                          AREA ||i.SHOW_IC_VALUE_A||, CODE, READONLY, ALIGN=2

                  SHOW_IC_VALUE_A PROC
;;;608    
;;;609    void SHOW_IC_VALUE_A(u16 adx,u16 n,u8 data)           //被调函数要在调用函数之前！
000000  b570              PUSH     {r4-r6,lr}
;;;610    {
;;;611        u8 table[17]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','\0'};
000002  a312              ADR      r3,|L25.76|
000004  b088              SUB      sp,sp,#0x20           ;610
000006  e8931070          LDM      r3,{r4-r6,r12}
00000a  e88d1070          STM      sp,{r4-r6,r12}
00000e  691b              LDR      r3,[r3,#0x10]
;;;612        u8 value[5]={0};
000010  9304              STR      r3,[sp,#0x10]
000012  2300              MOVS     r3,#0
000014  9305              STR      r3,[sp,#0x14]
;;;613        u16 temp;  
;;;614        
;;;615    //    temp=data>>12;
;;;616    //    temp=temp&0x0f;
;;;617    //    value[0]=table[temp];
;;;618    //    temp=data>>8;
;;;619    //    temp=temp&0x0f;
;;;620    //    value[1]=table[temp];			 ///屏蔽掉的代a16位字符@示
;;;621        value[0]=0x30;	//////底0
000016  9306              STR      r3,[sp,#0x18]
000018  2330              MOVS     r3,#0x30
00001a  f88d3014          STRB     r3,[sp,#0x14]
;;;622    	value[1]=0x78;	//////小x		 ///定值8位字符@示的0x
00001e  2378              MOVS     r3,#0x78
000020  f88d3015          STRB     r3,[sp,#0x15]
;;;623    	temp=data>>4;
000024  0913              LSRS     r3,r2,#4
;;;624        temp=temp&0x0f;
;;;625        value[2]=table[temp];
;;;626        temp=data;
;;;627        temp=temp&0x0f;
000026  f002020f          AND      r2,r2,#0xf
00002a  f81d3003          LDRB     r3,[sp,r3]            ;625
00002e  f88d3016          STRB     r3,[sp,#0x16]         ;625
;;;628        value[3]=table[temp];
000032  f81d2002          LDRB     r2,[sp,r2]
000036  f88d2017          STRB     r2,[sp,#0x17]
;;;629        value[4]=table[16];
00003a  f89d2010          LDRB     r2,[sp,#0x10]
00003e  f88d2018          STRB     r2,[sp,#0x18]
;;;630    
;;;631        LCD_DisplayStringLine(adx,n,value);
000042  aa05              ADD      r2,sp,#0x14
000044  f7fffffe          BL       LCD_DisplayStringLine
;;;632    }
000048  b008              ADD      sp,sp,#0x20
00004a  bd70              POP      {r4-r6,pc}
;;;633    
                          ENDP

                  |L25.76|
00004c  30313233          DCB      "0123456789ABCDEF",0
000050  34353637
000054  38394142
000058  43444546
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.SHOW_value||, CODE, READONLY, ALIGN=2

                  SHOW_value PROC
;;;511    
;;;512    void SHOW_value(u16 addx,u16 addy,u32 Data)
000000  b510              PUSH     {r4,lr}
;;;513    {
000002  b082              SUB      sp,sp,#8
;;;514    	u32 sdcap;
;;;515    	u8 TCH[7];
;;;516    
;;;517    	sdcap = Data;
;;;518    	TCH[4]=0;
000004  2300              MOVS     r3,#0
;;;519    	TCH[3]=(sdcap%10+0x30);sdcap/=10;
000006  4c1b              LDR      r4,|L26.116|
000008  f88d3004          STRB     r3,[sp,#4]            ;518
00000c  fba4c302          UMULL    r12,r3,r4,r2
000010  08db              LSRS     r3,r3,#3
000012  f1c30c00          RSB      r12,r3,#0
000016  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00001a  eb02024c          ADD      r2,r2,r12,LSL #1
00001e  3230              ADDS     r2,r2,#0x30
000020  f88d2003          STRB     r2,[sp,#3]
;;;520    	TCH[2]=(sdcap%10+0x30);sdcap/=10;
000024  fba4c203          UMULL    r12,r2,r4,r3
000028  08d2              LSRS     r2,r2,#3
00002a  f1c20c00          RSB      r12,r2,#0
00002e  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000032  eb03034c          ADD      r3,r3,r12,LSL #1
000036  3330              ADDS     r3,r3,#0x30
000038  f88d3002          STRB     r3,[sp,#2]
;;;521    	TCH[1]=(sdcap%10+0x30);sdcap/=10;
00003c  fba4c302          UMULL    r12,r3,r4,r2
000040  08db              LSRS     r3,r3,#3
000042  f1c30c00          RSB      r12,r3,#0
000046  eb0c0c8c          ADD      r12,r12,r12,LSL #2
00004a  eb02024c          ADD      r2,r2,r12,LSL #1
00004e  3230              ADDS     r2,r2,#0x30
000050  f88d2001          STRB     r2,[sp,#1]
;;;522    	TCH[0]=(sdcap%10+0x30);
000054  fba4c203          UMULL    r12,r2,r4,r3
000058  08d2              LSRS     r2,r2,#3
00005a  4252              RSBS     r2,r2,#0
00005c  eb020282          ADD      r2,r2,r2,LSL #2
000060  eb030242          ADD      r2,r3,r2,LSL #1
000064  3230              ADDS     r2,r2,#0x30
000066  f88d2000          STRB     r2,[sp,#0]
;;;523    
;;;524    	LCD_DisplayStringLine(addx,addy,TCH);
00006a  466a              MOV      r2,sp
00006c  f7fffffe          BL       LCD_DisplayStringLine
;;;525    
;;;526    }
000070  b002              ADD      sp,sp,#8
000072  bd10              POP      {r4,pc}
;;;527    
                          ENDP

                  |L26.116|
                          DCD      0xcccccccd

                          AREA ||i.SysTick_Config||, CODE, READONLY, ALIGN=2

                  SysTick_Config PROC
;;;1016   *******************************************************************************/
;;;1017   void SysTick_Config(void)
000000  b510              PUSH     {r4,lr}
;;;1018   {
;;;1019     /* Configure HCLK clock as SysTick clock source */
;;;1020     SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;1021    
;;;1022     /* SysTick interrupt each 100 Hz with HCLK equal to 72MHz */
;;;1023     SysTick_SetReload(72000);
000008  4805              LDR      r0,|L27.32|
00000a  f7fffffe          BL       SysTick_SetReload
;;;1024   
;;;1025     /* Enable the SysTick Interrupt */
;;;1026     SysTick_ITConfig(DISABLE);//ENABLE DISABLE
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       SysTick_ITConfig
;;;1027   
;;;1028     /* Enable the SysTick Counter */
;;;1029     SysTick_CounterCmd(SysTick_Counter_Enable);
000014  e8bd4010          POP      {r4,lr}
000018  2001              MOVS     r0,#1
00001a  f7ffbffe          B.W      SysTick_CounterCmd
;;;1030   }
;;;1031   //----设定按键接口--------------
                          ENDP

00001e  0000              DCW      0x0000
                  |L27.32|
                          DCD      0x00011940

                          AREA ||i.USART1GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  USART1GPIO_Configuration PROC
;;;1119   *******************************************************************************/
;;;1120   void USART1GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1121   {
;;;1122     GPIO_InitTypeDef GPIO_InitStructure;
;;;1123   
;;;1124     /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;1125     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;1126     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;1127     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
;;;1128     GPIO_Init(GPIOA, &GPIO_InitStructure);
000012  4c09              LDR      r4,|L28.56|
000014  f88d0002          STRB     r0,[sp,#2]            ;1127
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       GPIO_Init
;;;1129       
;;;1130     /* Configure USART1 Rx (PA.10) as input floating */
;;;1131     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000020  1521              ASRS     r1,r4,#20
000022  f8ad1000          STRH     r1,[sp,#0]
;;;1132     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2104              MOVS     r1,#4
000028  f88d1003          STRB     r1,[sp,#3]
;;;1133     GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;1134   }
000034  bd38              POP      {r3-r5,pc}
;;;1135   
                          ENDP

000036  0000              DCW      0x0000
                  |L28.56|
                          DCD      0x40010800

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;1070   
;;;1071   void USART_Configuration(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1072   {
000002  b087              SUB      sp,sp,#0x1c
;;;1073     USART_InitTypeDef USART_InitStructure;
;;;1074     USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;1075   
;;;1076   /* USART1 configuration ------------------------------------------------------*/
;;;1077     /* USART1 configured as follow:
;;;1078           - BaudRate = 115200 baud  
;;;1079           - Word Length = 8 Bits
;;;1080           - One Stop Bit
;;;1081           - No parity
;;;1082           - Hardware flow control disabled (RTS and CTS signals)
;;;1083           - Receive and transmit enabled
;;;1084           - USART Clock disabled
;;;1085           - USART CPOL: Clock is active low
;;;1086           - USART CPHA: Data is captured on the middle 
;;;1087           - USART LastBit: The clock pulse of the last data bit is not output to 
;;;1088                            the SCLK pin
;;;1089     */
;;;1090   USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;1091   USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;1092   USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0014          STRH     r0,[sp,#0x14]
;;;1093   USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;1094   /* Configure the USART1 synchronous paramters */
;;;1095   USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L29.84|
000010  f8ad4010          STRH     r4,[sp,#0x10]         ;1090
000014  f8ad4012          STRH     r4,[sp,#0x12]         ;1091
000018  f8ad4016          STRH     r4,[sp,#0x16]         ;1093
00001c  a904              ADD      r1,sp,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;1096   
;;;1097   USART_InitStructure.USART_BaudRate = 115200;
000024  f44f31e1          MOV      r1,#0x1c200
;;;1098   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9100              STR      r1,[sp,#0]
;;;1099   USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;1100   USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4008          STRH     r4,[sp,#8]
;;;1101   USART_InitStructure.USART_HardwareFlowControl = 
;;;1102   USART_HardwareFlowControl_None;
;;;1103   
;;;1104   USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  210c              MOVS     r1,#0xc
000030  f8ad4004          STRH     r4,[sp,#4]            ;1098
000034  f8ad100a          STRH     r1,[sp,#0xa]
000038  f8ad4006          STRH     r4,[sp,#6]            ;1099
00003c  f8ad400c          STRH     r4,[sp,#0xc]          ;1101
;;;1105   /* Configure USART1 basic and asynchronous paramters */
;;;1106   USART_Init(USART1, &USART_InitStructure);
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;1107       
;;;1108     /* Enable USART1 */
;;;1109     USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;1110     
;;;1111   }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;1112   
                          ENDP

                  |L29.84|
                          DCD      0x40013800

                          AREA ||i.VCOM_GET||, CODE, READONLY, ALIGN=2

                  VCOM_GET PROC
;;;1720   
;;;1721   u8 VCOM_GET(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1722   {
;;;1723   	READ_VCOM_OTP_TIMES_HX8369(0x1B);
000002  201b              MOVS     r0,#0x1b
000004  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
;;;1724   		DelayKEY(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DelayKEY
;;;1725   		switch(MIPI_READ_DATA[4])
00000e  4d38              LDR      r5,|L30.240|
000010  2100              MOVS     r1,#0
;;;1726   		{
;;;1727   			case 0xFF:
;;;1728   				
;;;1729   				OTP_TIMES_BEFORE = 0;
000012  4c38              LDR      r4,|L30.244|
000014  7928              LDRB     r0,[r5,#4]            ;1725  ; MIPI_READ_DATA
000016  2827              CMP      r0,#0x27              ;1725
000018  d035              BEQ      |L30.134|
00001a  dc03              BGT      |L30.36|
00001c  b130              CBZ      r0,|L30.44|
00001e  2803              CMP      r0,#3                 ;1725
000020  d04b              BEQ      |L30.186|
000022  e003              B        |L30.44|
                  |L30.36|
000024  286f              CMP      r0,#0x6f              ;1725
000026  d015              BEQ      |L30.84|
000028  28ff              CMP      r0,#0xff              ;1725
00002a  d007              BEQ      |L30.60|
                  |L30.44|
;;;1730   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1731   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1732   				break;
;;;1733   			
;;;1734   			case 0x6F:
;;;1735   				
;;;1736   				OTP_TIMES_BEFORE = 1;
;;;1737   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1738   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1739   				READ_VCOM_OTP_TIMES_HX8369(0x1C);
;;;1740   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1741   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1742   				break;
;;;1743   			
;;;1744   			case 0x27:
;;;1745   				
;;;1746   				OTP_TIMES_BEFORE = 2;
;;;1747   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1748   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1749   				READ_VCOM_OTP_TIMES_HX8369(0x1E);
;;;1750   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1751   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1752   				break;
;;;1753   			
;;;1754   			case 0x03:
;;;1755   				
;;;1756   				OTP_TIMES_BEFORE = 3;
;;;1757   				LCD_DisplayStringLine(1,10,"otp times = ");
;;;1758   				SHOW_IC_VALUE_A(195,10,OTP_TIMES_BEFORE);
;;;1759   				READ_VCOM_OTP_TIMES_HX8369(0x20);
;;;1760   				LCD_DisplayStringLine(1,50,"vcom value = ");
;;;1761   				SHOW_IC_VALUE_A(195,50,MIPI_READ_DATA[4]);
;;;1762   				break;
;;;1763   			
;;;1764   			case 0x00:
;;;1765   				
;;;1766   				OTP_TIMES_BEFORE = 0;
00002c  7261              STRB     r1,[r4,#9]
;;;1767   				LCD_DisplayStringLine(20,10,"otp read error");
00002e  a232              ADR      r2,|L30.248|
000030  210a              MOVS     r1,#0xa
000032  2014              MOVS     r0,#0x14
000034  f7fffffe          BL       LCD_DisplayStringLine
                  |L30.56|
;;;1768   				break;
;;;1769   			
;;;1770   			default:
;;;1771   				
;;;1772   				OTP_TIMES_BEFORE = 0;
;;;1773   				LCD_DisplayStringLine(20,10,"otp read error");
;;;1774   				break;
;;;1775   		}
;;;1776   		
;;;1777   		return 0;
000038  2000              MOVS     r0,#0
;;;1778   }
00003a  bd70              POP      {r4-r6,pc}
                  |L30.60|
00003c  7261              STRB     r1,[r4,#9]            ;1729
00003e  a232              ADR      r2,|L30.264|
000040  210a              MOVS     r1,#0xa               ;1730
000042  2001              MOVS     r0,#1                 ;1730
000044  f7fffffe          BL       LCD_DisplayStringLine
000048  7a62              LDRB     r2,[r4,#9]            ;1731  ; OTP_TIMES_BEFORE
00004a  210a              MOVS     r1,#0xa               ;1731
00004c  20c3              MOVS     r0,#0xc3              ;1731
00004e  f7fffffe          BL       SHOW_IC_VALUE_A
000052  e7f1              B        |L30.56|
                  |L30.84|
000054  2001              MOVS     r0,#1                 ;1736
000056  7260              STRB     r0,[r4,#9]            ;1736
000058  a22b              ADR      r2,|L30.264|
00005a  210a              MOVS     r1,#0xa               ;1737
00005c  f7fffffe          BL       LCD_DisplayStringLine
000060  7a62              LDRB     r2,[r4,#9]            ;1738  ; OTP_TIMES_BEFORE
000062  210a              MOVS     r1,#0xa               ;1738
000064  20c3              MOVS     r0,#0xc3              ;1738
000066  f7fffffe          BL       SHOW_IC_VALUE_A
00006a  201c              MOVS     r0,#0x1c              ;1739
00006c  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
000070  a229              ADR      r2,|L30.280|
000072  2132              MOVS     r1,#0x32              ;1740
000074  2001              MOVS     r0,#1                 ;1740
000076  f7fffffe          BL       LCD_DisplayStringLine
00007a  792a              LDRB     r2,[r5,#4]            ;1741  ; MIPI_READ_DATA
00007c  2132              MOVS     r1,#0x32              ;1741
00007e  20c3              MOVS     r0,#0xc3              ;1741
000080  f7fffffe          BL       SHOW_IC_VALUE_A
000084  e7d8              B        |L30.56|
                  |L30.134|
000086  2002              MOVS     r0,#2                 ;1746
000088  7260              STRB     r0,[r4,#9]            ;1746
00008a  a21f              ADR      r2,|L30.264|
00008c  210a              MOVS     r1,#0xa               ;1747
00008e  2001              MOVS     r0,#1                 ;1747
000090  f7fffffe          BL       LCD_DisplayStringLine
000094  7a62              LDRB     r2,[r4,#9]            ;1748  ; OTP_TIMES_BEFORE
000096  210a              MOVS     r1,#0xa               ;1748
000098  20c3              MOVS     r0,#0xc3              ;1748
00009a  f7fffffe          BL       SHOW_IC_VALUE_A
00009e  201e              MOVS     r0,#0x1e              ;1749
0000a0  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
0000a4  a21c              ADR      r2,|L30.280|
0000a6  2132              MOVS     r1,#0x32              ;1750
0000a8  2001              MOVS     r0,#1                 ;1750
0000aa  f7fffffe          BL       LCD_DisplayStringLine
0000ae  792a              LDRB     r2,[r5,#4]            ;1751  ; MIPI_READ_DATA
0000b0  2132              MOVS     r1,#0x32              ;1751
0000b2  20c3              MOVS     r0,#0xc3              ;1751
0000b4  f7fffffe          BL       SHOW_IC_VALUE_A
0000b8  e7be              B        |L30.56|
                  |L30.186|
0000ba  2003              MOVS     r0,#3                 ;1756
0000bc  7260              STRB     r0,[r4,#9]            ;1756
0000be  a212              ADR      r2,|L30.264|
0000c0  210a              MOVS     r1,#0xa               ;1757
0000c2  2001              MOVS     r0,#1                 ;1757
0000c4  f7fffffe          BL       LCD_DisplayStringLine
0000c8  7a62              LDRB     r2,[r4,#9]            ;1758  ; OTP_TIMES_BEFORE
0000ca  210a              MOVS     r1,#0xa               ;1758
0000cc  20c3              MOVS     r0,#0xc3              ;1758
0000ce  f7fffffe          BL       SHOW_IC_VALUE_A
0000d2  2020              MOVS     r0,#0x20              ;1759
0000d4  f7fffffe          BL       READ_VCOM_OTP_TIMES_HX8369
0000d8  a20f              ADR      r2,|L30.280|
0000da  2132              MOVS     r1,#0x32              ;1760
0000dc  2001              MOVS     r0,#1                 ;1760
0000de  f7fffffe          BL       LCD_DisplayStringLine
0000e2  792a              LDRB     r2,[r5,#4]            ;1761  ; MIPI_READ_DATA
0000e4  2132              MOVS     r1,#0x32              ;1761
0000e6  20c3              MOVS     r0,#0xc3              ;1761
0000e8  f7fffffe          BL       SHOW_IC_VALUE_A
0000ec  e7a4              B        |L30.56|
;;;1779   /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
                          ENDP

0000ee  0000              DCW      0x0000
                  |L30.240|
                          DCD      ||.bss||
                  |L30.244|
                          DCD      ||.data||
                  |L30.248|
0000f8  6f747020          DCB      "otp read error",0
0000fc  72656164
000100  20657272
000104  6f7200  
000107  00                DCB      0
                  |L30.264|
000108  6f747020          DCB      "otp times = ",0
00010c  74696d65
000110  73203d20
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L30.280|
000118  76636f6d          DCB      "vcom value = ",0
00011c  2076616c
000120  7565203d
000124  2000    
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.check_power||, CODE, READONLY, ALIGN=2

                  check_power PROC
;;;389    
;;;390    void check_power(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;391    {
000002  b083              SUB      sp,sp,#0xc
;;;392    	  	ENTER_LP_mode(); //enter  LP mode
000004  f7fffffe          BL       ENTER_LP_mode
;;;393    
;;;394    	 	MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000008  2300              MOVS     r3,#0
00000a  461a              MOV      r2,r3
00000c  2139              MOVS     r1,#0x39
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       MIPI_SPI_Write
;;;395    		MIPI_SPI_Write(0x05,0x39,0xFF,0x80,0x09,0x01);
000014  2501              MOVS     r5,#1
000016  2409              MOVS     r4,#9
000018  2380              MOVS     r3,#0x80
00001a  22ff              MOVS     r2,#0xff
00001c  2139              MOVS     r1,#0x39
00001e  2005              MOVS     r0,#5
000020  e9cd4500          STRD     r4,r5,[sp,#0]
000024  f7fffffe          BL       MIPI_SPI_Write
;;;396    		
;;;397    		MIPI_SPI_Write(0x03,0x39,0x00,0x80);
000028  2380              MOVS     r3,#0x80
00002a  2200              MOVS     r2,#0
00002c  2139              MOVS     r1,#0x39
00002e  2003              MOVS     r0,#3
000030  f7fffffe          BL       MIPI_SPI_Write
;;;398    		MIPI_SPI_Write(0x04,0x39,0xFF,0x80,0x09);
000034  2380              MOVS     r3,#0x80
000036  22ff              MOVS     r2,#0xff
000038  2139              MOVS     r1,#0x39
00003a  2004              MOVS     r0,#4
00003c  9400              STR      r4,[sp,#0]
00003e  f7fffffe          BL       MIPI_SPI_Write
;;;399    
;;;400    		MIPI_SPI_Write(0x03,0x39,0x00,0x00);
000042  2300              MOVS     r3,#0
000044  461a              MOV      r2,r3
000046  2139              MOVS     r1,#0x39
000048  2003              MOVS     r0,#3
00004a  f7fffffe          BL       MIPI_SPI_Write
;;;401    		MIPI_SPI_Write(0x03,0x39,0xD0,0xD5);
00004e  23d5              MOVS     r3,#0xd5
000050  22d0              MOVS     r2,#0xd0
000052  2139              MOVS     r1,#0x39
000054  2003              MOVS     r0,#3
000056  f7fffffe          BL       MIPI_SPI_Write
;;;402    
;;;403    		READ_IC(0XD3,0x00);
00005a  2100              MOVS     r1,#0
00005c  20d3              MOVS     r0,#0xd3
00005e  f7fffffe          BL       READ_IC
;;;404    
;;;405       
;;;406     
;;;407    		if(MIPI_READ_DATA[0] == 0x03)
000062  4c15              LDR      r4,|L31.184|
000064  2000              MOVS     r0,#0
000066  22ff              MOVS     r2,#0xff              ;395
000068  7827              LDRB     r7,[r4,#0]  ; MIPI_READ_DATA
;;;408    		{
;;;409    			ID_OK = 0;
00006a  4914              LDR      r1,|L31.188|
;;;410    			FontR = 0; FontG = 255; FontB = 0;
00006c  4b14              LDR      r3,|L31.192|
00006e  f8dfc054          LDR      r12,|L31.196|
000072  4e15              LDR      r6,|L31.200|
000074  2f03              CMP      r7,#3                 ;407
000076  d018              BEQ      |L31.170|
;;;411    		//		LCD_DisplayStringLine_A( 10 ,800,"otp power OK");
;;;412    		}
;;;413    		else
;;;414    		{
;;;415    			ID_OK = 1;
000078  728d              STRB     r5,[r1,#0xa]
;;;416    			FontR = 255; FontG = 0; FontB = 0;
00007a  701a              STRB     r2,[r3,#0]
00007c  f88c0000          STRB     r0,[r12,#0]
000080  7030              STRB     r0,[r6,#0]
;;;417    			LCD_DisplayStringLine(100,700,"otp  power");
000082  a212              ADR      r2,|L31.204|
000084  f44f712f          MOV      r1,#0x2bc
000088  2064              MOVS     r0,#0x64
00008a  f7fffffe          BL       LCD_DisplayStringLine
;;;418    			SHOW_IC_VALUE_A(300,700,MIPI_READ_DATA[0]);
00008e  7822              LDRB     r2,[r4,#0]  ; MIPI_READ_DATA
000090  f44f712f          MOV      r1,#0x2bc
000094  f44f7096          MOV      r0,#0x12c
000098  f7fffffe          BL       SHOW_IC_VALUE_A
;;;419    			LCD_DisplayStringLine_A( 50 ,800,"otp power NG");
00009c  a20e              ADR      r2,|L31.216|
00009e  f44f7148          MOV      r1,#0x320
0000a2  2032              MOVS     r0,#0x32
0000a4  f7fffffe          BL       LCD_DisplayStringLine_A
                  |L31.168|
;;;420    			while(1);
0000a8  e7fe              B        |L31.168|
                  |L31.170|
0000aa  7288              STRB     r0,[r1,#0xa]          ;409
0000ac  7018              STRB     r0,[r3,#0]            ;410
0000ae  f88c2000          STRB     r2,[r12,#0]           ;410
0000b2  7030              STRB     r0,[r6,#0]            ;410
;;;421    		//		LCD_DisplayStringLine_A(adx+150,ady,"NG");
;;;422    		}
;;;423    		
;;;424    		////	Delay(5);
;;;425    
;;;426    }
0000b4  b003              ADD      sp,sp,#0xc
0000b6  bdf0              POP      {r4-r7,pc}
;;;427    
                          ENDP

                  |L31.184|
                          DCD      ||.bss||
                  |L31.188|
                          DCD      ||.data||
                  |L31.192|
                          DCD      FontR
                  |L31.196|
                          DCD      FontG
                  |L31.200|
                          DCD      FontB
                  |L31.204|
0000cc  6f747020          DCB      "otp  power",0
0000d0  20706f77
0000d4  657200  
0000d7  00                DCB      0
                  |L31.216|
0000d8  6f747020          DCB      "otp power NG",0
0000dc  706f7765
0000e0  72204e47
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.cycle_OTP||, CODE, READONLY, ALIGN=1

                  cycle_OTP PROC
;;;1519   
;;;1520   void cycle_OTP(u8 OTPValue)
000000  b530              PUSH     {r4,r5,lr}
;;;1521   {
000002  b083              SUB      sp,sp,#0xc
;;;1522   
;;;1523   
;;;1524   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x00);
000004  2500              MOVS     r5,#0
000006  e9cd5000          STRD     r5,r0,[sp,#0]
00000a  4604              MOV      r4,r0                 ;1521
00000c  462b              MOV      r3,r5
00000e  22bb              MOVS     r2,#0xbb
000010  2139              MOVS     r1,#0x39
000012  2006              MOVS     r0,#6
000014  9502              STR      r5,[sp,#8]
000016  f7fffffe          BL       MIPI_SPI_Write
;;;1525   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x01);
00001a  2001              MOVS     r0,#1
00001c  9500              STR      r5,[sp,#0]
00001e  e9cd4001          STRD     r4,r0,[sp,#4]
000022  2300              MOVS     r3,#0
000024  22bb              MOVS     r2,#0xbb
000026  2139              MOVS     r1,#0x39
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       MIPI_SPI_Write
;;;1526   	Delay(5);
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       Delay
000034  e9cd5400          STRD     r5,r4,[sp,#0]
;;;1527   	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,OTPValue,0x00);
000038  2300              MOVS     r3,#0
00003a  22bb              MOVS     r2,#0xbb
00003c  2139              MOVS     r1,#0x39
00003e  2006              MOVS     r0,#6
000040  9502              STR      r5,[sp,#8]
000042  f7fffffe          BL       MIPI_SPI_Write
;;;1528   
;;;1529   }
000046  b003              ADD      sp,sp,#0xc
000048  bd30              POP      {r4,r5,pc}
;;;1530   
                          ENDP


                          AREA ||i.initial_OTP||, CODE, READONLY, ALIGN=1

                  initial_OTP PROC
;;;1530   
;;;1531   void initial_OTP(void)
000000  b510              PUSH     {r4,lr}
;;;1532   {
;;;1533   
;;;1534   //	MIPI_SPI_Write(0x06,0x39, 0xB9,0xFF,0x83,0x69);//EXTC Command Set enable register
;;;1535   //
;;;1536   //	OPEN_OTP_Voltage;//Open 7.5V
;;;1537   //	Delay(50);//Wait 500ms for PVSS stable	8369 no delay time
;;;1538   //
;;;1539   ////	MIPI_SPI_Write(0x06,0x39,0xB6,0x2E,0x2E);	//Set VCOM
;;;1540   //	MIPI_SPI_Write(0x06,0x39,0xE9,0xAA,0x55);	//Set OTP
;;;1541   
;;;1542   //-----------------------GIP timing------------------------//
;;;1543   //	MIPI_SPI_Write(0x06,0x39,0xBB,0x00,0x00,0xB3,0x00);
;;;1544   //	MIPI_SPI_Write(0x30,0x39,0xBB,0x00,0x00,0xB3,0x01);
;;;1545   //	Delay(5);
;;;1546   //	MIPI_SPI_Write(0x30,0x39,0xBB,0x00,0x00,0xB3,0x00);
;;;1547   
;;;1548   
;;;1549   
;;;1550   cycle_OTP(0xB0);
000002  20b0              MOVS     r0,#0xb0
000004  f7fffffe          BL       cycle_OTP
;;;1551   cycle_OTP(0xB1);
000008  20b1              MOVS     r0,#0xb1
00000a  f7fffffe          BL       cycle_OTP
;;;1552   cycle_OTP(0xB2);
00000e  20b2              MOVS     r0,#0xb2
000010  f7fffffe          BL       cycle_OTP
;;;1553   cycle_OTP(0xB3);
000014  20b3              MOVS     r0,#0xb3
000016  f7fffffe          BL       cycle_OTP
;;;1554   
;;;1555   //cycle_OTP(0x1C);
;;;1556   //cycle_OTP(0x1D);
;;;1557   
;;;1558   cycle_OTP(0x31);
00001a  2031              MOVS     r0,#0x31
00001c  f7fffffe          BL       cycle_OTP
;;;1559   cycle_OTP(0x32);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       cycle_OTP
;;;1560   cycle_OTP(0x33);
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       cycle_OTP
;;;1561   cycle_OTP(0x34);
00002c  2034              MOVS     r0,#0x34
00002e  f7fffffe          BL       cycle_OTP
;;;1562   cycle_OTP(0x35);
000032  2035              MOVS     r0,#0x35
000034  f7fffffe          BL       cycle_OTP
;;;1563   cycle_OTP(0x36);
000038  2036              MOVS     r0,#0x36
00003a  f7fffffe          BL       cycle_OTP
;;;1564   cycle_OTP(0x37);
00003e  2037              MOVS     r0,#0x37
000040  f7fffffe          BL       cycle_OTP
;;;1565   cycle_OTP(0x38);
000044  2038              MOVS     r0,#0x38
000046  f7fffffe          BL       cycle_OTP
;;;1566   cycle_OTP(0x39);
00004a  2039              MOVS     r0,#0x39
00004c  f7fffffe          BL       cycle_OTP
;;;1567   cycle_OTP(0x3A);
000050  203a              MOVS     r0,#0x3a
000052  f7fffffe          BL       cycle_OTP
;;;1568   cycle_OTP(0x3B);
000056  203b              MOVS     r0,#0x3b
000058  f7fffffe          BL       cycle_OTP
;;;1569   cycle_OTP(0x3C);
00005c  203c              MOVS     r0,#0x3c
00005e  f7fffffe          BL       cycle_OTP
;;;1570   cycle_OTP(0x3D);
000062  203d              MOVS     r0,#0x3d
000064  f7fffffe          BL       cycle_OTP
;;;1571   cycle_OTP(0x3E);
000068  203e              MOVS     r0,#0x3e
00006a  f7fffffe          BL       cycle_OTP
;;;1572   cycle_OTP(0x3F);
00006e  203f              MOVS     r0,#0x3f
000070  f7fffffe          BL       cycle_OTP
;;;1573   
;;;1574   cycle_OTP(0x40);
000074  2040              MOVS     r0,#0x40
000076  f7fffffe          BL       cycle_OTP
;;;1575   cycle_OTP(0x41);
00007a  2041              MOVS     r0,#0x41
00007c  f7fffffe          BL       cycle_OTP
;;;1576   cycle_OTP(0x42);
000080  2042              MOVS     r0,#0x42
000082  f7fffffe          BL       cycle_OTP
;;;1577   cycle_OTP(0x43);
000086  2043              MOVS     r0,#0x43
000088  f7fffffe          BL       cycle_OTP
;;;1578   cycle_OTP(0x44);
00008c  2044              MOVS     r0,#0x44
00008e  f7fffffe          BL       cycle_OTP
;;;1579   cycle_OTP(0x45);
000092  2045              MOVS     r0,#0x45
000094  f7fffffe          BL       cycle_OTP
;;;1580   cycle_OTP(0x46);
000098  2046              MOVS     r0,#0x46
00009a  f7fffffe          BL       cycle_OTP
;;;1581   //cycle_OTP(0x47);
;;;1582   cycle_OTP(0x48);
00009e  2048              MOVS     r0,#0x48
0000a0  f7fffffe          BL       cycle_OTP
;;;1583   cycle_OTP(0x49);
0000a4  2049              MOVS     r0,#0x49
0000a6  f7fffffe          BL       cycle_OTP
;;;1584   cycle_OTP(0x4A);
0000aa  204a              MOVS     r0,#0x4a
0000ac  f7fffffe          BL       cycle_OTP
;;;1585   
;;;1586   cycle_OTP(0x78);
0000b0  2078              MOVS     r0,#0x78
0000b2  f7fffffe          BL       cycle_OTP
;;;1587   cycle_OTP(0x79);
0000b6  2079              MOVS     r0,#0x79
0000b8  f7fffffe          BL       cycle_OTP
;;;1588   cycle_OTP(0x7A);
0000bc  207a              MOVS     r0,#0x7a
0000be  f7fffffe          BL       cycle_OTP
;;;1589   cycle_OTP(0x7B);
0000c2  207b              MOVS     r0,#0x7b
0000c4  f7fffffe          BL       cycle_OTP
;;;1590   cycle_OTP(0x7C);
0000c8  207c              MOVS     r0,#0x7c
0000ca  f7fffffe          BL       cycle_OTP
;;;1591   cycle_OTP(0x7D);
0000ce  207d              MOVS     r0,#0x7d
0000d0  f7fffffe          BL       cycle_OTP
;;;1592   cycle_OTP(0x7E);
0000d4  207e              MOVS     r0,#0x7e
0000d6  f7fffffe          BL       cycle_OTP
;;;1593   cycle_OTP(0x7F);
0000da  207f              MOVS     r0,#0x7f
0000dc  f7fffffe          BL       cycle_OTP
;;;1594   
;;;1595   cycle_OTP(0x80);
0000e0  2080              MOVS     r0,#0x80
0000e2  f7fffffe          BL       cycle_OTP
;;;1596   cycle_OTP(0x81);
0000e6  2081              MOVS     r0,#0x81
0000e8  f7fffffe          BL       cycle_OTP
;;;1597   cycle_OTP(0x82);
0000ec  2082              MOVS     r0,#0x82
0000ee  f7fffffe          BL       cycle_OTP
;;;1598   cycle_OTP(0x83);
0000f2  2083              MOVS     r0,#0x83
0000f4  f7fffffe          BL       cycle_OTP
;;;1599   cycle_OTP(0x84);
0000f8  2084              MOVS     r0,#0x84
0000fa  f7fffffe          BL       cycle_OTP
;;;1600   cycle_OTP(0x85);
0000fe  2085              MOVS     r0,#0x85
000100  f7fffffe          BL       cycle_OTP
;;;1601   cycle_OTP(0x86);
000104  2086              MOVS     r0,#0x86
000106  f7fffffe          BL       cycle_OTP
;;;1602   cycle_OTP(0x87);
00010a  2087              MOVS     r0,#0x87
00010c  f7fffffe          BL       cycle_OTP
;;;1603   cycle_OTP(0x88);
000110  2088              MOVS     r0,#0x88
000112  f7fffffe          BL       cycle_OTP
;;;1604   cycle_OTP(0x89);
000116  2089              MOVS     r0,#0x89
000118  f7fffffe          BL       cycle_OTP
;;;1605   cycle_OTP(0x8A);
00011c  208a              MOVS     r0,#0x8a
00011e  f7fffffe          BL       cycle_OTP
;;;1606   cycle_OTP(0x8B);
000122  208b              MOVS     r0,#0x8b
000124  f7fffffe          BL       cycle_OTP
;;;1607   cycle_OTP(0x8C);
000128  208c              MOVS     r0,#0x8c
00012a  f7fffffe          BL       cycle_OTP
;;;1608   cycle_OTP(0x8D);
00012e  208d              MOVS     r0,#0x8d
000130  f7fffffe          BL       cycle_OTP
;;;1609   cycle_OTP(0x8E);
000134  208e              MOVS     r0,#0x8e
000136  f7fffffe          BL       cycle_OTP
;;;1610   cycle_OTP(0x8F);
00013a  208f              MOVS     r0,#0x8f
00013c  f7fffffe          BL       cycle_OTP
;;;1611   
;;;1612   cycle_OTP(0x90);
000140  2090              MOVS     r0,#0x90
000142  f7fffffe          BL       cycle_OTP
;;;1613   cycle_OTP(0x91);
000146  2091              MOVS     r0,#0x91
000148  f7fffffe          BL       cycle_OTP
;;;1614   cycle_OTP(0x92);
00014c  2092              MOVS     r0,#0x92
00014e  f7fffffe          BL       cycle_OTP
;;;1615   cycle_OTP(0x93);
000152  2093              MOVS     r0,#0x93
000154  f7fffffe          BL       cycle_OTP
;;;1616   cycle_OTP(0x94);
000158  2094              MOVS     r0,#0x94
00015a  f7fffffe          BL       cycle_OTP
;;;1617   cycle_OTP(0x95);
00015e  2095              MOVS     r0,#0x95
000160  f7fffffe          BL       cycle_OTP
;;;1618   cycle_OTP(0x96);
000164  2096              MOVS     r0,#0x96
000166  f7fffffe          BL       cycle_OTP
;;;1619   cycle_OTP(0x97);
00016a  2097              MOVS     r0,#0x97
00016c  f7fffffe          BL       cycle_OTP
;;;1620   cycle_OTP(0x98);
000170  2098              MOVS     r0,#0x98
000172  f7fffffe          BL       cycle_OTP
;;;1621   cycle_OTP(0x99);
000176  2099              MOVS     r0,#0x99
000178  f7fffffe          BL       cycle_OTP
;;;1622   cycle_OTP(0x9A);
00017c  209a              MOVS     r0,#0x9a
00017e  f7fffffe          BL       cycle_OTP
;;;1623   cycle_OTP(0x9B);
000182  209b              MOVS     r0,#0x9b
000184  f7fffffe          BL       cycle_OTP
;;;1624   cycle_OTP(0x9C);
000188  209c              MOVS     r0,#0x9c
00018a  f7fffffe          BL       cycle_OTP
;;;1625   cycle_OTP(0x9D);
00018e  209d              MOVS     r0,#0x9d
000190  f7fffffe          BL       cycle_OTP
;;;1626   cycle_OTP(0x9E);
000194  209e              MOVS     r0,#0x9e
000196  f7fffffe          BL       cycle_OTP
;;;1627   cycle_OTP(0x9F);
00019a  209f              MOVS     r0,#0x9f
00019c  f7fffffe          BL       cycle_OTP
;;;1628   
;;;1629   cycle_OTP(0xA0);
0001a0  20a0              MOVS     r0,#0xa0
0001a2  f7fffffe          BL       cycle_OTP
;;;1630   cycle_OTP(0xA1);
0001a6  20a1              MOVS     r0,#0xa1
0001a8  f7fffffe          BL       cycle_OTP
;;;1631   cycle_OTP(0xA2);
0001ac  20a2              MOVS     r0,#0xa2
0001ae  f7fffffe          BL       cycle_OTP
;;;1632   cycle_OTP(0xA3);
0001b2  20a3              MOVS     r0,#0xa3
0001b4  f7fffffe          BL       cycle_OTP
;;;1633   cycle_OTP(0xA4);
0001b8  20a4              MOVS     r0,#0xa4
0001ba  f7fffffe          BL       cycle_OTP
;;;1634   cycle_OTP(0xA5);
0001be  20a5              MOVS     r0,#0xa5
0001c0  f7fffffe          BL       cycle_OTP
;;;1635   cycle_OTP(0xA6);
0001c4  20a6              MOVS     r0,#0xa6
0001c6  f7fffffe          BL       cycle_OTP
;;;1636   cycle_OTP(0xA7);
0001ca  20a7              MOVS     r0,#0xa7
0001cc  f7fffffe          BL       cycle_OTP
;;;1637   cycle_OTP(0xA8);
0001d0  20a8              MOVS     r0,#0xa8
0001d2  f7fffffe          BL       cycle_OTP
;;;1638   cycle_OTP(0xA9);
0001d6  20a9              MOVS     r0,#0xa9
0001d8  f7fffffe          BL       cycle_OTP
;;;1639   cycle_OTP(0xAA);
0001dc  20aa              MOVS     r0,#0xaa
0001de  f7fffffe          BL       cycle_OTP
;;;1640   cycle_OTP(0xAB);
0001e2  20ab              MOVS     r0,#0xab
0001e4  f7fffffe          BL       cycle_OTP
;;;1641   cycle_OTP(0xAC);
0001e8  20ac              MOVS     r0,#0xac
0001ea  f7fffffe          BL       cycle_OTP
;;;1642   cycle_OTP(0xAD);
0001ee  20ad              MOVS     r0,#0xad
0001f0  f7fffffe          BL       cycle_OTP
;;;1643   cycle_OTP(0xAE);
0001f4  20ae              MOVS     r0,#0xae
0001f6  f7fffffe          BL       cycle_OTP
;;;1644   cycle_OTP(0xAF);
0001fa  e8bd4010          POP      {r4,lr}
0001fe  20af              MOVS     r0,#0xaf
000200  f7ffbffe          B.W      cycle_OTP
;;;1645   
;;;1646   
;;;1647   
;;;1648   
;;;1649   //	MIPI_SPI_Write(0x06,0x39,0xE9,0x00,0x00);	//Set OTP
;;;1650   //
;;;1651   //	CLOSE_OTP_Voltage;//Close 7.5V 
;;;1652   //	Delay(10);//Wait 10ms	8369 no delay time
;;;1653   	
;;;1654   //	SSD1963Command_8(0xBa); 
;;;1655   //	SSD1963Data_8(0x0E);   //RESET=0
;;;1656   //	Delay(12);
;;;1657   //	SSD1963Command_8(0xBa); 
;;;1658   //	SSD1963Data_8(0x0F);   //RESET=1 
;;;1659   //	Delay(12);
;;;1660   	
;;;1661   //	SSD1963INITSSD2825();
;;;1662   //	OTP_initial();
;;;1663   
;;;1664   
;;;1665   	}
;;;1666   
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;115    /*******************************************************************************/
;;;116    int main(void)
000000  b084              SUB      sp,sp,#0x10
000002  f7fffffe          BL       RCC_DeInit
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4c99              LDR      r4,|L34.632|
000014  2801              CMP      r0,#1
000016  7360              STRB     r0,[r4,#0xd]
000018  d124              BNE      |L34.100|
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L34.76|
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L34.76|
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L34.92|
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L34.92|
                  |L34.100|
000064  2101              MOVS     r1,#1
000066  f2440004          MOV      r0,#0x4004
00006a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;117    {   // uint testf;		//only for test 2014.1.27
;;;118    //	u8 mm=1;
;;;119    //	u32 rand_val;
;;;120    	u32 sdcap=1;
;;;121    	u8 READ_ID = 0;
;;;122    	u16 mm_KEYB1 = 1;
;;;123    
;;;124    //	u8 temp[9];
;;;125    
;;;126      #ifdef DEBUG
;;;127      debug();
;;;128      #endif
;;;129      /* System Clocks Configuration */
;;;130    	RCC_Configuration();	 	
;;;131      /* NVIC Configuration */
;;;132    	NVIC_Configuration();   //中断管理初始化   
00006e  f7fffffe          BL       NVIC_Configuration
000072  2004              MOVS     r0,#4
000074  f7fffffe          BL       SysTick_CLKSourceConfig
000078  4880              LDR      r0,|L34.636|
00007a  f7fffffe          BL       SysTick_SetReload
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       SysTick_ITConfig
000084  2001              MOVS     r0,#1
000086  f7fffffe          BL       SysTick_CounterCmd
;;;133    	SysTick_Config();		    //延时用  	
;;;134    	  
;;;135      //-------------------------------------------------
;;;136      /* Initialize the LCD */
;;;137    	STM32_SSD1963_Init();
00008a  f7fffffe          BL       STM32_SSD1963_Init
00008e  2101              MOVS     r1,#1
000090  2015              MOVS     r0,#0x15
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
000096  2040              MOVS     r0,#0x40
000098  f8ad0000          STRH     r0,[sp,#0]
00009c  2548              MOVS     r5,#0x48
00009e  f88d5003          STRB     r5,[sp,#3]
0000a2  4669              MOV      r1,sp
0000a4  4876              LDR      r0,|L34.640|
0000a6  f7fffffe          BL       GPIO_Init
0000aa  2080              MOVS     r0,#0x80
0000ac  f8ad0000          STRH     r0,[sp,#0]
0000b0  f88d5003          STRB     r5,[sp,#3]
0000b4  4669              MOV      r1,sp
0000b6  4873              LDR      r0,|L34.644|
0000b8  f7fffffe          BL       GPIO_Init
;;;138    
;;;139    	KEYGPIO_Init();
;;;140    	Sensor_GPIO_Config();
0000bc  f7fffffe          BL       Sensor_GPIO_Config
;;;141    	
;;;142    
;;;143    	
;;;144    ///SD  卡初始化部分。
;;;145    	if(SDConfigFlag == 0)
0000c0  7860              LDRB     r0,[r4,#1]  ; SDConfigFlag
;;;146    	{
;;;147    		SDShowFlag=1;
;;;148    	
;;;149    		Status =SD_InitAndConfig();  /*设置SD接口,初始化SD卡*/
;;;150    		sdcap=sd_Capacity>>20; //(sdcap=sd_Capacity/1024/1024)
;;;151    		All_Color(255,255,255)   ;
;;;152    
;;;153    			if(sdcap == 0)
;;;154    			{
;;;155    				FontR = 255;
0000c2  f8df81c4          LDR      r8,|L34.648|
;;;156    				FontB = 20;
0000c6  4e71              LDR      r6,|L34.652|
;;;157    				FontG = 20;
0000c8  4f71              LDR      r7,|L34.656|
0000ca  f04f0b14          MOV      r11,#0x14             ;156
0000ce  f04f09ff          MOV      r9,#0xff              ;151
0000d2  f04f0a01          MOV      r10,#1                ;120
0000d6  2800              CMP      r0,#0                 ;145
0000d8  d07e              BEQ      |L34.472|
                  |L34.218|
;;;158    //				LCD_DisplayStringLine_A(0,Line0,"SD ERROR!");	
;;;159    
;;;160    				FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
;;;161    //				while(1)
;;;162    //				{
;;;163    //					DelayKEY(100);
;;;164    //				}
;;;165    			}
;;;166    			else
;;;167    			{
;;;168    				FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
;;;169    				SDConfigFlag = 1;
;;;170    					
;;;171    			}
;;;172    	}
;;;173    
;;;174    
;;;175    	FontR = FontG = FontB = 255;			   //屏蔽字符
0000da  f8869000          STRB     r9,[r6,#0]
0000de  f8879000          STRB     r9,[r7,#0]
0000e2  f8889000          STRB     r9,[r8,#0]
;;;176    	  	if (FAT_Init())	//初始化FAT文件系统
0000e6  f7fffffe          BL       FAT_Init
0000ea  b150              CBZ      r0,|L34.258|
;;;177    		  {	
;;;178    		  		All_Color(255,255,255)   ;
0000ec  22ff              MOVS     r2,#0xff
0000ee  4611              MOV      r1,r2
0000f0  4610              MOV      r0,r2
0000f2  f7fffffe          BL       All_Color
;;;179    				FontR = 255;
0000f6  f8889000          STRB     r9,[r8,#0]
;;;180    				FontB = 20;
0000fa  f886b000          STRB     r11,[r6,#0]
;;;181    				FontG = 20;
0000fe  f887b000          STRB     r11,[r7,#0]
                  |L34.258|
;;;182    //				LCD_DisplayStringLine_A(0,Line0,"SD ERROR!");
;;;183    //				while(1)
;;;184    				{
;;;185    //					DelayKEY(100);
;;;186    				}
;;;187        
;;;188    		  }
;;;189              FontR = FontG = FontB = 255;		//屏蔽部分字符时候使用此段；
000102  f8869000          STRB     r9,[r6,#0]
000106  f8879000          STRB     r9,[r7,#0]
00010a  f8889000          STRB     r9,[r8,#0]
;;;190    		LCD_DisplayStringLine(0,Line2,"Waiting....");
00010e  a261              ADR      r2,|L34.660|
000110  2130              MOVS     r1,#0x30
000112  2000              MOVS     r0,#0
000114  f7fffffe          BL       LCD_DisplayStringLine
;;;191    		
;;;192    			SearchInit();
000118  f7fffffe          BL       SearchInit
;;;193    
;;;194    		//////////////////show the project ----------------------------------------------------
;;;195    		
;;;196    
;;;197    
;;;198    
;;;199    
;;;200    	     
;;;201    	  	FontR = FontG = FontB = 0;
00011c  2500              MOVS     r5,#0
00011e  7035              STRB     r5,[r6,#0]
000120  703d              STRB     r5,[r7,#0]
000122  f8885000          STRB     r5,[r8,#0]
;;;202    		LCD_DisplayStringLine_A(30,160,"TFT9K2353_A");	  /////2014/4/4   /////2014/4/4  M1461A0_C
000126  a25e              ADR      r2,|L34.672|
000128  21a0              MOVS     r1,#0xa0
00012a  201e              MOVS     r0,#0x1e
00012c  f7fffffe          BL       LCD_DisplayStringLine_A
;;;203    //		LCD_DisplayStringLine_A(30,360,"FGA7_20160426");
;;;204    		DelayKEY(100);
000130  2064              MOVS     r0,#0x64
000132  f7fffffe          BL       DelayKEY
;;;205    //		VCOM_GET();
;;;206    		
;;;207    		
;;;208    	FontR = FontG = FontB = 255;			   //屏蔽字符
000136  f8869000          STRB     r9,[r6,#0]
00013a  f8879000          STRB     r9,[r7,#0]
00013e  f8889000          STRB     r9,[r8,#0]
;;;209    	 
;;;210    
;;;211    		SDShowTimes = 0;
000142  70e5              STRB     r5,[r4,#3]
;;;212    
;;;213    		while (SDShowFlag) //开始BMP文件显示
000144  78a0              LDRB     r0,[r4,#2]  ; SDShowFlag
000146  b128              CBZ      r0,|L34.340|
;;;214    		{	  
;;;215    		 Disp_BMP() ;
000148  f7fffffe          BL       Disp_BMP
;;;216    		  Delay(1);
00014c  2001              MOVS     r0,#1
00014e  f7fffffe          BL       Delay
;;;217    		  SDShowFlag = 0;	
000152  70a5              STRB     r5,[r4,#2]
                  |L34.340|
;;;218    		}				   
;;;219    	
;;;220    //	ID_CHECK_A(10,100);  /////check ID ,if ID NG,,while(1);  if ID ok,DO nothing..	
;;;221    	
;;;222    	FontR = FontG = FontB = 0;			   //显示字符
000154  7035              STRB     r5,[r6,#0]
000156  703d              STRB     r5,[r7,#0]
000158  f8885000          STRB     r5,[r8,#0]
00015c  f8df814c          LDR      r8,|L34.684|
                  |L34.352|
;;;223    
;;;224    
;;;225    	 
;;;226    		
;;;227    //	sdcap = KEYA7;
;;;228    
;;;229    
;;;230    ////	while(sdcap!=0)
;;;231    //	
;;;232    //	{sdcap = KEYA7;}
;;;233    
;;;234    //		 
;;;235    //		   if((sdcap==0)||(OTP_TIMES_BEFORE<=0))
;;;236    //		   {	
;;;237    //		   		Flicker_sub_pixel() ;	
;;;238    //			   ////////Re光感板是否放置到A定位置。
;;;239    //					sdcap = KEYA8;
;;;240    //					while(sdcap != 0)	
;;;241    //					{	
;;;242    //						LCD_DisplayStringLine(20,100,"Adjust sensor");	
;;;243    //						Delay(1);
;;;244    //						sdcap = KEYA8;	
;;;245    //					}
;;;246    
;;;247    //				Flicker_sub_pixel() ;
;;;248    //				LCD_WriteArea(3,20,10,790,255,0,0);		   ////start auto otp flow
;;;249    //		   		I2C_DATAL_COMPAREX();
;;;250    //				LCD_WriteArea(3,20,10,790,0,255,0);			  ////to show the best flicker。。。
;;;251    //				DelayKEY(1);
;;;252    //				Flicker_sub_pixel();	
;;;253    //				DelayKEY(1);
;;;254    //				if(DATA_SUM1[count2] <= 350)			 ///for check OTP is OK or NG....		 96
;;;255    //				{
;;;256    //						if(DATA_SUM1[count2] >= 5)
;;;257    //						{
;;;258    //							DelayKEY(1);
;;;259    //							sdcap = 1;
;;;260    //							LCD_CS(1);
;;;261    //							Delay(10);	
;;;262    //							sdcap = KEYA7;
;;;263    ////						    check_power();	   	 	Delay(150);	
;;;264    ////							sdcap = 0;
;;;265    ////							if(sdcap == 0)
;;;266    //						    {
;;;267    //								
;;;268    //								aat = 1;
;;;269    //								MTP_ID();
;;;270    //								FontR = FontG = FontB = 0;
;;;271    //					
;;;272    ////								Soft_reset();
;;;273    //					//			OTP_FLAG = 0;
;;;274    //								aat = 0;
;;;275    //							}
;;;276    //							LCD_CS(0);
;;;277    //							Delay(10);
;;;278    //							Soft_reset();
;;;279    //						    Flicker_sub_pixel();								
;;;280    //							FontR = 50; FontG = 255; FontB = 50;
;;;281    
;;;282    //							VCOM_GET();
;;;283    //							sdcap= MIPI_READ_DATA[4];
;;;284    //							if(sdcap != VCOMDC1)
;;;285    //							{
;;;286    //								OTP_ERROR(); while(1);
;;;287    //							}
;;;288    //							else
;;;289    //							{
;;;290    //								LCD_DisplayStringLine(20,100,"Flicker OTP ok");		
;;;291    //							}
;;;292    //							FontR = 255; FontG = 0; FontB = 0;
;;;293    //							LCD_DisplayStringLine(20,130,"Check flicker again!"); 	DelayKEY(100);
;;;294    //							
;;;295    //							FontR = 0; FontG = 0; FontB = 0;
;;;296    //							
;;;297    //						//	while(1);
;;;298    
;;;299    //						}
;;;300    //						else	   //////////if VCOM value not found perfect,goto error
;;;301    //						{
;;;302    //							OTP_ERROR(); while(1);
;;;303    //						}
;;;304    //				}
;;;305    //				else	   //////////if VCOM value not found perfect,goto error
;;;306    //				{
;;;307    //					OTP_ERROR(); while(1);
;;;308    //				}
;;;309    //				
;;;310    //				
;;;311    //		   }
;;;312    //	else
;;;313    //	{
;;;314    //		Soft_reset();    ///////复位后使用客户初始化code，以便拦检OTP漏烧产品。
;;;315    //	}
;;;316    //	KEY_adjust();
;;;317    //	Flicker_PIXEL();
;;;318    //	showid_vcom()	;								Delay(150);			mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;319    
;;;320    
;;;321    LCDTest:
;;;322    	
;;;323    		   	All_Color(255,0,0)   ; 							DelayKEY(100);
000160  2200              MOVS     r2,#0
000162  4611              MOV      r1,r2
000164  20ff              MOVS     r0,#0xff
000166  f7fffffe          BL       All_Color
00016a  2064              MOVS     r0,#0x64
00016c  f7fffffe          BL       DelayKEY
;;;324    //
;;;325    /////////*-------enter sleep mode------- */ 
;;;326    //////  	enter_sleep_mode( ) ;
;;;327    //////	DelayKEY(250);
;;;328    //////	exit_sleep_mode( );
;;;329    //////*-------exit sleep mode------- */
;;;330    ////
;;;331      	All_Color(0,255,0)   ;					  		DelayKEY(100);
000170  2200              MOVS     r2,#0
000172  21ff              MOVS     r1,#0xff
000174  4610              MOV      r0,r2
000176  f7fffffe          BL       All_Color
00017a  2064              MOVS     r0,#0x64
00017c  f7fffffe          BL       DelayKEY
;;;332    	All_Color(0,0,255)   ;					  		DelayKEY(100);
000180  2100              MOVS     r1,#0
000182  22ff              MOVS     r2,#0xff
000184  4608              MOV      r0,r1
000186  f7fffffe          BL       All_Color
00018a  2064              MOVS     r0,#0x64
00018c  f7fffffe          BL       DelayKEY
;;;333    	All_Color(255,255,255)   ;				  	DelayKEY(100);
000190  22ff              MOVS     r2,#0xff
000192  4611              MOV      r1,r2
000194  4610              MOV      r0,r2
000196  f7fffffe          BL       All_Color
00019a  2064              MOVS     r0,#0x64
00019c  f7fffffe          BL       DelayKEY
;;;334    	LCD_WriteArea(1,XDP-2,1,YDP-2,0,0,0);		DelayKEY(100);
0001a0  2201              MOVS     r2,#1
0001a2  9500              STR      r5,[sp,#0]
0001a4  9501              STR      r5,[sp,#4]
0001a6  23ee              MOVS     r3,#0xee
0001a8  f44f71ef          MOV      r1,#0x1de
0001ac  4610              MOV      r0,r2
0001ae  9502              STR      r5,[sp,#8]
0001b0  f7fffffe          BL       LCD_WriteArea
0001b4  2064              MOVS     r0,#0x64
0001b6  f7fffffe          BL       DelayKEY
;;;335    	All_Color(0,0,0)   ;				  		DelayKEY(100);
0001ba  2200              MOVS     r2,#0
0001bc  4611              MOV      r1,r2
0001be  4610              MOV      r0,r2
0001c0  f7fffffe          BL       All_Color
0001c4  2064              MOVS     r0,#0x64
0001c6  f7fffffe          BL       DelayKEY
;;;336        All_Color(60,60,60)   ;				  		DelayKEY(100);
0001ca  223c              MOVS     r2,#0x3c
0001cc  4611              MOV      r1,r2
0001ce  4610              MOV      r0,r2
0001d0  f7fffffe          BL       All_Color
0001d4  2064              MOVS     r0,#0x64
0001d6  e000              B        |L34.474|
                  |L34.472|
0001d8  e02d              B        |L34.566|
                  |L34.474|
0001da  f7fffffe          BL       DelayKEY
;;;337    	All_Color(127,127,127)   ;				  		DelayKEY(100);
0001de  227f              MOVS     r2,#0x7f
0001e0  4611              MOV      r1,r2
0001e2  4610              MOV      r0,r2
0001e4  f7fffffe          BL       All_Color
0001e8  2064              MOVS     r0,#0x64
0001ea  f7fffffe          BL       DelayKEY
;;;338        RGB_color();                                    DelayKEY(100);
0001ee  f7fffffe          BL       RGB_color
0001f2  2064              MOVS     r0,#0x64
0001f4  f7fffffe          BL       DelayKEY
;;;339        Flicker_PIXEL();                                DelayKEY(100);
0001f8  f7fffffe          BL       Flicker_PIXEL
0001fc  2064              MOVS     r0,#0x64
0001fe  f7fffffe          BL       DelayKEY
000202  f884a002          STRB     r10,[r4,#2]
000206  f884a003          STRB     r10,[r4,#3]
;;;340    	SDPicShow(1);				 			   		DelayKEY(80);	
00020a  2701              MOVS     r7,#1
00020c  2600              MOVS     r6,#0
00020e  f8a8a000          STRH     r10,[r8,#0]
                  |L34.530|
000212  f7fffffe          BL       Disp_BMP
000216  2001              MOVS     r0,#1
000218  f7fffffe          BL       DelayKEY
00021c  f8b80000          LDRH     r0,[r8,#0]  ; image_count
000220  4287              CMP      r7,r0
000222  bf98              IT       LS
000224  2e01              CMPLS    r6,#1
000226  d803              BHI      |L34.560|
000228  1c70              ADDS     r0,r6,#1
00022a  f8a87000          STRH     r7,[r8,#0]
00022e  b2c6              UXTB     r6,r0
                  |L34.560|
000230  b1de              CBZ      r6,|L34.618|
000232  70a5              STRB     r5,[r4,#2]
000234  e01c              B        |L34.624|
                  |L34.566|
000236  f884a002          STRB     r10,[r4,#2]           ;147
00023a  f7fffffe          BL       SD_InitAndConfig
00023e  7020              STRB     r0,[r4,#0]            ;149
000240  6a60              LDR      r0,[r4,#0x24]         ;150  ; sd_Capacity
000242  22ff              MOVS     r2,#0xff              ;151
000244  0d05              LSRS     r5,r0,#20             ;150
000246  4611              MOV      r1,r2                 ;151
000248  4610              MOV      r0,r2                 ;151
00024a  f7fffffe          BL       All_Color
00024e  2d00              CMP      r5,#0                 ;153
000250  bf08              IT       EQ                    ;155
000252  f8889000          STRBEQ   r9,[r8,#0]            ;155
000256  f8869000          STRB     r9,[r6,#0]            ;160
00025a  f8879000          STRB     r9,[r7,#0]            ;160
00025e  bf1c              ITT      NE                    ;168
000260  f8889000          STRBNE   r9,[r8,#0]            ;168
000264  f884a001          STRBNE   r10,[r4,#1]           ;169
000268  e737              B        |L34.218|
                  |L34.618|
00026a  78a0              LDRB     r0,[r4,#2]            ;153  ; SDShowFlag
00026c  2800              CMP      r0,#0                 ;153
00026e  d1d0              BNE      |L34.530|
                  |L34.624|
000270  2050              MOVS     r0,#0x50
000272  f7fffffe          BL       DelayKEY
;;;341    
;;;342    
;;;343    		   
;;;344    //	RGB_color();									
;;;345    //	LCD_DisplayStringLine(40,820,"RED");	 LCD_DisplayStringLine(140,820,"GREEN");		LCD_DisplayStringLine(265,820,"BLUE");		  LCD_DisplayStringLine(380,820,"WHITE");
;;;346    //	DelayKEY(80);															mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;347    //	SDPicShow(2);				 			   		Delay(150);			  mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }//SD  1   pic 
;;;348    //	All_Color(255,0,0)   ; 							Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;349    //	All_Color(0,255,0)   ;					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;350    //	All_Color(0,0,255)   ;					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;351    //	All_Color(255,255,255)   ;					   
;;;352    //	LCD_WriteArea(147,147,169,169,160,255,255);				   ////zy暗c	   R160,G210,B0
;;;353    //	LCD_WriteArea(231,231,169,169,255,210,255);
;;;354    //	LCD_WriteArea(311,311,169,169,255,255,0);			  	Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;355    //	All_Color(0,0,0)   ;							
;;;356    //	LCD_WriteArea(147,147,169,169,53,0,0);				   ////zy亮c		 R49,G29,B69
;;;357    //	LCD_WriteArea(231,231,169,169,0,35,0);
;;;358    //	LCD_WriteArea(311,311,169,169,0,0,89);					  		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;359    // 	SDPicShow(1);				 			   		Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   } //SD  1   pic
;;;360    //	Flicker_PIXEL();								Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;361    // 	showid_vcom()	;								Delay(150);			 mm_KEYB1=KEYC6;	 while(mm_KEYB1 != 0)	{	mm_KEYB1=KEYC6;   }
;;;362      goto LCDTest;
000276  e773              B        |L34.352|
;;;363    
;;;364    }
;;;365    
                          ENDP

                  |L34.632|
                          DCD      ||.data||
                  |L34.636|
                          DCD      0x00011940
                  |L34.640|
                          DCD      0x40011000
                  |L34.644|
                          DCD      0x40010800
                  |L34.648|
                          DCD      FontR
                  |L34.652|
                          DCD      FontB
                  |L34.656|
                          DCD      FontG
                  |L34.660|
000294  57616974          DCB      "Waiting....",0
000298  696e672e
00029c  2e2e2e00
                  |L34.672|
0002a0  54465439          DCB      "TFT9K2353_A",0
0002a4  4b323335
0002a8  335f4100
                  |L34.684|
                          DCD      image_count

                          AREA ||i.showid_vcom||, CODE, READONLY, ALIGN=2

                  showid_vcom PROC
;;;709    
;;;710    void showid_vcom(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;711    {
;;;712    	u8  vcom;
;;;713    
;;;714    	Flicker_PIXEL();		   DelayKEY(1);
000004  f7fffffe          BL       Flicker_PIXEL
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DelayKEY
;;;715    	
;;;716    	
;;;717    	READ_IC_A(0XD9,0x00);
00000e  2100              MOVS     r1,#0
000010  20d9              MOVS     r0,#0xd9
000012  f7fffffe          BL       READ_IC_A
;;;718    	FontR = 0; FontG = 0; FontB = 0;
000016  4e3c              LDR      r6,|L35.264|
000018  4f3c              LDR      r7,|L35.268|
00001a  2500              MOVS     r5,#0
00001c  f8df80f0          LDR      r8,|L35.272|
000020  7035              STRB     r5,[r6,#0]
;;;719    	vcom= MIPI_READ_DATA[0];
000022  f8df90f0          LDR      r9,|L35.276|
000026  703d              STRB     r5,[r7,#0]            ;718
000028  f8885000          STRB     r5,[r8,#0]            ;718
00002c  f8994000          LDRB     r4,[r9,#0]  ; MIPI_READ_DATA
;;;720    	LCD_DisplayStringLine(100,600,"VCOM");
000030  a239              ADR      r2,|L35.280|
000032  f44f7116          MOV      r1,#0x258
000036  2064              MOVS     r0,#0x64
000038  f7fffffe          BL       LCD_DisplayStringLine
;;;721    	SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
00003c  f44f7116          MOV      r1,#0x258
000040  f8992000          LDRB     r2,[r9,#0]  ; MIPI_READ_DATA
000044  1048              ASRS     r0,r1,#1
000046  f7fffffe          BL       SHOW_IC_VALUE_A
;;;722    	
;;;723    	while(ID_CHECK(20,700) == 1)
00004a  f44f712f          MOV      r1,#0x2bc
00004e  2014              MOVS     r0,#0x14
000050  f7fffffe          BL       ID_CHECK
000054  2801              CMP      r0,#1
000056  d126              BNE      |L35.166|
;;;724    	{
;;;725    		READ_ID++;
;;;726    		if(READ_ID >3)
;;;727    		{		while(1);	}
;;;728    		
;;;729    		temp = 1;
;;;730    		temp = KEYA7;
000058  f8dfa0c4          LDR      r10,|L35.288|
00005c  f8df90c4          LDR      r9,|L35.292|
000060  4683              MOV      r11,r0                ;714
                  |L35.98|
000062  f899000c          LDRB     r0,[r9,#0xc]          ;725  ; READ_ID
000066  1c40              ADDS     r0,r0,#1              ;725
000068  b2c0              UXTB     r0,r0                 ;725
00006a  f889000c          STRB     r0,[r9,#0xc]          ;725
00006e  2803              CMP      r0,#3                 ;726
000070  d900              BLS      |L35.116|
                  |L35.114|
000072  e7fe              B        |L35.114|
                  |L35.116|
000074  f8da0000          LDR      r0,[r10,#0]
000078  f0100080          ANDS     r0,r0,#0x80
00007c  f889000b          STRB     r0,[r9,#0xb]
;;;731    		//		temp = 0 ;
;;;732    		
;;;733    		if(temp == 0)
;;;734    		{
;;;735    			aat2 = 0;
;;;736    		//			ENTER_LP_mode();
;;;737    		//			MTP_ID();
;;;738    			aat2 = 1;
000080  bf08              IT       EQ
000082  f8a9b014          STRHEQ   r11,[r9,#0x14]
;;;739    		}
;;;740    		
;;;741    		FontR = FontG = FontB = 0;
000086  f8885000          STRB     r5,[r8,#0]
00008a  703d              STRB     r5,[r7,#0]
00008c  7035              STRB     r5,[r6,#0]
;;;742    		Soft_reset();
00008e  f7fffffe          BL       Soft_reset
;;;743    		Delay(10);	
000092  200a              MOVS     r0,#0xa
000094  f7fffffe          BL       Delay
000098  f44f712f          MOV      r1,#0x2bc             ;723
00009c  2014              MOVS     r0,#0x14              ;723
00009e  f7fffffe          BL       ID_CHECK
0000a2  2801              CMP      r0,#1                 ;723
0000a4  d0dd              BEQ      |L35.98|
                  |L35.166|
;;;744    	
;;;745    	}
;;;746    	
;;;747    	Delay(10);						
0000a6  200a              MOVS     r0,#0xa
0000a8  f7fffffe          BL       Delay
;;;748    	//	READ_IC_A(0XD9,0x00);
;;;749    	
;;;750    	//	Delay(10);
;;;751    	//   LCD_DisplayStringLine(100,600,"VCOM");
;;;752    	////   SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
;;;753    	//	SHOW_IC_VALUE_A(300,600,VCOMDC);
;;;754    	////
;;;755    	////  if(VCOMDC== MIPI_READ_DATA[0] )	
;;;756    	////	{
;;;757    	//		LCD_DisplayStringLine_A(50,700,"VCOMDC PASS");
;;;758    	//	}
;;;759    	//	else
;;;760    	//	{
;;;761    	//	
;;;762    	//		LCD_DisplayStringLine_A(50,700,"VCOMDC NG");
;;;763    	//			while(1);
;;;764    	//	}
;;;765    	//		
;;;766    	FontR = FontG = FontB = 0;
0000ac  f8885000          STRB     r5,[r8,#0]
0000b0  703d              STRB     r5,[r7,#0]
0000b2  7035              STRB     r5,[r6,#0]
;;;767    	LCD_DisplayChinese(20,700,cfont,2);
0000b4  2302              MOVS     r3,#2
0000b6  4a1c              LDR      r2,|L35.296|
0000b8  f44f712f          MOV      r1,#0x2bc
0000bc  2014              MOVS     r0,#0x14
0000be  f7fffffe          BL       LCD_DisplayChinese
;;;768    
;;;769    	if(vcom==0x39)
;;;770    	{
;;;771    		FontR =255; FontG =0; FontB = 0;
0000c2  20ff              MOVS     r0,#0xff
0000c4  2c39              CMP      r4,#0x39              ;769
0000c6  d011              BEQ      |L35.236|
;;;772    		LCD_DisplayChinese(270,700,cfont2,2);
;;;773    	}
;;;774    	else
;;;775    	{
;;;776    		FontR =0; FontG =255; FontB = 0;
0000c8  7035              STRB     r5,[r6,#0]
0000ca  7038              STRB     r0,[r7,#0]
0000cc  f8885000          STRB     r5,[r8,#0]
;;;777    		LCD_DisplayChinese(270,700,cfont1,2);
0000d0  2302              MOVS     r3,#2
0000d2  4a16              LDR      r2,|L35.300|
0000d4  f44f712f          MOV      r1,#0x2bc
0000d8  f44f7087          MOV      r0,#0x10e
0000dc  f7fffffe          BL       LCD_DisplayChinese
                  |L35.224|
;;;778    	}
;;;779    	
;;;780    	FontR = FontG = FontB = 0;
0000e0  f8885000          STRB     r5,[r8,#0]
0000e4  703d              STRB     r5,[r7,#0]
0000e6  7035              STRB     r5,[r6,#0]
;;;781    	
;;;782    
;;;783    }
0000e8  e8bd9ff0          POP      {r4-r12,pc}
                  |L35.236|
0000ec  7030              STRB     r0,[r6,#0]            ;771
0000ee  703d              STRB     r5,[r7,#0]            ;771
0000f0  f8885000          STRB     r5,[r8,#0]            ;771
0000f4  2302              MOVS     r3,#2                 ;772
0000f6  4a0e              LDR      r2,|L35.304|
0000f8  f44f712f          MOV      r1,#0x2bc             ;772
0000fc  f44f7087          MOV      r0,#0x10e             ;772
000100  f7fffffe          BL       LCD_DisplayChinese
000104  e7ec              B        |L35.224|
;;;784    
                          ENDP

000106  0000              DCW      0x0000
                  |L35.264|
                          DCD      FontR
                  |L35.268|
                          DCD      FontG
                  |L35.272|
                          DCD      FontB
                  |L35.276|
                          DCD      ||.bss||
                  |L35.280|
000118  56434f4d          DCB      "VCOM",0
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L35.288|
                          DCD      0x40010808
                  |L35.292|
                          DCD      ||.data||
                  |L35.296|
                          DCD      ||.data||+0x28
                  |L35.300|
                          DCD      ||.data||+0x1c
                  |L35.304|
                          DCD      ||.data||+0x20

                          AREA ||i.showid_vcom_A||, CODE, READONLY, ALIGN=2

                  showid_vcom_A PROC
;;;785    
;;;786    void showid_vcom_A(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;787    {
;;;788    	
;;;789    
;;;790    
;;;791       while(ID_CHECK(20,700) == 1)
000004  f44f712f          MOV      r1,#0x2bc
000008  2014              MOVS     r0,#0x14
00000a  f7fffffe          BL       ID_CHECK
;;;792    	{
;;;793    		READ_ID++;
00000e  4d18              LDR      r5,|L36.112|
000010  2801              CMP      r0,#1                 ;791
000012  d118              BNE      |L36.70|
;;;794    		if(READ_ID >3)
;;;795    		{		while(1);	}
;;;796    
;;;797    //		temp = 1;
;;;798    //		temp = KEYA7;
;;;799    //		temp = 0 ;
;;;800    //
;;;801    //		if(temp == 0)
;;;802    //		{
;;;803    //			aat2 = 0;
;;;804    //			ENTER_LP_mode();
;;;805    //			MTP_ID();
;;;806    //			aat2 = 1;
;;;807    //		}
;;;808    
;;;809    		FontR = FontG = FontB = 0;
000014  4e17              LDR      r6,|L36.116|
000016  4f18              LDR      r7,|L36.120|
000018  f8df8060          LDR      r8,|L36.124|
00001c  2400              MOVS     r4,#0                 ;791
                  |L36.30|
00001e  7b28              LDRB     r0,[r5,#0xc]          ;793  ; READ_ID
000020  1c40              ADDS     r0,r0,#1              ;793
000022  b2c0              UXTB     r0,r0                 ;793
000024  7328              STRB     r0,[r5,#0xc]          ;793
000026  2803              CMP      r0,#3                 ;794
000028  d900              BLS      |L36.44|
                  |L36.42|
00002a  e7fe              B        |L36.42|
                  |L36.44|
00002c  7034              STRB     r4,[r6,#0]
00002e  703c              STRB     r4,[r7,#0]
000030  f8884000          STRB     r4,[r8,#0]
;;;810    		Soft_reset();
000034  f7fffffe          BL       Soft_reset
000038  f44f712f          MOV      r1,#0x2bc             ;791
00003c  2014              MOVS     r0,#0x14              ;791
00003e  f7fffffe          BL       ID_CHECK
000042  2801              CMP      r0,#1                 ;791
000044  d0eb              BEQ      |L36.30|
                  |L36.70|
;;;811    
;;;812    
;;;813    	}
;;;814    
;;;815    	Delay(10);						
000046  200a              MOVS     r0,#0xa
000048  f7fffffe          BL       Delay
;;;816    //	READ_IC_A(0XD9,0x00);
;;;817    
;;;818    	Delay(10);
00004c  200a              MOVS     r0,#0xa
00004e  f7fffffe          BL       Delay
;;;819       LCD_DisplayStringLine(100,600,"VCOM");
000052  a20b              ADR      r2,|L36.128|
000054  f44f7116          MOV      r1,#0x258
000058  2064              MOVS     r0,#0x64
00005a  f7fffffe          BL       LCD_DisplayStringLine
;;;820    //   SHOW_IC_VALUE_A(300,600,MIPI_READ_DATA[0]);
;;;821    	SHOW_IC_VALUE_A(300,600,VCOMDC);
00005e  792a              LDRB     r2,[r5,#4]  ; VCOMDC
000060  e8bd41f0          POP      {r4-r8,lr}
000064  f44f7116          MOV      r1,#0x258
000068  1048              ASRS     r0,r1,#1
00006a  f7ffbffe          B.W      SHOW_IC_VALUE_A
;;;822    //
;;;823    //  if(VCOMDC== MIPI_READ_DATA[0] )	
;;;824    //	{
;;;825    //		LCD_DisplayStringLine_A(50,700,"VCOMDC PASS");
;;;826    //	}
;;;827    //	else
;;;828    //	{
;;;829    //	
;;;830    //		LCD_DisplayStringLine_A(50,700,"VCOMDC NG");
;;;831    //			while(1);
;;;832    //	}
;;;833    //		
;;;834    
;;;835    
;;;836    
;;;837    
;;;838    }
;;;839    
                          ENDP

00006e  0000              DCW      0x0000
                  |L36.112|
                          DCD      ||.data||
                  |L36.116|
                          DCD      FontB
                  |L36.120|
                          DCD      FontG
                  |L36.124|
                          DCD      FontR
                  |L36.128|
000080  56434f4d          DCB      "VCOM",0
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MIPI_READ_DATA
                          %        12
                  SDCardInfo
                          %        80
                  DATA_SUM1
                          %        60
                  SURE
                          %        60

                          AREA ||area_number.39||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.39||, ||.bss||
                  DATA_SUMY
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  Status
000000  2a                DCB      0x2a
                  SDConfigFlag
000001  00                DCB      0x00
                  SDShowFlag
000002  01                DCB      0x01
                  SDShowTimes
000003  01                DCB      0x01
                  VCOMDC
000004  15                DCB      0x15
                  STEP
000005  18                DCB      0x18
                  OTP_VALUE1
000006  00                DCB      0x00
                  OTP_VALUE2
000007  00                DCB      0x00
                  OTP_TIMES
000008  00                DCB      0x00
                  OTP_TIMES_BEFORE
000009  00                DCB      0x00
                  ID_OK
00000a  01                DCB      0x01
                  temp
00000b  01                DCB      0x01
                  READ_ID
00000c  00                DCB      0x00
                  HSEStartUpStatus
00000d  00                DCB      0x00
                  count1
00000e  0000              DCW      0x0000
                  count2
000010  0000              DCW      0x0000
                  aat
000012  0000              DCW      0x0000
                  aat2
000014  0001              DCW      0x0001
                  VCOMDC1
000016  0000              DCW      0x0000
                  TimingDelay
                          DCD      0x00000000
                  cfont1
00001c  11131400          DCB      0x11,0x13,0x14,0x00
                  cfont2
000020  12131400          DCB      0x12,0x13,0x14,0x00
                  sd_Capacity
                          DCD      0x00000000
                  cfont
000028  0d0e0f10          DCB      0x0d,0x0e,0x0f,0x10
00002c  00                DCB      0x00

                          AREA ||area_number.42||, DATA, ALIGN=1

                          EXPORTAS ||area_number.42||, ||.data||
                  vcomdc_value
000000  0000              DCW      0x0000

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  VCOM1
000000  15                DCB      0x15

                          AREA ||area_number.44||, DATA, ALIGN=1

                          EXPORTAS ||area_number.44||, ||.data||
                  GPIO_InitStructure
                          DCDU     0x00000000

                  __ARM_use_no_argv EQU 0
