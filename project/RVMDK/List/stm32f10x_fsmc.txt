; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_fsmc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_fsmc.crf ..\..\library\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;744    *******************************************************************************/                   
;;;745    void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;746    {
;;;747     /* Check the parameters */
;;;748      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;749      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;750        
;;;751      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d008              BEQ      |L1.26|
;;;752      {
;;;753        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;754      }  
;;;755      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d009              BEQ      |L1.34|
;;;756      {
;;;757        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;758      }
;;;759      /* FSMC_Bank4_PCCARD*/
;;;760      else
;;;761      {
;;;762        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00000e  f8d200a4          LDR      r0,[r2,#0xa4]
000012  4388              BICS     r0,r0,r1
000014  f8c200a4          STR      r0,[r2,#0xa4]
;;;763      }
;;;764    }
000018  4770              BX       lr
                  |L1.26|
00001a  6e50              LDR      r0,[r2,#0x64]         ;753
00001c  4388              BICS     r0,r0,r1              ;753
00001e  6650              STR      r0,[r2,#0x64]         ;753
000020  4770              BX       lr
                  |L1.34|
000022  f8d20084          LDR      r0,[r2,#0x84]         ;757
000026  4388              BICS     r0,r0,r1              ;757
000028  f8c20084          STR      r0,[r2,#0x84]         ;757
00002c  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;835    *******************************************************************************/
;;;836    void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;840      assert_param(IS_FSMC_IT(FSMC_IT));
;;;841        
;;;842      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d009              BEQ      |L2.28|
;;;843      {
;;;844        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;845      }  
;;;846      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00b              BEQ      |L2.38|
;;;847      {
;;;848        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;849      }
;;;850      /* FSMC_Bank4_PCCARD*/
;;;851      else
;;;852      {
;;;853        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00000e  f8d200a4          LDR      r0,[r2,#0xa4]
000012  ea2000d1          BIC      r0,r0,r1,LSR #3
000016  f8c200a4          STR      r0,[r2,#0xa4]
;;;854      }
;;;855    }
00001a  4770              BX       lr
                  |L2.28|
00001c  6e50              LDR      r0,[r2,#0x64]         ;844
00001e  ea2000d1          BIC      r0,r0,r1,LSR #3       ;844
000022  6650              STR      r0,[r2,#0x64]         ;844
000024  4770              BX       lr
                  |L2.38|
000026  f8d20084          LDR      r0,[r2,#0x84]         ;848
00002a  ea2000d1          BIC      r0,r0,r1,LSR #3       ;848
00002e  f8c20084          STR      r0,[r2,#0x84]         ;848
000032  4770              BX       lr
;;;856    
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;593    *******************************************************************************/
;;;594    u32 FSMC_GetECC(u32 FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;595    {
;;;596      u32 eccval = 0x00000000;
;;;597      
;;;598      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
;;;599      {
;;;600        /* Get the ECCR2 register value */
;;;601        eccval = FSMC_Bank2->ECCR2;
000006  bf0c              ITE      EQ
000008  6f48              LDREQ    r0,[r1,#0x74]
;;;602      }
;;;603      else
;;;604      {
;;;605        /* Get the ECCR3 register value */
;;;606        eccval = FSMC_Bank3->ECCR3;
00000a  f8d10094          LDRNE    r0,[r1,#0x94]
;;;607      }
;;;608      /* Return the error correction code value */
;;;609      return(eccval);
;;;610    }
00000e  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;692    *******************************************************************************/                   
;;;693    FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG)
000000  2200              MOVS     r2,#0
;;;694    {
;;;695      FlagStatus bitstatus = RESET;
;;;696      u32 tmpsr = 0x00000000;
;;;697      
;;;698      /* Check the parameters */
;;;699      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;700      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;701      
;;;702      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;703      {
;;;704        tmpsr = FSMC_Bank2->SR2;
000002  f04f4320          MOV      r3,#0xa0000000
000006  2810              CMP      r0,#0x10              ;702
000008  bf08              IT       EQ
00000a  6e58              LDREQ    r0,[r3,#0x64]
00000c  d006              BEQ      |L4.28|
;;;705      }  
;;;706      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000e  f5b07f80          CMP      r0,#0x100
;;;707      {
;;;708        tmpsr = FSMC_Bank3->SR3;
000012  bf0c              ITE      EQ
000014  f8d30084          LDREQ    r0,[r3,#0x84]
;;;709      }
;;;710      /* FSMC_Bank4_PCCARD*/
;;;711      else
;;;712      {
;;;713        tmpsr = FSMC_Bank4->SR4;
000018  f8d300a4          LDRNE    r0,[r3,#0xa4]
                  |L4.28|
;;;714      } 
;;;715      
;;;716      /* Get the flag status */
;;;717      if ((tmpsr & FSMC_FLAG) != (u16)RESET )
00001c  4208              TST      r0,r1
;;;718      {
;;;719        bitstatus = SET;
00001e  bf18              IT       NE
000020  2201              MOVNE    r2,#1
;;;720      }
;;;721      else
;;;722      {
;;;723        bitstatus = RESET;
;;;724      }
;;;725      /* Return the flag status */
;;;726      return bitstatus;
000022  4610              MOV      r0,r2
;;;727    }
000024  4770              BX       lr
;;;728    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;781    *******************************************************************************/ 
;;;782    ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT)
000000  2200              MOVS     r2,#0
;;;783    {
;;;784      ITStatus bitstatus = RESET;
;;;785      u32 tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;786      
;;;787      /* Check the parameters */
;;;788      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;789      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;790      
;;;791      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;792      {
;;;793        tmpsr = FSMC_Bank2->SR2;
000002  f04f4320          MOV      r3,#0xa0000000
000006  2810              CMP      r0,#0x10              ;791
000008  bf08              IT       EQ
00000a  6e58              LDREQ    r0,[r3,#0x64]
00000c  d006              BEQ      |L5.28|
;;;794      }  
;;;795      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000e  f5b07f80          CMP      r0,#0x100
;;;796      {
;;;797        tmpsr = FSMC_Bank3->SR3;
000012  bf0c              ITE      EQ
000014  f8d30084          LDREQ    r0,[r3,#0x84]
;;;798      }
;;;799      /* FSMC_Bank4_PCCARD*/
;;;800      else
;;;801      {
;;;802        tmpsr = FSMC_Bank4->SR4;
000018  f8d300a4          LDRNE    r0,[r3,#0xa4]
                  |L5.28|
;;;803      } 
;;;804      
;;;805      itstatus = tmpsr & FSMC_IT;
00001c  4208              TST      r0,r1
;;;806      
;;;807      itenable = tmpsr & (FSMC_IT >> 3);
00001e  ea0000d1          AND      r0,r0,r1,LSR #3
;;;808    
;;;809      if ((itstatus != (u32)RESET)  && (itenable != (u32)RESET))
000022  bf1c              ITT      NE
000024  2800              CMPNE    r0,#0
;;;810      {
;;;811        bitstatus = SET;
000026  2201              MOVNE    r2,#1
;;;812      }
;;;813      else
;;;814      {
;;;815        bitstatus = RESET;
;;;816      }
;;;817      return bitstatus; 
000028  4610              MOV      r0,r2
;;;818    }
00002a  4770              BX       lr
;;;819    
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;630    *******************************************************************************/
;;;631    void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState)
000000  f04f4320          MOV      r3,#0xa0000000
;;;632    {
000004  b18a              CBZ      r2,|L6.42|
;;;633      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;634      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;635      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;636      
;;;637      if (NewState != DISABLE)
;;;638      {
;;;639        /* Enable the selected FSMC_Bank2 interrupts */
;;;640        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
;;;641        {
;;;642          FSMC_Bank2->SR2 |= FSMC_IT;
000008  bf04              ITT      EQ
00000a  6e58              LDREQ    r0,[r3,#0x64]
00000c  4308              ORREQ    r0,r0,r1
00000e  d01e              BEQ      |L6.78|
;;;643        }
;;;644        /* Enable the selected FSMC_Bank3 interrupts */
;;;645        else if (FSMC_Bank == FSMC_Bank3_NAND)
000010  f5b07f80          CMP      r0,#0x100
;;;646        {
;;;647          FSMC_Bank3->SR3 |= FSMC_IT;
000014  bf0c              ITE      EQ
000016  f8d30084          LDREQ    r0,[r3,#0x84]
;;;648        }
;;;649        /* Enable the selected FSMC_Bank4 interrupts */
;;;650        else
;;;651        {
;;;652          FSMC_Bank4->SR4 |= FSMC_IT;    
00001a  f8d300a4          LDRNE    r0,[r3,#0xa4]
00001e  ea400001          ORR      r0,r0,r1
000022  d011              BEQ      |L6.72|
                  |L6.36|
000024  f8c300a4          STR      r0,[r3,#0xa4]
;;;653        }
;;;654      }
;;;655      else
;;;656      {
;;;657        /* Disable the selected FSMC_Bank2 interrupts */
;;;658        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;659        {
;;;660          
;;;661          FSMC_Bank2->SR2 &= (u32)~FSMC_IT;
;;;662        }
;;;663        /* Disable the selected FSMC_Bank3 interrupts */
;;;664        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;665        {
;;;666          FSMC_Bank3->SR3 &= (u32)~FSMC_IT;
;;;667        }
;;;668        /* Disable the selected FSMC_Bank4 interrupts */
;;;669        else
;;;670        {
;;;671          FSMC_Bank4->SR4 &= (u32)~FSMC_IT;    
;;;672        }
;;;673      }
;;;674    }
000028  4770              BX       lr
                  |L6.42|
00002a  2810              CMP      r0,#0x10              ;658
00002c  bf04              ITT      EQ                    ;661
00002e  6e58              LDREQ    r0,[r3,#0x64]         ;661
000030  4388              BICEQ    r0,r0,r1              ;661
000032  d00c              BEQ      |L6.78|
000034  f5b07f80          CMP      r0,#0x100             ;664
000038  bf0c              ITE      EQ                    ;666
00003a  f8d30084          LDREQ    r0,[r3,#0x84]         ;666
00003e  f8d300a4          LDRNE    r0,[r3,#0xa4]         ;671
000042  ea200001          BIC      r0,r0,r1              ;671
000046  d1ed              BNE      |L6.36|
                  |L6.72|
000048  f8c30084          STR      r0,[r3,#0x84]         ;647
00004c  4770              BX       lr
                  |L6.78|
00004e  6658              STR      r0,[r3,#0x64]         ;642
000050  4770              BX       lr
;;;675                      
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;485    *******************************************************************************/
;;;486    void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;487    {
000004  b151              CBZ      r1,|L7.28|
;;;488      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;490      
;;;491      if (NewState != DISABLE)
;;;492      {
;;;493        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;494        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
;;;495        {
;;;496          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
000008  bf0c              ITE      EQ
00000a  6e10              LDREQ    r0,[r2,#0x60]
;;;497        }
;;;498        else
;;;499        {
;;;500          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
00000c  f8d20080          LDRNE    r0,[r2,#0x80]
000010  f0400004          ORR      r0,r0,#4
000014  d00b              BEQ      |L7.46|
                  |L7.22|
000016  f8c20080          STR      r0,[r2,#0x80]
;;;501        }
;;;502      }
;;;503      else
;;;504      {
;;;505        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;506        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;507        {
;;;508          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
;;;509        }
;;;510        else
;;;511        {
;;;512          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
;;;513        }
;;;514      }
;;;515    }
00001a  4770              BX       lr
                  |L7.28|
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;506
000020  bf14              ITE      NE                    ;512
000022  f8d20080          LDRNE    r0,[r2,#0x80]         ;512
000026  6e10              LDREQ    r0,[r2,#0x60]         ;508
000028  ea000001          AND      r0,r0,r1              ;508
00002c  d1f3              BNE      |L7.22|
                  |L7.46|
00002e  6610              STR      r0,[r2,#0x60]         ;496
000030  4770              BX       lr
;;;516    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;83     *******************************************************************************/
;;;84     void FSMC_NANDDeInit(u32 FSMC_Bank)
000000  2340              MOVS     r3,#0x40
;;;85     {
;;;86       /* Check the parameter */
;;;87       assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;88       
;;;89       if(FSMC_Bank == FSMC_Bank2_NAND)
;;;90       {
;;;91         /* Set the FSMC_Bank2 registers to their reset values */
;;;92         FSMC_Bank2->PCR2 = 0x00000018;
000002  f04f0c18          MOV      r12,#0x18
000006  f04f4120          MOV      r1,#0xa0000000
;;;93         FSMC_Bank2->SR2 = 0x00000040;
;;;94         FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;89
000010  d008              BEQ      |L8.36|
;;;95         FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;96       }
;;;97       /* FSMC_Bank3_NAND */  
;;;98       else
;;;99       {
;;;100        /* Set the FSMC_Bank3 registers to their reset values */
;;;101        FSMC_Bank3->PCR3 = 0x00000018;
000012  f8c1c080          STR      r12,[r1,#0x80]
;;;102        FSMC_Bank3->SR3 = 0x00000040;
000016  f8c13084          STR      r3,[r1,#0x84]
;;;103        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
00001a  f8c12088          STR      r2,[r1,#0x88]
;;;104        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001e  f8c1208c          STR      r2,[r1,#0x8c]
;;;105      }  
;;;106    }
000022  4770              BX       lr
                  |L8.36|
000024  f8c1c060          STR      r12,[r1,#0x60]        ;92
000028  664b              STR      r3,[r1,#0x64]         ;93
00002a  668a              STR      r2,[r1,#0x68]         ;94
00002c  66ca              STR      r2,[r1,#0x6c]         ;95
00002e  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;552    *******************************************************************************/
;;;553    void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;554    {
000004  b151              CBZ      r1,|L9.28|
;;;555      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;556      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;557      
;;;558      if (NewState != DISABLE)
;;;559      {
;;;560        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;561        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
;;;562        {
;;;563          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
000008  bf0c              ITE      EQ
00000a  6e10              LDREQ    r0,[r2,#0x60]
;;;564        }
;;;565        else
;;;566        {
;;;567          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
00000c  f8d20080          LDRNE    r0,[r2,#0x80]
000010  f0400040          ORR      r0,r0,#0x40
000014  d00b              BEQ      |L9.46|
                  |L9.22|
000016  f8c20080          STR      r0,[r2,#0x80]
;;;568        }
;;;569      }
;;;570      else
;;;571      {
;;;572        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;573        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;574        {
;;;575          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
;;;576        }
;;;577        else
;;;578        {
;;;579          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
;;;580        }
;;;581      }
;;;582    }
00001a  4770              BX       lr
                  |L9.28|
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;573
000020  bf14              ITE      NE                    ;579
000022  f8d20080          LDRNE    r0,[r2,#0x80]         ;579
000026  6e10              LDREQ    r0,[r2,#0x60]         ;575
000028  ea000001          AND      r0,r0,r1              ;575
00002c  d1f3              BNE      |L9.22|
                  |L9.46|
00002e  6610              STR      r0,[r2,#0x60]         ;563
000030  4770              BX       lr
;;;583    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDInit PROC
;;;223    *******************************************************************************/
;;;224    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b410              PUSH     {r4}
;;;225    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;226      u32 tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;227        
;;;228      /* Check the parameters */
;;;229      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;230      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;231      assert_param( IS_FSMC_DATA_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;232      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;233      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;234      assert_param( IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_NANDInitStruct->FSMC_AddressLowMapping));
;;;235      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;236      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;237    
;;;238      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;239      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;240      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;241      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;242    
;;;243      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;244      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;245      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;246      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;247      
;;;248      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;249      tmppcr = (u32)FSMC_NANDInitStruct->FSMC_Waitfeature |
000006  430a              ORRS     r2,r2,r1
000008  e9d01303          LDRD     r1,r3,[r0,#0xc]
00000c  4319              ORRS     r1,r1,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  4311              ORRS     r1,r1,r2
000014  6982              LDR      r2,[r0,#0x18]
000016  ea412142          ORR      r1,r1,r2,LSL #9
00001a  69c2              LDR      r2,[r0,#0x1c]
00001c  ea413142          ORR      r1,r1,r2,LSL #13
000020  f0410208          ORR      r2,r1,#8
;;;250                PCR_MemoryType_NAND |
;;;251                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;252                FSMC_NANDInitStruct->FSMC_ECC |
;;;253                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;254                FSMC_NANDInitStruct->FSMC_AddressLowMapping |
;;;255                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;256                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;257                
;;;258      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;259      tmppmem = (u32)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000024  6a01              LDR      r1,[r0,#0x20]
000026  e9d13c00          LDRD     r3,r12,[r1,#0]
00002a  ea43230c          ORR      r3,r3,r12,LSL #8
00002e  f8b1c008          LDRH     r12,[r1,#8]
000032  7b09              LDRB     r1,[r1,#0xc]
000034  ea4f4c0c          LSL      r12,r12,#16
000038  ea4c6101          ORR      r1,r12,r1,LSL #24
00003c  430b              ORRS     r3,r3,r1
;;;260                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;261                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;262                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;263                
;;;264      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;265      tmppatt = (u32)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
00003e  6a41              LDR      r1,[r0,#0x24]
000040  e9d1c400          LDRD     r12,r4,[r1,#0]
000044  ea4c2c04          ORR      r12,r12,r4,LSL #8
000048  890c              LDRH     r4,[r1,#8]
00004a  7b09              LDRB     r1,[r1,#0xc]
00004c  0424              LSLS     r4,r4,#16
00004e  ea446101          ORR      r1,r4,r1,LSL #24
000052  ea4c0101          ORR      r1,r12,r1
;;;266                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;267                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;268                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;269      
;;;270      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;271      {
;;;272        /* FSMC_Bank2_NAND registers configuration */
;;;273        FSMC_Bank2->PCR2 = tmppcr;
000056  f8d0c000          LDR      r12,[r0,#0]
00005a  f04f4020          MOV      r0,#0xa0000000
00005e  f1bc0f10          CMP      r12,#0x10             ;270
000062  d007              BEQ      |L10.116|
;;;274        FSMC_Bank2->PMEM2 = tmppmem;
;;;275        FSMC_Bank2->PATT2 = tmppatt;
;;;276      }
;;;277      else
;;;278      {
;;;279        /* FSMC_Bank3_NAND registers configuration */
;;;280        FSMC_Bank3->PCR3 = tmppcr;
000064  f8c02080          STR      r2,[r0,#0x80]
;;;281        FSMC_Bank3->PMEM3 = tmppmem;
000068  f8c03088          STR      r3,[r0,#0x88]
;;;282        FSMC_Bank3->PATT3 = tmppatt;
00006c  f8c0108c          STR      r1,[r0,#0x8c]
;;;283      }
;;;284    }
000070  bc10              POP      {r4}
000072  4770              BX       lr
                  |L10.116|
000074  6602              STR      r2,[r0,#0x60]         ;273
000076  6683              STR      r3,[r0,#0x68]         ;274
000078  66c1              STR      r1,[r0,#0x6c]         ;275
00007a  bc10              POP      {r4}
00007c  4770              BX       lr
;;;285    
                          ENDP


                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;392    *******************************************************************************/
;;;393    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;394    { 
;;;395      /* Reset NAND Init structure parameters values */
;;;396      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;397      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;398      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;399      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;400      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;401      FSMC_NANDInitStruct->FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
00000c  6101              STR      r1,[r0,#0x10]
;;;402      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;403      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
000010  6181              STR      r1,[r0,#0x18]
;;;404      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000012  61c1              STR      r1,[r0,#0x1c]
000014  6a02              LDR      r2,[r0,#0x20]
000016  21fc              MOVS     r1,#0xfc
;;;405      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000018  6011              STR      r1,[r2,#0]
00001a  6a02              LDR      r2,[r0,#0x20]
;;;406      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001c  6051              STR      r1,[r2,#4]
00001e  6a02              LDR      r2,[r0,#0x20]
;;;407      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000020  6091              STR      r1,[r2,#8]
000022  6a02              LDR      r2,[r0,#0x20]
;;;408      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000024  60d1              STR      r1,[r2,#0xc]
000026  6a42              LDR      r2,[r0,#0x24]
;;;409      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000028  6011              STR      r1,[r2,#0]
00002a  6a42              LDR      r2,[r0,#0x24]
;;;410      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002c  6051              STR      r1,[r2,#4]
00002e  6a42              LDR      r2,[r0,#0x24]
;;;411      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
000030  6091              STR      r1,[r2,#8]
000032  6a40              LDR      r0,[r0,#0x24]
000034  60c1              STR      r1,[r0,#0xc]
;;;412    }
000036  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;456    *******************************************************************************/
;;;457    void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState)
000000  0080              LSLS     r0,r0,#2
;;;458    {
;;;459      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;460      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;461      
;;;462      if (NewState != DISABLE)
;;;463      {
;;;464        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;465        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
000002  f1a040c0          SUB      r0,r0,#0x60000000
000006  2900              CMP      r1,#0                 ;462
;;;466      }
;;;467      else
;;;468      {
;;;469        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;470        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
000008  6801              LDR      r1,[r0,#0]
00000a  bf12              ITEE     NE                    ;465
00000c  f0410101          ORRNE    r1,r1,#1              ;465
000010  4a01              LDREQ    r2,|L12.24|
000012  4011              ANDEQ    r1,r1,r2
000014  6001              STR      r1,[r0,#0]            ;465
;;;471      }
;;;472    }
000016  4770              BX       lr
;;;473    
                          ENDP

                  |L12.24|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;52     *******************************************************************************/
;;;53     void FSMC_NORSRAMDeInit(u32 FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;54     {
;;;55       /* Check the parameter */
;;;56       assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;57       
;;;58       /* FSMC_Bank1_NORSRAM1 */
;;;59       if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;60       {
;;;61         FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;62       }
;;;63       /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;64       else
;;;65       {   
;;;66         FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  2800              CMP      r0,#0                 ;59
000008  bf03              ITTTE    EQ                    ;61
00000a  f24300db          MOVEQ    r0,#0x30db            ;61
00000e  f04f4220          MOVEQ    r2,#0xa0000000        ;61
000012  6010              STREQ    r0,[r2,#0]            ;61
000014  f24300d2          MOVNE    r0,#0x30d2
000018  bf18              IT       NE
00001a  6008              STRNE    r0,[r1,#0]
;;;67       }
;;;68     
;;;69       FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4070          MVN      r0,#0xf0000000
000020  6048              STR      r0,[r1,#4]
;;;70       FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000022  f8c10104          STR      r0,[r1,#0x104]
;;;71     }
000026  4770              BX       lr
;;;72     
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;135    *******************************************************************************/
;;;136    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  e9d01201          LDRD     r1,r2,[r0,#4]
;;;137    { 
;;;138      /* Check the parameters */
;;;139      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;140      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;141      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;142      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;143      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;144      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;145      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;146      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;147      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;148      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;149      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;150      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;151      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;152      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;153      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;154      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;155      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;156      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;157      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;158      
;;;159      /* Bank1 NOR/SRAM control register configuration */ 
;;;160      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000004  4311              ORRS     r1,r1,r2
000006  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000a  431a              ORRS     r2,r2,r3
00000c  4311              ORRS     r1,r1,r2
00000e  6942              LDR      r2,[r0,#0x14]
000010  4311              ORRS     r1,r1,r2
000012  6982              LDR      r2,[r0,#0x18]
000014  4311              ORRS     r1,r1,r2
000016  69c2              LDR      r2,[r0,#0x1c]
000018  4311              ORRS     r1,r1,r2
00001a  6a02              LDR      r2,[r0,#0x20]
00001c  4311              ORRS     r1,r1,r2
00001e  6a42              LDR      r2,[r0,#0x24]
000020  4311              ORRS     r1,r1,r2
000022  6a82              LDR      r2,[r0,#0x28]
000024  4311              ORRS     r1,r1,r2
000026  6ac2              LDR      r2,[r0,#0x2c]
000028  430a              ORRS     r2,r2,r1
00002a  6801              LDR      r1,[r0,#0]
00002c  0089              LSLS     r1,r1,#2
00002e  f1a141c0          SUB      r1,r1,#0x60000000
000032  600a              STR      r2,[r1,#0]
;;;161                (u32)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;162                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;163                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;164                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;165                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;166                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;167                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;168                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;169                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;170                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;171                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;172    
;;;173      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000034  6881              LDR      r1,[r0,#8]
000036  2908              CMP      r1,#8
000038  d107              BNE      |L14.74|
;;;174      {
;;;175        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (u32)BCR_FACCEN_Set;
00003a  6801              LDR      r1,[r0,#0]
00003c  0089              LSLS     r1,r1,#2
00003e  f1a141c0          SUB      r1,r1,#0x60000000
000042  680a              LDR      r2,[r1,#0]
000044  f0420240          ORR      r2,r2,#0x40
000048  600a              STR      r2,[r1,#0]
                  |L14.74|
;;;176      }
;;;177    
;;;178      /* Bank1 NOR/SRAM timing register configuration */
;;;179      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
00004a  6b01              LDR      r1,[r0,#0x30]
00004c  e9d12300          LDRD     r2,r3,[r1,#0]
000050  ea421203          ORR      r2,r2,r3,LSL #4
000054  688b              LDR      r3,[r1,#8]
000056  f8b1c00c          LDRH     r12,[r1,#0xc]
00005a  021b              LSLS     r3,r3,#8
00005c  ea43430c          ORR      r3,r3,r12,LSL #16
000060  431a              ORRS     r2,r2,r3
000062  8a0b              LDRH     r3,[r1,#0x10]
000064  ea425203          ORR      r2,r2,r3,LSL #20
000068  7d0b              LDRB     r3,[r1,#0x14]
00006a  6989              LDR      r1,[r1,#0x18]
00006c  ea426203          ORR      r2,r2,r3,LSL #24
000070  4311              ORRS     r1,r1,r2
000072  6802              LDR      r2,[r0,#0]
000074  0092              LSLS     r2,r2,#2
000076  f1a242c0          SUB      r2,r2,#0x60000000
00007a  6051              STR      r1,[r2,#4]
;;;180                (u32)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;181                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;182                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;183                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;184                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;185                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;186                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;187                
;;;188    
;;;189        
;;;190      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;191      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
00007c  6a81              LDR      r1,[r0,#0x28]
00007e  f5b14f80          CMP      r1,#0x4000
000082  d008              BEQ      |L14.150|
;;;192      {
;;;193        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;194        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;195        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;196        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;197        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;198        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;199    
;;;200        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;201                  (u32)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;202                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;203                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;204                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;205                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;206                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;207      }
;;;208      else
;;;209      {
;;;210        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000084  6800              LDR      r0,[r0,#0]
000086  f06f4170          MVN      r1,#0xf0000000
00008a  0080              LSLS     r0,r0,#2
00008c  f1a040c0          SUB      r0,r0,#0x60000000
000090  f8c01104          STR      r1,[r0,#0x104]
;;;211      }
;;;212    }
000094  4770              BX       lr
                  |L14.150|
000096  6b41              LDR      r1,[r0,#0x34]         ;200
000098  e9d12300          LDRD     r2,r3,[r1,#0]         ;200
00009c  ea421203          ORR      r2,r2,r3,LSL #4       ;200
0000a0  688b              LDR      r3,[r1,#8]            ;200
0000a2  f8b1c010          LDRH     r12,[r1,#0x10]        ;200
0000a6  021b              LSLS     r3,r3,#8              ;200
0000a8  ea43530c          ORR      r3,r3,r12,LSL #20     ;200
0000ac  431a              ORRS     r2,r2,r3              ;200
0000ae  7d0b              LDRB     r3,[r1,#0x14]         ;200
0000b0  6989              LDR      r1,[r1,#0x18]         ;200
0000b2  ea426203          ORR      r2,r2,r3,LSL #24      ;200
0000b6  6800              LDR      r0,[r0,#0]            ;200
0000b8  4311              ORRS     r1,r1,r2              ;200
0000ba  0080              LSLS     r0,r0,#2              ;200
0000bc  f1a040c0          SUB      r0,r0,#0x60000000     ;200
0000c0  f8c01104          STR      r1,[r0,#0x104]        ;200
0000c4  4770              BX       lr
;;;213    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMStructInit PROC
;;;353    *******************************************************************************/
;;;354    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;355    {  
;;;356      /* Reset NOR/SRAM Init structure parameters values */
;;;357      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
;;;358      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000002  2202              MOVS     r2,#2
000004  e9c01200          STRD     r1,r2,[r0,#0]
;;;359      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;360      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000008  6081              STR      r1,[r0,#8]
;;;361      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
;;;362      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00000c  6101              STR      r1,[r0,#0x10]
;;;363      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
00000e  6141              STR      r1,[r0,#0x14]
;;;364      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;365      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000010  02d2              LSLS     r2,r2,#11
000012  6181              STR      r1,[r0,#0x18]
000014  e9c01207          STRD     r1,r2,[r0,#0x1c]
;;;366      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
000018  0052              LSLS     r2,r2,#1
00001a  e9c02109          STRD     r2,r1,[r0,#0x24]
;;;367      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;368      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;369      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
00001e  62c1              STR      r1,[r0,#0x2c]
000020  6b03              LDR      r3,[r0,#0x30]
000022  220f              MOVS     r2,#0xf
;;;370      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000024  601a              STR      r2,[r3,#0]
000026  6b03              LDR      r3,[r0,#0x30]
;;;371      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000028  605a              STR      r2,[r3,#4]
00002a  f8d0c030          LDR      r12,[r0,#0x30]
00002e  23ff              MOVS     r3,#0xff
;;;372      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000030  f8cc3008          STR      r3,[r12,#8]
000034  f8d0c030          LDR      r12,[r0,#0x30]
;;;373      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000038  f8cc200c          STR      r2,[r12,#0xc]
00003c  f8d0c030          LDR      r12,[r0,#0x30]
;;;374      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
000040  f8cc2010          STR      r2,[r12,#0x10]
000044  f8d0c030          LDR      r12,[r0,#0x30]
;;;375      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
000048  f8cc2014          STR      r2,[r12,#0x14]
00004c  f8d0c030          LDR      r12,[r0,#0x30]
;;;376      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000050  f8cc1018          STR      r1,[r12,#0x18]
000054  f8d0c034          LDR      r12,[r0,#0x34]
;;;377      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000058  f8cc2000          STR      r2,[r12,#0]
00005c  f8d0c034          LDR      r12,[r0,#0x34]
;;;378      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000060  f8cc2004          STR      r2,[r12,#4]
000064  f8d0c034          LDR      r12,[r0,#0x34]
;;;379      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000068  f8cc3008          STR      r3,[r12,#8]
00006c  6b43              LDR      r3,[r0,#0x34]
;;;380      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
00006e  60da              STR      r2,[r3,#0xc]
000070  6b43              LDR      r3,[r0,#0x34]
;;;381      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000072  611a              STR      r2,[r3,#0x10]
000074  6b43              LDR      r3,[r0,#0x34]
;;;382      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
000076  615a              STR      r2,[r3,#0x14]
000078  6b40              LDR      r0,[r0,#0x34]
00007a  6181              STR      r1,[r0,#0x18]
;;;383    }
00007c  4770              BX       lr
;;;384    
                          ENDP


                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;524    *******************************************************************************/
;;;525    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  f04f4120          MOV      r1,#0xa0000000
;;;526    {
;;;527      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;528      
;;;529      if (NewState != DISABLE)
000004  2800              CMP      r0,#0
;;;530      {
;;;531        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;532        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
000006  bf19              ITTEE    NE
000008  f8d100a0          LDRNE    r0,[r1,#0xa0]
00000c  f0400004          ORRNE    r0,r0,#4
;;;533      }
;;;534      else
;;;535      {
;;;536        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;537        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
000010  f8d120a0          LDREQ    r2,[r1,#0xa0]
000014  4802              LDREQ    r0,|L16.32|
000016  bf08              IT       EQ
000018  4010              ANDEQ    r0,r0,r2
00001a  f8c100a0          STR      r0,[r1,#0xa0]         ;532
;;;538      }
;;;539    }
00001e  4770              BX       lr
;;;540    
                          ENDP

                  |L16.32|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDDeInit PROC
;;;115    *******************************************************************************/
;;;116    void FSMC_PCCARDDeInit(void)
000000  f04f4020          MOV      r0,#0xa0000000
;;;117    {
;;;118      /* Set the FSMC_Bank4 registers to their reset values */
;;;119      FSMC_Bank4->PCR4 = 0x00000018; 
000004  2118              MOVS     r1,#0x18
000006  f8401fa0          STR      r1,[r0,#0xa0]!
;;;120      FSMC_Bank4->SR4 = 0x00000000;	
00000a  2100              MOVS     r1,#0
00000c  6041              STR      r1,[r0,#4]
;;;121      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000e  f04f31fc          MOV      r1,#0xfcfcfcfc
000012  6081              STR      r1,[r0,#8]
;;;122      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000014  60c1              STR      r1,[r0,#0xc]
;;;123      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000016  6101              STR      r1,[r0,#0x10]
;;;124    }
000018  4770              BX       lr
;;;125    
                          ENDP


                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDInit PROC
;;;295    *******************************************************************************/
;;;296    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  e9d01200          LDRD     r1,r2,[r0,#0]
;;;297    {
;;;298      /* Check the parameters */
;;;299      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;300      assert_param(IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_PCCARDInitStruct->FSMC_AddressLowMapping));
;;;301      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;302      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;303    
;;;304     
;;;305      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;306      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;307      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;308      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;309      
;;;310      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;311      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;312      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;313      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;314    
;;;315      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;316      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;317      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;318      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;319      
;;;320      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;321      FSMC_Bank4->PCR4 = (u32)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000004  4311              ORRS     r1,r1,r2
000006  6882              LDR      r2,[r0,#8]
000008  68c3              LDR      r3,[r0,#0xc]
00000a  0252              LSLS     r2,r2,#9
00000c  ea423243          ORR      r2,r2,r3,LSL #13
000010  4311              ORRS     r1,r1,r2
000012  f04f4220          MOV      r2,#0xa0000000
000016  f0410110          ORR      r1,r1,#0x10
00001a  f8421fa0          STR      r1,[r2,#0xa0]!
;;;322                         FSMC_MemoryDataWidth_16b |  
;;;323                         FSMC_PCCARDInitStruct->FSMC_AddressLowMapping |
;;;324                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;325                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;326                
;;;327      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;328      FSMC_Bank4->PMEM4 = (u32)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00001e  6901              LDR      r1,[r0,#0x10]
000020  e9d13c00          LDRD     r3,r12,[r1,#0]
000024  ea43230c          ORR      r3,r3,r12,LSL #8
000028  f8b1c008          LDRH     r12,[r1,#8]
00002c  7b09              LDRB     r1,[r1,#0xc]
00002e  ea4f4c0c          LSL      r12,r12,#16
000032  ea4c6101          ORR      r1,r12,r1,LSL #24
000036  4319              ORRS     r1,r1,r3
000038  6091              STR      r1,[r2,#8]
;;;329                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;330                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;331                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;332                
;;;333      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;334      FSMC_Bank4->PATT4 = (u32)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
00003a  6941              LDR      r1,[r0,#0x14]
00003c  e9d13c00          LDRD     r3,r12,[r1,#0]
000040  ea43230c          ORR      r3,r3,r12,LSL #8
000044  f8b1c008          LDRH     r12,[r1,#8]
000048  7b09              LDRB     r1,[r1,#0xc]
00004a  ea4f4c0c          LSL      r12,r12,#16
00004e  ea4c6101          ORR      r1,r12,r1,LSL #24
000052  4319              ORRS     r1,r1,r3
000054  60d1              STR      r1,[r2,#0xc]
;;;335                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;336                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;337                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;338                
;;;339      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;340      FSMC_Bank4->PIO4 = (u32)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000056  6980              LDR      r0,[r0,#0x18]
000058  e9d01300          LDRD     r1,r3,[r0,#0]
00005c  ea412103          ORR      r1,r1,r3,LSL #8
000060  8903              LDRH     r3,[r0,#8]
000062  7b00              LDRB     r0,[r0,#0xc]
000064  041b              LSLS     r3,r3,#16
000066  ea436000          ORR      r0,r3,r0,LSL #24
00006a  4308              ORRS     r0,r0,r1
00006c  6110              STR      r0,[r2,#0x10]
;;;341                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;342                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;343                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;344    }
00006e  4770              BX       lr
;;;345    
                          ENDP


                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;421    *******************************************************************************/
;;;422    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;423    {
;;;424      /* Reset PCCARD Init structure parameters values */
;;;425      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;426      FSMC_PCCARDInitStruct->FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
000002  6001              STR      r1,[r0,#0]
;;;427      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;428      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000006  6081              STR      r1,[r0,#8]
;;;429      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000008  60c1              STR      r1,[r0,#0xc]
00000a  6902              LDR      r2,[r0,#0x10]
00000c  21fc              MOVS     r1,#0xfc
;;;430      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000e  6011              STR      r1,[r2,#0]
000010  6902              LDR      r2,[r0,#0x10]
;;;431      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000012  6051              STR      r1,[r2,#4]
000014  6902              LDR      r2,[r0,#0x10]
;;;432      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000016  6091              STR      r1,[r2,#8]
000018  6902              LDR      r2,[r0,#0x10]
;;;433      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00001a  60d1              STR      r1,[r2,#0xc]
00001c  6942              LDR      r2,[r0,#0x14]
;;;434      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001e  6011              STR      r1,[r2,#0]
000020  6942              LDR      r2,[r0,#0x14]
;;;435      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000022  6051              STR      r1,[r2,#4]
000024  6942              LDR      r2,[r0,#0x14]
;;;436      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000026  6091              STR      r1,[r2,#8]
000028  6942              LDR      r2,[r0,#0x14]
;;;437      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00002a  60d1              STR      r1,[r2,#0xc]
00002c  6982              LDR      r2,[r0,#0x18]
;;;438      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002e  6011              STR      r1,[r2,#0]
000030  6982              LDR      r2,[r0,#0x18]
;;;439      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000032  6051              STR      r1,[r2,#4]
000034  6982              LDR      r2,[r0,#0x18]
;;;440      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000036  6091              STR      r1,[r2,#8]
000038  6980              LDR      r0,[r0,#0x18]
00003a  60c1              STR      r1,[r0,#0xc]
;;;441    }
00003c  4770              BX       lr
;;;442    
                          ENDP

