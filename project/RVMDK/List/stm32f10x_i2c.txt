; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_i2c.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_i2c.crf ..\..\library\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;817    *******************************************************************************/
;;;818    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;819    {
;;;820      /* Check the parameters */
;;;821      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;822      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;823    
;;;824      if (NewState != DISABLE)
;;;825      {
;;;826        /* Enable the selected I2C ARP */
;;;827        I2Cx->CR1 |= CR1_ENARP_Set;
;;;828      }
;;;829      else
;;;830      {
;;;831        /* Disable the selected I2C ARP */
;;;832        I2Cx->CR1 &= CR1_ENARP_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;827
000006  f0410110          ORRNE    r1,r1,#0x10           ;827
00000a  f0210110          BICEQ    r1,r1,#0x10
00000e  8001              STRH     r1,[r0,#0]            ;827
;;;833      }
;;;834    }
000010  4770              BX       lr
;;;835    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;425    *******************************************************************************/
;;;426    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;427    {
;;;428      /* Check the parameters */
;;;429      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;430      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;431    
;;;432      if (NewState != DISABLE)
;;;433      {
;;;434        /* Enable the acknowledgement */
;;;435        I2Cx->CR1 |= CR1_ACK_Set;
;;;436      }
;;;437      else
;;;438      {
;;;439        /* Disable the acknowledgement */
;;;440        I2Cx->CR1 &= CR1_ACK_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;435
000006  f4416180          ORRNE    r1,r1,#0x400          ;435
00000a  f4216180          BICEQ    r1,r1,#0x400
00000e  8001              STRH     r1,[r0,#0]            ;435
;;;441      }
;;;442    }
000010  4770              BX       lr
;;;443    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;774    *******************************************************************************/
;;;775    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;776    {
;;;777      /* Check the parameters */
;;;778      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;779      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;780    
;;;781      if (NewState != DISABLE)
;;;782      {
;;;783        /* Enable the selected I2C PEC calculation */
;;;784        I2Cx->CR1 |= CR1_ENPEC_Set;
;;;785      }
;;;786      else
;;;787      {
;;;788        /* Disable the selected I2C PEC calculation */
;;;789        I2Cx->CR1 &= CR1_ENPEC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;784
000006  f0410120          ORRNE    r1,r1,#0x20           ;784
00000a  f0210120          BICEQ    r1,r1,#0x20
00000e  8001              STRH     r1,[r0,#0]            ;784
;;;790      }
;;;791    }
000010  4770              BX       lr
;;;792    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;940    *******************************************************************************/
;;;941    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
000000  8a83              LDRH     r3,[r0,#0x14]
;;;942    {
;;;943      u32 lastevent = 0;
;;;944      u32 flag1 = 0, flag2 = 0;
;;;945      ErrorStatus status = ERROR;
000002  2200              MOVS     r2,#0
;;;946    
;;;947      /* Check the parameters */
;;;948      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;949      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;950    
;;;951      /* Read the I2Cx status register */
;;;952      flag1 = I2Cx->SR1;
;;;953      flag2 = I2Cx->SR2;
000004  8b00              LDRH     r0,[r0,#0x18]
;;;954      flag2 = flag2 << 16;
;;;955    
;;;956      /* Get the last event value from I2C status register */
;;;957      lastevent = (flag1 | flag2) & FLAG_Mask;
000006  ea434000          ORR      r0,r3,r0,LSL #16
00000a  f020407f          BIC      r0,r0,#0xff000000
;;;958    
;;;959      /* Check whether the last event is equal to I2C_EVENT */
;;;960      if (lastevent == I2C_EVENT )
00000e  4288              CMP      r0,r1
;;;961      {
;;;962        /* SUCCESS: last event is equal to I2C_EVENT */
;;;963        status = SUCCESS;
000010  bf08              IT       EQ
000012  2201              MOVEQ    r2,#1
;;;964      }
;;;965      else
;;;966      {
;;;967        /* ERROR: last event is different from I2C_EVENT */
;;;968        status = ERROR;
;;;969      }
;;;970    
;;;971      /* Return status */
;;;972      return status;
000014  4610              MOV      r0,r2
;;;973    }
000016  4770              BX       lr
;;;974    
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1091   *******************************************************************************/
;;;1092   void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1093   {
;;;1094     u32 flagpos = 0;
;;;1095   
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1098     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1099   
;;;1100     /* Get the I2C flag position */
;;;1101     flagpos = I2C_FLAG & FLAG_Mask;
;;;1102   
;;;1103     /* Clear the selected I2C flag */
;;;1104     I2Cx->SR1 = (u16)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1105   }
000004  4770              BX       lr
;;;1106   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1200   *******************************************************************************/
;;;1201   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1202   {
;;;1203     u32 flagpos = 0;
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1207     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1208   
;;;1209     /* Get the I2C flag position */
;;;1210     flagpos = I2C_IT & FLAG_Mask;
;;;1211   
;;;1212     /* Clear the selected I2C flag */
;;;1213     I2Cx->SR1 = (u16)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1214   }
000004  4770              BX       lr
;;;1215   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;290    *******************************************************************************/
;;;291    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;292    {
;;;293      /* Check the parameters */
;;;294      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;295      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;296    
;;;297      if (NewState != DISABLE)
;;;298      {
;;;299        /* Enable the selected I2C peripheral */
;;;300        I2Cx->CR1 |= CR1_PE_Set;
;;;301      }
;;;302      else
;;;303      {
;;;304        /* Disable the selected I2C peripheral */
;;;305        I2Cx->CR1 &= CR1_PE_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;300
000006  f0410101          ORRNE    r1,r1,#1              ;300
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8001              STRH     r1,[r0,#0]            ;300
;;;306      }
;;;307    }
000010  4770              BX       lr
;;;308    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;317    *******************************************************************************/
;;;318    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;322      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;323    
;;;324      if (NewState != DISABLE)
;;;325      {
;;;326        /* Enable the selected I2C DMA requests */
;;;327        I2Cx->CR2 |= CR2_DMAEN_Set;
;;;328      }
;;;329      else
;;;330      {
;;;331        /* Disable the selected I2C DMA requests */
;;;332        I2Cx->CR2 &= CR2_DMAEN_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;327
000006  f4416100          ORRNE    r1,r1,#0x800          ;327
00000a  f4216100          BICEQ    r1,r1,#0x800
00000e  8081              STRH     r1,[r0,#4]            ;327
;;;333      }
;;;334    }
000010  4770              BX       lr
;;;335    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;344    *******************************************************************************/
;;;345    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;346    {
;;;347      /* Check the parameters */
;;;348      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;349      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;350    
;;;351      if (NewState != DISABLE)
;;;352      {
;;;353        /* Next DMA transfer is the last transfer */
;;;354        I2Cx->CR2 |= CR2_LAST_Set;
;;;355      }
;;;356      else
;;;357      {
;;;358        /* Next DMA transfer is not the last transfer */
;;;359        I2Cx->CR2 &= CR2_LAST_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;354
000006  f4415180          ORRNE    r1,r1,#0x1000         ;354
00000a  f4215180          BICEQ    r1,r1,#0x1000
00000e  8081              STRH     r1,[r0,#4]            ;354
;;;360      }
;;;361    }
000010  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=1

                  I2C_DeInit PROC
;;;111    *******************************************************************************/
;;;112    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;113    {
000002  f5a040a8          SUB      r0,r0,#0x5400
000006  f1b04080          SUBS     r0,r0,#0x40000000
00000a  d00e              BEQ      |L10.42|
;;;114      /* Check the parameters */
;;;115      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;116    
;;;117      switch (*(u32*)&I2Cx)
00000c  f5b06f80          CMP      r0,#0x400
;;;118      {
;;;119        case I2C1_BASE:
;;;120          /* Enable I2C1 reset state */
;;;121          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;122          /* Release I2C1 from reset state */
;;;123          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;124          break;
;;;125    
;;;126        case I2C2_BASE:
;;;127          /* Enable I2C2 reset state */
;;;128          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
;;;129          /* Release I2C2 from reset state */
;;;130          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
;;;131          break;
;;;132    
;;;133        default:
;;;134          break;
;;;135      }
;;;136    }
000010  bf18              IT       NE
000012  bd10              POPNE    {r4,pc}
000014  2101              MOVS     r1,#1                 ;128
000016  0588              LSLS     r0,r1,#22             ;128
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e8bd4010          POP      {r4,lr}               ;130
000020  2100              MOVS     r1,#0                 ;130
000022  f44f0080          MOV      r0,#0x400000          ;130
000026  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L10.42|
00002a  2101              MOVS     r1,#1                 ;121
00002c  0548              LSLS     r0,r1,#21             ;121
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e8bd4010          POP      {r4,lr}               ;123
000036  2100              MOVS     r1,#0                 ;123
000038  f44f1000          MOV      r0,#0x200000          ;123
00003c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;137    
                          ENDP


                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;477    *******************************************************************************/
;;;478    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483    
;;;484      if (NewState != DISABLE)
;;;485      {
;;;486        /* Enable dual addressing mode */
;;;487        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
;;;488      }
;;;489      else
;;;490      {
;;;491        /* Disable dual addressing mode */
;;;492        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;487
000006  f0410101          ORRNE    r1,r1,#1              ;487
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8181              STRH     r1,[r0,#0xc]          ;487
;;;493      }
;;;494    }
000010  4770              BX       lr
;;;495    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;873    *******************************************************************************/
;;;874    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;875    {
;;;876      /* Check the parameters */
;;;877      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;878      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;879    
;;;880      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;881      {
;;;882        /* I2C fast mode Tlow/Thigh=2 */
;;;883        I2Cx->CCR &= I2C_DutyCycle_2;
;;;884      }
;;;885      else
;;;886      {
;;;887        /* I2C fast mode Tlow/Thigh=16/9 */
;;;888        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  bf14              ITE      NE                    ;883
000008  f4214180          BICNE    r1,r1,#0x4000         ;883
00000c  f4414180          ORREQ    r1,r1,#0x4000
000010  8381              STRH     r1,[r0,#0x1c]         ;883
;;;889      }
;;;890    }
000012  4770              BX       lr
;;;891    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;504    *******************************************************************************/
;;;505    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;506    {
;;;507      /* Check the parameters */
;;;508      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;509      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;510    
;;;511      if (NewState != DISABLE)
;;;512      {
;;;513        /* Enable generall call */
;;;514        I2Cx->CR1 |= CR1_ENGC_Set;
;;;515      }
;;;516      else
;;;517      {
;;;518        /* Disable generall call */
;;;519        I2Cx->CR1 &= CR1_ENGC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;514
000006  f0410140          ORRNE    r1,r1,#0x40           ;514
00000a  f0210140          BICEQ    r1,r1,#0x40
00000e  8001              STRH     r1,[r0,#0]            ;514
;;;520      }
;;;521    }
000010  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;371    *******************************************************************************/
;;;372    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;373    {
;;;374      /* Check the parameters */
;;;375      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;376      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;377    
;;;378      if (NewState != DISABLE)
;;;379      {
;;;380        /* Generate a START condition */
;;;381        I2Cx->CR1 |= CR1_START_Set;
;;;382      }
;;;383      else
;;;384      {
;;;385        /* Disable the START condition generation */
;;;386        I2Cx->CR1 &= CR1_START_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;381
000006  f4417180          ORRNE    r1,r1,#0x100          ;381
00000a  f4217180          BICEQ    r1,r1,#0x100
00000e  8001              STRH     r1,[r0,#0]            ;381
;;;387      }
;;;388    }
000010  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;398    *******************************************************************************/
;;;399    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404    
;;;405      if (NewState != DISABLE)
;;;406      {
;;;407        /* Generate a STOP condition */
;;;408        I2Cx->CR1 |= CR1_STOP_Set;
;;;409      }
;;;410      else
;;;411      {
;;;412        /* Disable the STOP condition generation */
;;;413        I2Cx->CR1 &= CR1_STOP_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;408
000006  f4417100          ORRNE    r1,r1,#0x200          ;408
00000a  f4217100          BICEQ    r1,r1,#0x200
00000e  8001              STRH     r1,[r0,#0]            ;408
;;;414      }
;;;415    }
000010  4770              BX       lr
;;;416    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1005   *******************************************************************************/
;;;1006   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1007   {
;;;1008     FlagStatus bitstatus = RESET;
;;;1009     u32 i2creg = 0, i2cxbase = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1013     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1014   
;;;1015     /* Get the I2Cx peripheral base address */
;;;1016     i2cxbase = (*(u32*)&(I2Cx));
;;;1017     
;;;1018     /* Read flag register index */
;;;1019     i2creg = I2C_FLAG >> 28;
000002  0f0b              LSRS     r3,r1,#28
;;;1020     
;;;1021     /* Get bit[23:0] of the flag */
;;;1022     I2C_FLAG &= FLAG_Mask;
000004  f021417f          BIC      r1,r1,#0xff000000
000008  bf12              ITEE     NE
00000a  3014              ADDNE    r0,r0,#0x14
;;;1023     
;;;1024     if(i2creg != 0)
;;;1025     {
;;;1026       /* Get the I2Cx SR1 register address */
;;;1027       i2cxbase += 0x14;
;;;1028     }
;;;1029     else
;;;1030     {
;;;1031       /* Flag in I2Cx SR2 Register */
;;;1032       I2C_FLAG = (u32)(I2C_FLAG >> 16);
00000c  0c09              LSREQ    r1,r1,#16
00000e  3018              ADDEQ    r0,r0,#0x18
;;;1033       /* Get the I2Cx SR2 register address */
;;;1034       i2cxbase += 0x18;
;;;1035     }
;;;1036     
;;;1037     if(((*(vu32 *)i2cxbase) & I2C_FLAG) != (u32)RESET)
000010  6800              LDR      r0,[r0,#0]
000012  4208              TST      r0,r1
;;;1038     {
;;;1039       /* I2C_FLAG is set */
;;;1040       bitstatus = SET;
000014  bf18              IT       NE
000016  2201              MOVNE    r2,#1
;;;1041     }
;;;1042     else
;;;1043     {
;;;1044       /* I2C_FLAG is reset */
;;;1045       bitstatus = RESET;
;;;1046     }
;;;1047     
;;;1048     /* Return the I2C_FLAG status */
;;;1049     return  bitstatus;
000018  4610              MOV      r0,r2
;;;1050   }
00001a  4770              BX       lr
;;;1051   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1130   *******************************************************************************/
;;;1131   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
000000  8883              LDRH     r3,[r0,#4]
;;;1132   {
;;;1133     ITStatus bitstatus = RESET;
000002  2200              MOVS     r2,#0
;;;1134     u32 enablestatus = 0;
;;;1135   
;;;1136     /* Check the parameters */
;;;1137     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1138     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1139   
;;;1140     /* Check if the interrupt source is enabled or not */
;;;1141     enablestatus = (u32)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;  
000004  f44f6ce0          MOV      r12,#0x700
000008  ea0c4c11          AND      r12,r12,r1,LSR #16
;;;1142   
;;;1143     /* Get bit[23:0] of the flag */
;;;1144     I2C_IT &= FLAG_Mask;
;;;1145   
;;;1146     /* Check the status of the specified I2C flag */
;;;1147     if (((I2Cx->SR1 & I2C_IT) != (u32)RESET) && enablestatus)
00000c  8a80              LDRH     r0,[r0,#0x14]
00000e  ea03030c          AND      r3,r3,r12             ;1141
000012  f021417f          BIC      r1,r1,#0xff000000     ;1144
000016  4208              TST      r0,r1
000018  bf1c              ITT      NE
00001a  2b00              CMPNE    r3,#0
;;;1148     {
;;;1149       /* I2C_IT is set */
;;;1150       bitstatus = SET;
00001c  2201              MOVNE    r2,#1
;;;1151     }
;;;1152     else
;;;1153     {
;;;1154       /* I2C_IT is reset */
;;;1155       bitstatus = RESET;
;;;1156     }
;;;1157     /* Return the I2C_IT status */
;;;1158     return  bitstatus;
00001e  4610              MOV      r0,r2
;;;1159   }
000020  4770              BX       lr
;;;1160   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;898    *******************************************************************************/
;;;899    u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;900    {
;;;901      u32 lastevent = 0;
;;;902      u32 flag1 = 0, flag2 = 0;
;;;903    
;;;904      /* Check the parameters */
;;;905      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;906    
;;;907      /* Read the I2Cx status register */
;;;908      flag1 = I2Cx->SR1;
;;;909      flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;910      flag2 = flag2 << 16;
;;;911    
;;;912      /* Get the last event value from I2C status register */
;;;913      lastevent = (flag1 | flag2) & FLAG_Mask;
000004  ea414000          ORR      r0,r1,r0,LSL #16
000008  f020407f          BIC      r0,r0,#0xff000000
;;;914    
;;;915      /* Return status */
;;;916      return lastevent;
;;;917    }
00000c  4770              BX       lr
;;;918    
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;799    *******************************************************************************/
;;;800    u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;804    
;;;805      /* Return the selected I2C PEC value */
;;;806      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;807    }
000004  4770              BX       lr
;;;808    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;537    *******************************************************************************/
;;;538    void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;539    {
;;;540      /* Check the parameters */
;;;541      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;542      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;543      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;544      
;;;545      if (NewState != DISABLE)
;;;546      {
;;;547        /* Enable the selected I2C interrupts */
;;;548        I2Cx->CR2 |= I2C_IT;
;;;549      }
;;;550      else
;;;551      {
;;;552        /* Disable the selected I2C interrupts */
;;;553        I2Cx->CR2 &= (u16)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  bf14              ITE      NE                    ;548
000006  4311              ORRNE    r1,r1,r2              ;548
000008  ea220101          BICEQ    r1,r2,r1
00000c  8081              STRH     r1,[r0,#4]            ;548
;;;554      }
;;;555    }
00000e  4770              BX       lr
;;;556    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;148    ******************************************************************************/
;;;149    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4604              MOV      r4,r0
;;;151      u16 tmpreg = 0, freqrange = 0;
;;;152      u16 result = 0x04;
;;;153      u32 pclk1 = 8000000;
;;;154      RCC_ClocksTypeDef  rcc_clocks;
;;;155    
;;;156      /* Check the parameters */
;;;157      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;158      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;159      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;160      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;161      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;162      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;163      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;164    
;;;165    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;166      /* Get the I2Cx CR2 value */
;;;167      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  b086              SUB      sp,sp,#0x18           ;150
000008  460d              MOV      r5,r1                 ;150
;;;168      /* Clear frequency FREQ[5:0] bits */
;;;169      tmpreg &= CR2_FREQ_Reset;
00000a  f020063f          BIC      r6,r0,#0x3f
;;;170      /* Get pclk1 frequency value */
;;;171      RCC_GetClocksFreq(&rcc_clocks);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       RCC_GetClocksFreq
;;;172      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;173      /* Set frequency bits depending on pclk1 value */
;;;174      freqrange = (u16)(pclk1 / 1000000);
000014  4929              LDR      r1,|L21.188|
000016  9802              LDR      r0,[sp,#8]
000018  fbb0f1f1          UDIV     r1,r0,r1
00001c  b289              UXTH     r1,r1
;;;175      tmpreg |= freqrange;
00001e  ea460201          ORR      r2,r6,r1
;;;176      /* Write to I2Cx CR2 */
;;;177      I2Cx->CR2 = tmpreg;
000022  80a2              STRH     r2,[r4,#4]
;;;178    
;;;179    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;180      /* Disable the selected I2C peripheral to configure TRISE */
;;;181      I2Cx->CR1 &= CR1_PE_Reset;
000024  8822              LDRH     r2,[r4,#0]
000026  f0220201          BIC      r2,r2,#1
00002a  8022              STRH     r2,[r4,#0]
;;;182    
;;;183      /* Reset tmpreg value */
;;;184      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;185      tmpreg = 0;
;;;186    
;;;187      /* Configure speed in standard mode */
;;;188      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00002c  4b24              LDR      r3,|L21.192|
00002e  68ea              LDR      r2,[r5,#0xc]
000030  429a              CMP      r2,r3
000032  d81d              BHI      |L21.112|
;;;189      {
;;;190        /* Standard mode speed calculate */
;;;191        result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000034  0052              LSLS     r2,r2,#1
000036  fbb0f0f2          UDIV     r0,r0,r2
00003a  b280              UXTH     r0,r0
;;;192        /* Test if CCR value is under 0x4*/
;;;193        if (result < 0x04)
00003c  2804              CMP      r0,#4
;;;194        {
;;;195          /* Set minimum allowed value */
;;;196          result = 0x04;  
00003e  bf38              IT       CC
000040  2004              MOVCC    r0,#4
000042  1c49              ADDS     r1,r1,#1
;;;197        }
;;;198        /* Set speed value for standard mode */
;;;199        tmpreg |= result;	  
;;;200        /* Set Maximum Rise Time for standard mode */
;;;201        I2Cx->TRISE = freqrange + 1; 
000044  8421              STRH     r1,[r4,#0x20]
                  |L21.70|
;;;202      }
;;;203      /* Configure speed in fast mode */
;;;204      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;205      {
;;;206        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;207        {
;;;208          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;209          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;210        }
;;;211        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;212        {
;;;213          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;214          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;215          /* Set DUTY bit */
;;;216          result |= I2C_DutyCycle_16_9;
;;;217        }
;;;218        /* Test if CCR value is under 0x1*/
;;;219        if ((result & CCR_CCR_Set) == 0)
;;;220        {
;;;221          /* Set minimum allowed value */
;;;222          result |= (u16)0x0001;  
;;;223        }
;;;224        /* Set speed value and set F/S bit for fast mode */
;;;225        tmpreg |= result | CCR_FS_Set;
;;;226        /* Set Maximum Rise Time for fast mode */
;;;227        I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
;;;228      }
;;;229      /* Write to I2Cx CCR */
;;;230      I2Cx->CCR = tmpreg;
000046  83a0              STRH     r0,[r4,#0x1c]
;;;231    
;;;232      /* Enable the selected I2C peripheral */
;;;233      I2Cx->CR1 |= CR1_PE_Set;
000048  8820              LDRH     r0,[r4,#0]
00004a  f0400001          ORR      r0,r0,#1
00004e  8020              STRH     r0,[r4,#0]
;;;234    
;;;235    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;236      /* Get the I2Cx CR1 value */
;;;237      tmpreg = I2Cx->CR1;
000050  8820              LDRH     r0,[r4,#0]
;;;238      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;239      tmpreg &= CR1_CLEAR_Mask;
;;;240      /* Configure I2Cx: mode and acknowledgement */
;;;241      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;242      /* Set ACK bit according to I2C_Ack value */
;;;243      tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000052  8829              LDRH     r1,[r5,#0]
000054  88ea              LDRH     r2,[r5,#6]
000056  f020000a          BIC      r0,r0,#0xa            ;239
00005a  f4206080          BIC      r0,r0,#0x400          ;239
00005e  4311              ORRS     r1,r1,r2
000060  4308              ORRS     r0,r0,r1
;;;244      /* Write to I2Cx CR1 */
;;;245      I2Cx->CR1 = tmpreg;
000062  8020              STRH     r0,[r4,#0]
;;;246    
;;;247    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;248      /* Set I2Cx Own Address1 and acknowledged address */
;;;249      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000064  8928              LDRH     r0,[r5,#8]
000066  88a9              LDRH     r1,[r5,#4]
000068  4308              ORRS     r0,r0,r1
00006a  8120              STRH     r0,[r4,#8]
;;;250    }
00006c  b006              ADD      sp,sp,#0x18
00006e  bd70              POP      {r4-r6,pc}
                  |L21.112|
000070  886b              LDRH     r3,[r5,#2]            ;206
000072  f5a34c3f          SUB      r12,r3,#0xbf00        ;206
000076  f1bc0cff          SUBS     r12,r12,#0xff         ;206
00007a  d019              BEQ      |L21.176|
00007c  eb0203c2          ADD      r3,r2,r2,LSL #3       ;214
000080  eb031202          ADD      r2,r3,r2,LSL #4       ;214
000084  fbb0f0f2          UDIV     r0,r0,r2              ;214
000088  b280              UXTH     r0,r0                 ;214
00008a  f4404080          ORR      r0,r0,#0x4000         ;216
                  |L21.142|
00008e  0502              LSLS     r2,r0,#20             ;219
000090  0d12              LSRS     r2,r2,#20             ;219
000092  bf08              IT       EQ                    ;222
000094  f0400001          ORREQ    r0,r0,#1              ;222
000098  f4404000          ORR      r0,r0,#0x8000         ;225
00009c  f44f7296          MOV      r2,#0x12c             ;227
0000a0  4351              MULS     r1,r2,r1              ;227
0000a2  f44f727a          MOV      r2,#0x3e8             ;227
0000a6  fbb1f1f2          UDIV     r1,r1,r2              ;227
0000aa  1c49              ADDS     r1,r1,#1              ;227
0000ac  8421              STRH     r1,[r4,#0x20]         ;227
0000ae  e7ca              B        |L21.70|
                  |L21.176|
0000b0  eb020242          ADD      r2,r2,r2,LSL #1       ;209
0000b4  fbb0f0f2          UDIV     r0,r0,r2              ;209
0000b8  b280              UXTH     r0,r0                 ;209
0000ba  e7e8              B        |L21.142|
;;;251    
                          ENDP

                  |L21.188|
                          DCD      0x000f4240
                  |L21.192|
                          DCD      0x000186a0

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;451    *******************************************************************************/
;;;452    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;453    {
;;;454      u16 tmpreg = 0;
;;;455    
;;;456      /* Check the parameters */
;;;457      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;458    
;;;459      /* Get the old register value */
;;;460      tmpreg = I2Cx->OAR2;
;;;461      /* Reset I2Cx Own address2 bit [7:1] */
;;;462      tmpreg &= OAR2_ADD2_Reset;
;;;463      /* Set I2Cx Own address2 */
;;;464      tmpreg |= (u16)(Address & (u16)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;462
00000a  4311              ORRS     r1,r1,r2
;;;465      /* Store the new register value */
;;;466      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;467    }
00000e  4770              BX       lr
;;;468    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;746    *******************************************************************************/
;;;747    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;748    {
;;;749      /* Check the parameters */
;;;750      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;751      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;752    
;;;753      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;754      {
;;;755        /* Next byte in shift register is PEC */
;;;756        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;757      }
;;;758      else
;;;759      {
;;;760        /* Current byte in shift register is PEC */
;;;761        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  bf0c              ITE      EQ                    ;756
000008  f4416100          ORREQ    r1,r1,#0x800          ;756
00000c  f4216100          BICNE    r1,r1,#0x800
000010  8001              STRH     r1,[r0,#0]            ;756
;;;762      }
;;;763    }
000012  4770              BX       lr
;;;764    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;640    *******************************************************************************/
;;;641    u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
000000  5a40              LDRH     r0,[r0,r1]
;;;642    {
;;;643      /* Check the parameters */
;;;644      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;645      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;646    
;;;647      /* Return the selected register value */
;;;648      return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
;;;649    }
000002  4770              BX       lr
;;;650    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;580    *******************************************************************************/
;;;581    u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;582    {
;;;583      /* Check the parameters */
;;;584      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;585    
;;;586      /* Return the data in the DR register */
;;;587      return (u8)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;588    }
000004  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;688    *******************************************************************************/
;;;689    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;690    {
;;;691      /* Check the parameters */
;;;692      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;693      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;694    
;;;695      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;696      {
;;;697        /* Drive the SMBusAlert pin Low */
;;;698        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;699      }
;;;700      else
;;;701      {
;;;702        /* Drive the SMBusAlert pin High  */
;;;703        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  bf0c              ITE      EQ                    ;698
000008  f4415100          ORREQ    r1,r1,#0x2000         ;698
00000c  f4215100          BICNE    r1,r1,#0x2000
000010  8001              STRH     r1,[r0,#0]            ;698
;;;704      }
;;;705    }
000012  4770              BX       lr
;;;706    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;602    *******************************************************************************/
;;;603    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
000000  2a00              CMP      r2,#0
;;;604    {
;;;605      /* Check the parameters */
;;;606      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;607      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;608    
;;;609      /* Test on the direction to set/reset the read/write bit */
;;;610      if (I2C_Direction != I2C_Direction_Transmitter)
;;;611      {
;;;612        /* Set the address bit0 for read */
;;;613        Address |= OAR1_ADD0_Set;
000002  bf14              ITE      NE
000004  f0410101          ORRNE    r1,r1,#1
;;;614      }
;;;615      else
;;;616      {
;;;617        /* Reset the address bit0 for write */
;;;618        Address &= OAR1_ADD0_Reset;
000008  f00101fe          ANDEQ    r1,r1,#0xfe
;;;619      }
;;;620      /* Send the address */
;;;621      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;622    }
00000e  4770              BX       lr
;;;623    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;564    *******************************************************************************/
;;;565    void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;566    {
;;;567      /* Check the parameters */
;;;568      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;569    
;;;570      /* Write in the DR register the data to be sent */
;;;571      I2Cx->DR = Data;
;;;572    }
000002  4770              BX       lr
;;;573    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;659    *******************************************************************************/
;;;660    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;661    {
;;;662      /* Check the parameters */
;;;663      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;664      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;665    
;;;666      if (NewState != DISABLE)
;;;667      {
;;;668        /* Peripheral under reset */
;;;669        I2Cx->CR1 |= CR1_SWRST_Set;
;;;670      }
;;;671      else
;;;672      {
;;;673        /* Peripheral not under reset */
;;;674        I2Cx->CR1 &= CR1_SWRST_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;669
000006  f4414100          ORRNE    r1,r1,#0x8000         ;669
00000a  f3c1010e          UBFXEQ   r1,r1,#0,#15
00000e  8001              STRH     r1,[r0,#0]            ;669
;;;675      }
;;;676    }
000010  4770              BX       lr
;;;677    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;844    *******************************************************************************/
;;;845    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;846    {
;;;847      /* Check the parameters */
;;;848      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;849      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;850    
;;;851      if (NewState == DISABLE)
;;;852      {
;;;853        /* Enable the selected I2C Clock stretching */
;;;854        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
;;;855      }
;;;856      else
;;;857      {
;;;858        /* Disable the selected I2C Clock stretching */
;;;859        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf0c              ITE      EQ                    ;854
000006  f0410180          ORREQ    r1,r1,#0x80           ;854
00000a  f0210180          BICNE    r1,r1,#0x80
00000e  8001              STRH     r1,[r0,#0]            ;854
;;;860      }
;;;861    }
000010  4770              BX       lr
;;;862    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;259    *******************************************************************************/
;;;260    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;261    {
;;;262    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;263      /* Initialize the I2C_Mode member */
;;;264      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000002  8001              STRH     r1,[r0,#0]
;;;265    
;;;266      /* Initialize the I2C_DutyCycle member */
;;;267      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000004  f64b72ff          MOV      r2,#0xbfff
000008  8042              STRH     r2,[r0,#2]
;;;268    
;;;269      /* Initialize the I2C_OwnAddress1 member */
;;;270      I2C_InitStruct->I2C_OwnAddress1 = 0;
00000a  8081              STRH     r1,[r0,#4]
;;;271    
;;;272      /* Initialize the I2C_Ack member */
;;;273      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00000c  80c1              STRH     r1,[r0,#6]
;;;274    
;;;275      /* Initialize the I2C_AcknowledgedAddress member */
;;;276      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00000e  f44f4180          MOV      r1,#0x4000
000012  8101              STRH     r1,[r0,#8]
;;;277    
;;;278      /* initialize the I2C_ClockSpeed member */
;;;279      I2C_InitStruct->I2C_ClockSpeed = 5000;
000014  f2413188          MOV      r1,#0x1388
000018  60c1              STR      r1,[r0,#0xc]
;;;280    }
00001a  4770              BX       lr
;;;281    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;715    *******************************************************************************/
;;;716    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;717    {
;;;718      /* Check the parameters */
;;;719      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;720      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;721    
;;;722      if (NewState != DISABLE)
;;;723      {
;;;724        /* Enable the selected I2C PEC transmission */
;;;725        I2Cx->CR1 |= CR1_PEC_Set;
;;;726      }
;;;727      else
;;;728      {
;;;729        /* Disable the selected I2C PEC transmission */
;;;730        I2Cx->CR1 &= CR1_PEC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;725
000006  f4415180          ORRNE    r1,r1,#0x1000         ;725
00000a  f4215180          BICEQ    r1,r1,#0x1000
00000e  8001              STRH     r1,[r0,#0]            ;725
;;;731      }
;;;732    }
000010  4770              BX       lr
;;;733    
                          ENDP

