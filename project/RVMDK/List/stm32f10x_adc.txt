; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_adc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_adc.crf ..\..\library\src\stm32f10x_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogCmd PROC
;;;1155   *******************************************************************************/
;;;1156   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
000000  6842              LDR      r2,[r0,#4]
;;;1157   {
;;;1158     u32 tmpreg = 0;
;;;1159   
;;;1160     /* Check the parameters */
;;;1161     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1162     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1163   
;;;1164     /* Get the old register value */
;;;1165     tmpreg = ADCx->CR1;
;;;1166     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1167     tmpreg &= CR1_AWDMode_Reset;
000002  f4227200          BIC      r2,r2,#0x200
000006  f4220240          BIC      r2,r2,#0xc00000
;;;1168     /* Set the analog watchdog enable mode */
;;;1169     tmpreg |= ADC_AnalogWatchdog;
00000a  4311              ORRS     r1,r1,r2
;;;1170     /* Store the new register value */
;;;1171     ADCx->CR1 = tmpreg;
00000c  6041              STR      r1,[r0,#4]
;;;1172   }
00000e  4770              BX       lr
;;;1173   
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1226   *******************************************************************************/
;;;1227   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
000000  6842              LDR      r2,[r0,#4]
;;;1228   {
;;;1229     u32 tmpreg = 0;
;;;1230   
;;;1231     /* Check the parameters */
;;;1232     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1233     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1234   
;;;1235     /* Get the old register value */
;;;1236     tmpreg = ADCx->CR1;
;;;1237     /* Clear the Analog watchdog channel select bits */
;;;1238     tmpreg &= CR1_AWDCH_Reset;
000002  f022021f          BIC      r2,r2,#0x1f
;;;1239     /* Set the Analog watchdog channel */
;;;1240     tmpreg |= ADC_Channel;
000006  4311              ORRS     r1,r1,r2
;;;1241     /* Store the new register value */
;;;1242     ADCx->CR1 = tmpreg;
000008  6041              STR      r1,[r0,#4]
;;;1243   }
00000a  4770              BX       lr
;;;1244   
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1184   *******************************************************************************/
;;;1185   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
000000  6241              STR      r1,[r0,#0x24]
;;;1186                                           u16 LowThreshold)
;;;1187   {
;;;1188     /* Check the parameters */
;;;1189     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1190     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1191     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1192   
;;;1193     /* Set the ADCx high threshold */
;;;1194     ADCx->HTR = HighThreshold;
;;;1195     /* Set the ADCx low threshold */
;;;1196     ADCx->LTR = LowThreshold;
000002  6282              STR      r2,[r0,#0x28]
;;;1197   }
000004  4770              BX       lr
;;;1198   
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;759    *******************************************************************************/
;;;760    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;761    {
;;;762      /* Check the parameters */
;;;763      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;764      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;765    
;;;766      if (NewState != DISABLE)
;;;767      {
;;;768        /* Enable the selected ADC automatic injected group conversion */
;;;769        ADCx->CR1 |= CR1_JAUTO_Set;
;;;770      }
;;;771      else
;;;772      {
;;;773        /* Disable the selected ADC automatic injected group conversion */
;;;774        ADCx->CR1 &= CR1_JAUTO_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  bf14              ITE      NE                    ;769
000006  f4416180          ORRNE    r1,r1,#0x400          ;769
00000a  f4216180          BICEQ    r1,r1,#0x400
00000e  6041              STR      r1,[r0,#4]            ;769
;;;775      }
;;;776    }
000010  4770              BX       lr
;;;777    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1321   *******************************************************************************/
;;;1322   void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
000000  43c9              MVNS     r1,r1
;;;1323   {
;;;1324     /* Check the parameters */
;;;1325     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1326     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1327   
;;;1328     /* Clear the selected ADC flags */
;;;1329     ADCx->SR = ~(u32)ADC_FLAG;
000002  6001              STR      r1,[r0,#0]
;;;1330   }
000004  4770              BX       lr
;;;1331   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1386   *******************************************************************************/
;;;1387   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
000000  ea6f2111          MVN      r1,r1,LSR #8
;;;1388   {
;;;1389     u8 itmask = 0;
;;;1390   
;;;1391     /* Check the parameters */
;;;1392     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1393     assert_param(IS_ADC_IT(ADC_IT));
;;;1394   
;;;1395     /* Get the ADC IT index */
;;;1396     itmask = (u8)(ADC_IT >> 8);
;;;1397   
;;;1398     /* Clear the selected ADC interrupt pending bits */
;;;1399     ADCx->SR = ~(u32)itmask;
000004  6001              STR      r1,[r0,#0]
;;;1400   }
000006  4770              BX       lr
;;;1401   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;265    *******************************************************************************/
;;;266    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;267    {
;;;268      /* Check the parameters */
;;;269      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;270      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;271    
;;;272      if (NewState != DISABLE)
;;;273      {
;;;274        /* Set the ADON bit to wake up the ADC from power down mode */
;;;275        ADCx->CR2 |= CR2_ADON_Set;
;;;276      }
;;;277      else
;;;278      {
;;;279        /* Disable the selected ADC peripheral */
;;;280        ADCx->CR2 &= CR2_ADON_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  bf14              ITE      NE                    ;275
000006  f0410101          ORRNE    r1,r1,#1              ;275
00000a  f0210101          BICEQ    r1,r1,#1
00000e  6081              STR      r1,[r0,#8]            ;275
;;;281      }
;;;282    }
000010  4770              BX       lr
;;;283    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;293    *******************************************************************************/
;;;294    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;298      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;299    
;;;300      if (NewState != DISABLE)
;;;301      {
;;;302        /* Enable the selected ADC DMA request */
;;;303        ADCx->CR2 |= CR2_DMA_Set;
;;;304      }
;;;305      else
;;;306      {
;;;307        /* Disable the selected ADC DMA request */
;;;308        ADCx->CR2 &= CR2_DMA_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  bf14              ITE      NE                    ;303
000006  f4417180          ORRNE    r1,r1,#0x100          ;303
00000a  f4217180          BICEQ    r1,r1,#0x100
00000e  6081              STR      r1,[r0,#8]            ;303
;;;309      }
;;;310    }
000010  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;129    *******************************************************************************/
;;;130    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  f5a03092          SUB      r0,r0,#0x12400
000006  f1b04080          SUBS     r0,r0,#0x40000000
00000a  d011              BEQ      |L9.48|
;;;132      /* Check the parameters */
;;;133      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;134    
;;;135      switch (*(u32*)&ADCx)
00000c  f5b06f80          CMP      r0,#0x400
000010  d019              BEQ      |L9.70|
000012  f5b05fc0          CMP      r0,#0x1800
;;;136      {
;;;137        case ADC1_BASE:
;;;138          /* Enable ADC1 reset state */
;;;139          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
;;;140          /* Release ADC1 from reset state */
;;;141          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
;;;142          break;
;;;143        
;;;144        case ADC2_BASE:
;;;145          /* Enable ADC2 reset state */
;;;146          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
;;;147          /* Release ADC2 from reset state */
;;;148          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
;;;149          break;
;;;150          
;;;151        case ADC3_BASE:
;;;152          /* Enable ADC3 reset state */
;;;153          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
;;;154          /* Release ADC3 from reset state */
;;;155          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
;;;156          break; 
;;;157    
;;;158        default:
;;;159          break;
;;;160      }
;;;161    }
000016  bf18              IT       NE
000018  bd10              POPNE    {r4,pc}
00001a  2101              MOVS     r1,#1                 ;153
00001c  03c8              LSLS     r0,r1,#15             ;153
00001e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000022  e8bd4010          POP      {r4,lr}               ;155
000026  2100              MOVS     r1,#0                 ;155
000028  f44f4000          MOV      r0,#0x8000            ;155
00002c  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L9.48|
000030  2101              MOVS     r1,#1                 ;139
000032  0248              LSLS     r0,r1,#9              ;139
000034  f7fffffe          BL       RCC_APB2PeriphResetCmd
000038  e8bd4010          POP      {r4,lr}               ;141
00003c  2100              MOVS     r1,#0                 ;141
00003e  f44f7000          MOV      r0,#0x200             ;141
000042  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L9.70|
000046  2101              MOVS     r1,#1                 ;146
000048  0288              LSLS     r0,r1,#10             ;146
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
00004e  e8bd4010          POP      {r4,lr}               ;148
000052  2100              MOVS     r1,#0                 ;148
000054  f44f6080          MOV      r0,#0x400             ;148
000058  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;162    
                          ENDP


                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;511    *******************************************************************************/
;;;512    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
000000  6842              LDR      r2,[r0,#4]
;;;513    {
;;;514      u32 tmpreg1 = 0;
;;;515      u32 tmpreg2 = 0;
;;;516    
;;;517      /* Check the parameters */
;;;518      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;519      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;520    
;;;521      /* Get the old register value */
;;;522      tmpreg1 = ADCx->CR1;
;;;523      /* Clear the old discontinuous mode channel count */
;;;524      tmpreg1 &= CR1_DISCNUM_Reset;
000002  1e49              SUBS     r1,r1,#1
000004  f4224260          BIC      r2,r2,#0xe000
;;;525      /* Set the discontinuous mode channel count */
;;;526      tmpreg2 = Number - 1;
;;;527      tmpreg1 |= tmpreg2 << 13;
000008  ea423141          ORR      r1,r2,r1,LSL #13
;;;528      /* Store the new register value */
;;;529      ADCx->CR1 = tmpreg1;
00000c  6041              STR      r1,[r0,#4]
;;;530    }
00000e  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;542    *******************************************************************************/
;;;543    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;547      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;548    
;;;549      if (NewState != DISABLE)
;;;550      {
;;;551        /* Enable the selected ADC regular discontinuous mode */
;;;552        ADCx->CR1 |= CR1_DISCEN_Set;
;;;553      }
;;;554      else
;;;555      {
;;;556        /* Disable the selected ADC regular discontinuous mode */
;;;557        ADCx->CR1 &= CR1_DISCEN_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  bf14              ITE      NE                    ;552
000006  f4416100          ORRNE    r1,r1,#0x800          ;552
00000a  f4216100          BICEQ    r1,r1,#0x800
00000e  6041              STR      r1,[r0,#4]            ;552
;;;558      }
;;;559    }
000010  4770              BX       lr
;;;560    
                          ENDP


                          AREA ||i.ADC_ExternalTrigConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigConvCmd PROC
;;;702    *******************************************************************************/
;;;703    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;704    {
;;;705      /* Check the parameters */
;;;706      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;707      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;708    
;;;709      if (NewState != DISABLE)
;;;710      {
;;;711        /* Enable the selected ADC conversion on external event */
;;;712        ADCx->CR2 |= CR2_EXTTRIG_Set;
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable the selected ADC conversion on external event */
;;;717        ADCx->CR2 &= CR2_EXTTRIG_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  bf14              ITE      NE                    ;712
000006  f4411180          ORRNE    r1,r1,#0x100000       ;712
00000a  f4211180          BICEQ    r1,r1,#0x100000
00000e  6081              STR      r1,[r0,#8]            ;712
;;;718      }
;;;719    }
000010  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;873    *******************************************************************************/
;;;874    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;875    {
;;;876      /* Check the parameters */
;;;877      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;878      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;879    
;;;880      if (NewState != DISABLE)
;;;881      {
;;;882        /* Enable the selected ADC external event selection for injected group */
;;;883        ADCx->CR2 |= CR2_JEXTTRIG_Set;
;;;884      }
;;;885      else
;;;886      {
;;;887        /* Disable the selected ADC external event selection for injected group */
;;;888        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  bf14              ITE      NE                    ;883
000006  f4414100          ORRNE    r1,r1,#0x8000         ;883
00000a  f4214100          BICEQ    r1,r1,#0x8000
00000e  6081              STR      r1,[r0,#8]            ;883
;;;889      }
;;;890    }
000010  4770              BX       lr
;;;891    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;844    *******************************************************************************/
;;;845    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
000000  6882              LDR      r2,[r0,#8]
;;;846    {
;;;847      u32 tmpreg = 0;
;;;848    
;;;849      /* Check the parameters */
;;;850      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;851      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;852    
;;;853      /* Get the old register value */
;;;854      tmpreg = ADCx->CR2;
;;;855      /* Clear the old external event selection for injected group */
;;;856      tmpreg &= CR2_JEXTSEL_Reset;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;857      /* Set the external event selection for injected group */
;;;858      tmpreg |= ADC_ExternalTrigInjecConv;
000006  4311              ORRS     r1,r1,r2
;;;859      /* Store the new register value */
;;;860      ADCx->CR2 = tmpreg;
000008  6081              STR      r1,[r0,#8]
;;;861    }
00000a  4770              BX       lr
;;;862    
                          ENDP


                          AREA ||i.ADC_GetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationStatus PROC
;;;419    *******************************************************************************/
;;;420    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;421    {
;;;422      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;423    
;;;424      /* Check the parameters */
;;;425      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;426    
;;;427      /* Check the status of CAL bit */
;;;428      if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  f0110f04          TST      r1,#4
;;;429      {
;;;430        /* CAL bit is set: calibration on going */
;;;431        bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;432      }
;;;433      else
;;;434      {
;;;435        /* CAL bit is reset: end of calibration */
;;;436        bitstatus = RESET;
;;;437      }
;;;438    
;;;439      /* Return the CAL bit status */
;;;440      return  bitstatus;
;;;441    }
00000e  4770              BX       lr
;;;442    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;727    *******************************************************************************/
;;;728    u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  6cc0              LDR      r0,[r0,#0x4c]
;;;729    {
;;;730      /* Check the parameters */
;;;731      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;732    
;;;733      /* Return the selected ADC conversion value */
;;;734      return (u16) ADCx->DR;
000002  b280              UXTH     r0,r0
;;;735    }
000004  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.ADC_GetDualModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetDualModeConversionValue PROC
;;;742    *******************************************************************************/
;;;743    u32 ADC_GetDualModeConversionValue(void)
000000  4801              LDR      r0,|L17.8|
;;;744    {
;;;745      /* Return the dual mode conversion value */
;;;746      return (*(vu32 *) DR_ADDRESS);
000002  6800              LDR      r0,[r0,#0]
;;;747    }
000004  4770              BX       lr
;;;748    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x4001244c

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1283   *******************************************************************************/
;;;1284   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1285   {
;;;1286     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1287   
;;;1288     /* Check the parameters */
;;;1289     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1290     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1291   
;;;1292     /* Check the status of the specified ADC flag */
;;;1293     if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
;;;1294     {
;;;1295       /* ADC_FLAG is set */
;;;1296       bitstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;1297     }
;;;1298     else
;;;1299     {
;;;1300       /* ADC_FLAG is reset */
;;;1301       bitstatus = RESET;
;;;1302     }
;;;1303   
;;;1304     /* Return the ADC_FLAG status */
;;;1305     return  bitstatus;
;;;1306   }
00000c  4770              BX       lr
;;;1307   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1343   *******************************************************************************/
;;;1344   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
000000  2200              MOVS     r2,#0
;;;1345   {
;;;1346     ITStatus bitstatus = RESET;
;;;1347     u32 itmask = 0, enablestatus = 0;
;;;1348   
;;;1349     /* Check the parameters */
;;;1350     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1351     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1352   
;;;1353     /* Get the ADC IT index */
;;;1354     itmask = ADC_IT >> 8;
;;;1355   
;;;1356     /* Get the ADC_IT enable bit status */
;;;1357     enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
000002  f8d0c004          LDR      r12,[r0,#4]
000006  0a0b              LSRS     r3,r1,#8              ;1354
000008  b2c9              UXTB     r1,r1
;;;1358   
;;;1359     /* Check the status of the specified ADC interrupt */
;;;1360     if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
00000a  6800              LDR      r0,[r0,#0]
00000c  ea0c0101          AND      r1,r12,r1             ;1357
000010  4218              TST      r0,r3
000012  bf1c              ITT      NE
000014  2900              CMPNE    r1,#0
;;;1361     {
;;;1362       /* ADC_IT is set */
;;;1363       bitstatus = SET;
000016  2201              MOVNE    r2,#1
;;;1364     }
;;;1365     else
;;;1366     {
;;;1367       /* ADC_IT is reset */
;;;1368       bitstatus = RESET;
;;;1369     }
;;;1370   
;;;1371     /* Return the ADC_IT status */
;;;1372     return  bitstatus;
000018  4610              MOV      r0,r2
;;;1373   }
00001a  4770              BX       lr
;;;1374   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1121   *******************************************************************************/
;;;1122   u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
000000  4408              ADD      r0,r0,r1
;;;1123   {
;;;1124     /* Check the parameters */
;;;1125     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1126     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1127   
;;;1128     /* Returns the selected injected channel conversion data value */
;;;1129     return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
000002  6a80              LDR      r0,[r0,#0x28]
000004  b280              UXTH     r0,r0
;;;1130   }
000006  4770              BX       lr
;;;1131   
                          ENDP


                          AREA ||i.ADC_GetResetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetResetCalibrationStatus PROC
;;;373    *******************************************************************************/
;;;374    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;375    {
;;;376      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;377    
;;;378      /* Check the parameters */
;;;379      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;380    
;;;381      /* Check the status of RSTCAL bit */
;;;382      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  f0110f08          TST      r1,#8
;;;383      {
;;;384        /* RSTCAL bit is set */
;;;385        bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;386      }
;;;387      else
;;;388      {
;;;389        /* RSTCAL bit is reset */
;;;390        bitstatus = RESET;
;;;391      }
;;;392    
;;;393      /* Return the RSTCAL bit status */
;;;394      return  bitstatus;
;;;395    }
00000e  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;478    *******************************************************************************/
;;;479    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;480    {
;;;481      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;482    
;;;483      /* Check the parameters */
;;;484      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;485    
;;;486      /* Check the status of SWSTART bit */
;;;487      if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  f4110f80          TST      r1,#0x400000
;;;488      {
;;;489        /* SWSTART bit is set */
;;;490        bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;491      }
;;;492      else
;;;493      {
;;;494        /* SWSTART bit is reset */
;;;495        bitstatus = RESET;
;;;496      }
;;;497    
;;;498      /* Return the SWSTART bit status */
;;;499      return  bitstatus;
;;;500    }
00000e  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;929    *******************************************************************************/
;;;930    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;931    {
;;;932      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;933    
;;;934      /* Check the parameters */
;;;935      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;936    
;;;937      /* Check the status of JSWSTART bit */
;;;938      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  f4111f00          TST      r1,#0x200000
;;;939      {
;;;940        /* JSWSTART bit is set */
;;;941        bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;942      }
;;;943      else
;;;944      {
;;;945        /* JSWSTART bit is reset */
;;;946        bitstatus = RESET;
;;;947      }
;;;948    
;;;949      /* Return the JSWSTART bit status */
;;;950      return  bitstatus;
;;;951    }
00000e  4770              BX       lr
;;;952    
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;326    *******************************************************************************/
;;;327    void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;328    {
;;;329      u8 itmask = 0;
;;;330    
;;;331      /* Check the parameters */
;;;332      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;333      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;334      assert_param(IS_ADC_IT(ADC_IT));
;;;335    
;;;336      /* Get the ADC IT index */
;;;337      itmask = (u8)ADC_IT;
;;;338    
;;;339      if (NewState != DISABLE)
;;;340      {
;;;341        /* Enable the selected ADC interrupts */
;;;342        ADCx->CR1 |= itmask;
;;;343      }
;;;344      else
;;;345      {
;;;346        /* Disable the selected ADC interrupts */
;;;347        ADCx->CR1 &= (~(u32)itmask);
000002  6842              LDR      r2,[r0,#4]
000004  b2c9              UXTB     r1,r1                 ;337
000006  bf14              ITE      NE                    ;342
000008  4311              ORRNE    r1,r1,r2              ;342
00000a  ea220101          BICEQ    r1,r2,r1
00000e  6041              STR      r1,[r0,#4]            ;342
;;;348      }
;;;349    }
000010  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;173    ******************************************************************************/
;;;174    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  6842              LDR      r2,[r0,#4]
;;;175    {
;;;176      u32 tmpreg1 = 0;
;;;177      u8 tmpreg2 = 0;
;;;178    
;;;179      /* Check the parameters */
;;;180      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;181      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;182      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;183      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
;;;184      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;185      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;186      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;187    
;;;188      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;189      /* Get the ADCx CR1 value */
;;;190      tmpreg1 = ADCx->CR1;
;;;191      /* Clear DUALMOD and SCAN bits */
;;;192      tmpreg1 &= CR1_CLEAR_Mask;
;;;193      /* Configure ADCx: Dual mode and scan conversion mode */
;;;194      /* Set DUALMOD bits according to ADC_Mode value */
;;;195      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;196      tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
000002  f891c004          LDRB     r12,[r1,#4]
000006  f4227280          BIC      r2,r2,#0x100          ;192
00000a  f4222270          BIC      r2,r2,#0xf0000        ;192
00000e  680b              LDR      r3,[r1,#0]
000010  ea42220c          ORR      r2,r2,r12,LSL #8
000014  431a              ORRS     r2,r2,r3
;;;197      /* Write to ADCx CR1 */
;;;198      ADCx->CR1 = tmpreg1;
000016  6042              STR      r2,[r0,#4]
;;;199    
;;;200      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;201      /* Get the ADCx CR2 value */
;;;202      tmpreg1 = ADCx->CR2;
000018  6882              LDR      r2,[r0,#8]
;;;203      /* Clear CONT, ALIGN and EXTSEL bits */
;;;204      tmpreg1 &= CR2_CLEAR_Mask;
00001a  4b0b              LDR      r3,|L25.72|
00001c  401a              ANDS     r2,r2,r3
00001e  e9d1c302          LDRD     r12,r3,[r1,#8]
;;;205      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;206      /* Set ALIGN bit according to ADC_DataAlign value */
;;;207      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;208      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;209      tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
000022  ea43030c          ORR      r3,r3,r12
000026  f891c005          LDRB     r12,[r1,#5]
00002a  ea42024c          ORR      r2,r2,r12,LSL #1
00002e  431a              ORRS     r2,r2,r3
;;;210                ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;211      /* Write to ADCx CR2 */
;;;212      ADCx->CR2 = tmpreg1;
000030  6082              STR      r2,[r0,#8]
;;;213    
;;;214      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;215      /* Get the ADCx SQR1 value */
;;;216      tmpreg1 = ADCx->SQR1;
000032  6ac2              LDR      r2,[r0,#0x2c]
;;;217      /* Clear L bits */
;;;218      tmpreg1 &= SQR1_CLEAR_Mask;
;;;219      /* Configure ADCx: regular channel sequence length */
;;;220      /* Set L bits according to ADC_NbrOfChannel value */
;;;221      tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
000034  7c09              LDRB     r1,[r1,#0x10]
000036  f4220270          BIC      r2,r2,#0xf00000       ;218
00003a  1e49              SUBS     r1,r1,#1
00003c  b2c9              UXTB     r1,r1
;;;222      tmpreg1 |= ((u32)tmpreg2 << 20);
00003e  ea425101          ORR      r1,r2,r1,LSL #20
;;;223      /* Write to ADCx SQR1 */
;;;224      ADCx->SQR1 = tmpreg1;
000042  62c1              STR      r1,[r0,#0x2c]
;;;225    }
000044  4770              BX       lr
;;;226    
                          ENDP

000046  0000              DCW      0x0000
                  |L25.72|
                          DCD      0xfff1f7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;993    *******************************************************************************/
;;;994    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
000000  b430              PUSH     {r4,r5}
;;;995    {
;;;996      u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;997    
;;;998      /* Check the parameters */
;;;999      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1000     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1001     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1002     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1003   
;;;1004     /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;1005     if (ADC_Channel > ADC_Channel_9)
;;;1006     {
;;;1007       /* Get the old register value */
;;;1008       tmpreg1 = ADCx->SMPR1;
;;;1009       /* Calculate the mask to clear */
;;;1010       tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
000002  2507              MOVS     r5,#7
000004  2909              CMP      r1,#9                 ;1005
000006  d90c              BLS      |L26.34|
000008  68c4              LDR      r4,[r0,#0xc]          ;1008
00000a  f1a10c0a          SUB      r12,r1,#0xa
00000e  eb0c0c4c          ADD      r12,r12,r12,LSL #1
000012  fa05f50c          LSL      r5,r5,r12
;;;1011       /* Clear the old discontinuous mode channel count */
;;;1012       tmpreg1 &= ~tmpreg2;
000016  43ac              BICS     r4,r4,r5
;;;1013       /* Calculate the mask to set */
;;;1014       tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
000018  fa03f30c          LSL      r3,r3,r12
;;;1015       /* Set the discontinuous mode channel count */
;;;1016       tmpreg1 |= tmpreg2;
00001c  4323              ORRS     r3,r3,r4
;;;1017       /* Store the new register value */
;;;1018       ADCx->SMPR1 = tmpreg1;
00001e  60c3              STR      r3,[r0,#0xc]
000020  e009              B        |L26.54|
                  |L26.34|
;;;1019     }
;;;1020     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1021     {
;;;1022       /* Get the old register value */
;;;1023       tmpreg1 = ADCx->SMPR2;
000022  6904              LDR      r4,[r0,#0x10]
;;;1024       /* Calculate the mask to clear */
;;;1025       tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000024  eb010c41          ADD      r12,r1,r1,LSL #1
000028  fa05f50c          LSL      r5,r5,r12
;;;1026       /* Clear the old discontinuous mode channel count */
;;;1027       tmpreg1 &= ~tmpreg2;
00002c  43ac              BICS     r4,r4,r5
;;;1028       /* Calculate the mask to set */
;;;1029       tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
00002e  fa03f30c          LSL      r3,r3,r12
;;;1030       /* Set the discontinuous mode channel count */
;;;1031       tmpreg1 |= tmpreg2;
000032  4323              ORRS     r3,r3,r4
;;;1032       /* Store the new register value */
;;;1033       ADCx->SMPR2 = tmpreg1;
000034  6103              STR      r3,[r0,#0x10]
                  |L26.54|
;;;1034     }
;;;1035   
;;;1036     /* Rank configuration */
;;;1037     /* Get the old register value */
;;;1038     tmpreg1 = ADCx->JSQR;
000036  6b83              LDR      r3,[r0,#0x38]
;;;1039     /* Get JL value: Number = JL+1 */
;;;1040     tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000038  f3c35c01          UBFX     r12,r3,#20,#2
;;;1041     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1042     tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
00003c  eba2020c          SUB      r2,r2,r12
000040  1c92              ADDS     r2,r2,#2
000042  eb020282          ADD      r2,r2,r2,LSL #2
000046  f04f0c1f          MOV      r12,#0x1f
00004a  fa0cfc02          LSL      r12,r12,r2
;;;1043     /* Clear the old JSQx bits for the selected rank */
;;;1044     tmpreg1 &= ~tmpreg2;
00004e  ea23030c          BIC      r3,r3,r12
;;;1045     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1046     tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
000052  4091              LSLS     r1,r1,r2
;;;1047     /* Set the JSQx bits for the selected rank */
;;;1048     tmpreg1 |= tmpreg2;
000054  4319              ORRS     r1,r1,r3
;;;1049     /* Store the new register value */
;;;1050     ADCx->JSQR = tmpreg1;
000056  6381              STR      r1,[r0,#0x38]
;;;1051   }
000058  bc30              POP      {r4,r5}
00005a  4770              BX       lr
;;;1052   
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;788    *******************************************************************************/
;;;789    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;790    {
;;;791      /* Check the parameters */
;;;792      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;793      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;794    
;;;795      if (NewState != DISABLE)
;;;796      {
;;;797        /* Enable the selected ADC injected discontinuous mode */
;;;798        ADCx->CR1 |= CR1_JDISCEN_Set;
;;;799      }
;;;800      else
;;;801      {
;;;802        /* Disable the selected ADC injected discontinuous mode */
;;;803        ADCx->CR1 &= CR1_JDISCEN_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  bf14              ITE      NE                    ;798
000006  f4415180          ORRNE    r1,r1,#0x1000         ;798
00000a  f4215180          BICEQ    r1,r1,#0x1000
00000e  6041              STR      r1,[r0,#4]            ;798
;;;804      }
;;;805    }
000010  4770              BX       lr
;;;806    
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;1061   *******************************************************************************/
;;;1062   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
000000  6b82              LDR      r2,[r0,#0x38]
;;;1063   {
;;;1064     u32 tmpreg1 = 0;
;;;1065     u32 tmpreg2 = 0;
;;;1066   
;;;1067     /* Check the parameters */
;;;1068     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1069     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1070     
;;;1071     /* Get the old register value */
;;;1072     tmpreg1 = ADCx->JSQR;
;;;1073     /* Clear the old injected sequnence lenght JL bits */
;;;1074     tmpreg1 &= JSQR_JL_Reset;
000002  1e49              SUBS     r1,r1,#1
000004  f4221240          BIC      r2,r2,#0x300000
;;;1075     /* Set the injected sequnence lenght JL bits */
;;;1076     tmpreg2 = Length - 1; 
;;;1077     tmpreg1 |= tmpreg2 << 20;
000008  ea425101          ORR      r1,r2,r1,LSL #20
;;;1078     /* Store the new register value */
;;;1079     ADCx->JSQR = tmpreg1;
00000c  6381              STR      r1,[r0,#0x38]
;;;1080   }
00000e  4770              BX       lr
;;;1081   
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;601    *******************************************************************************/
;;;602    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
000000  b430              PUSH     {r4,r5}
;;;603    {
;;;604      u32 tmpreg1 = 0, tmpreg2 = 0;
;;;605    
;;;606      /* Check the parameters */
;;;607      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;608      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;609      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;610      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;611    
;;;612      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;613      if (ADC_Channel > ADC_Channel_9)
;;;614      {
;;;615        /* Get the old register value */
;;;616        tmpreg1 = ADCx->SMPR1;
;;;617        /* Calculate the mask to clear */
;;;618        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
000002  2507              MOVS     r5,#7
000004  2909              CMP      r1,#9                 ;613
000006  d90c              BLS      |L29.34|
000008  68c4              LDR      r4,[r0,#0xc]          ;616
00000a  f1a10c0a          SUB      r12,r1,#0xa
00000e  eb0c0c4c          ADD      r12,r12,r12,LSL #1
000012  fa05f50c          LSL      r5,r5,r12
;;;619        /* Clear the old discontinuous mode channel count */
;;;620        tmpreg1 &= ~tmpreg2;
000016  43ac              BICS     r4,r4,r5
;;;621        /* Calculate the mask to set */
;;;622        tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
000018  fa03f30c          LSL      r3,r3,r12
;;;623        /* Set the discontinuous mode channel count */
;;;624        tmpreg1 |= tmpreg2;
00001c  4323              ORRS     r3,r3,r4
;;;625        /* Store the new register value */
;;;626        ADCx->SMPR1 = tmpreg1;
00001e  60c3              STR      r3,[r0,#0xc]
000020  e009              B        |L29.54|
                  |L29.34|
;;;627      }
;;;628      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;629      {
;;;630        /* Get the old register value */
;;;631        tmpreg1 = ADCx->SMPR2;
000022  6904              LDR      r4,[r0,#0x10]
;;;632        /* Calculate the mask to clear */
;;;633        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000024  eb010c41          ADD      r12,r1,r1,LSL #1
000028  fa05f50c          LSL      r5,r5,r12
;;;634        /* Clear the old discontinuous mode channel count */
;;;635        tmpreg1 &= ~tmpreg2;
00002c  43ac              BICS     r4,r4,r5
;;;636        /* Calculate the mask to set */
;;;637        tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
00002e  fa03f30c          LSL      r3,r3,r12
;;;638        /* Set the discontinuous mode channel count */
;;;639        tmpreg1 |= tmpreg2;
000032  4323              ORRS     r3,r3,r4
;;;640        /* Store the new register value */
;;;641        ADCx->SMPR2 = tmpreg1;
000034  6103              STR      r3,[r0,#0x10]
                  |L29.54|
;;;642      }
;;;643      /* For Rank 1 to 6 */
;;;644      if (Rank < 7)
;;;645      {
;;;646        /* Get the old register value */
;;;647        tmpreg1 = ADCx->SQR3;
;;;648        /* Calculate the mask to clear */
;;;649        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
000036  f04f0c1f          MOV      r12,#0x1f
00003a  2a07              CMP      r2,#7                 ;644
00003c  d20c              BCS      |L29.88|
00003e  6b43              LDR      r3,[r0,#0x34]         ;647
000040  1e52              SUBS     r2,r2,#1              ;647
000042  eb020282          ADD      r2,r2,r2,LSL #2
000046  fa0cfc02          LSL      r12,r12,r2
;;;650        /* Clear the old SQx bits for the selected rank */
;;;651        tmpreg1 &= ~tmpreg2;
00004a  ea23030c          BIC      r3,r3,r12
;;;652        /* Calculate the mask to set */
;;;653        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
00004e  4091              LSLS     r1,r1,r2
;;;654        /* Set the SQx bits for the selected rank */
;;;655        tmpreg1 |= tmpreg2;
000050  4319              ORRS     r1,r1,r3
;;;656        /* Store the new register value */
;;;657        ADCx->SQR3 = tmpreg1;
000052  6341              STR      r1,[r0,#0x34]
;;;658      }
;;;659      /* For Rank 7 to 12 */
;;;660      else if (Rank < 13)
;;;661      {
;;;662        /* Get the old register value */
;;;663        tmpreg1 = ADCx->SQR2;
;;;664        /* Calculate the mask to clear */
;;;665        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
;;;666        /* Clear the old SQx bits for the selected rank */
;;;667        tmpreg1 &= ~tmpreg2;
;;;668        /* Calculate the mask to set */
;;;669        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
;;;670        /* Set the SQx bits for the selected rank */
;;;671        tmpreg1 |= tmpreg2;
;;;672        /* Store the new register value */
;;;673        ADCx->SQR2 = tmpreg1;
;;;674      }
;;;675      /* For Rank 13 to 16 */
;;;676      else
;;;677      {
;;;678        /* Get the old register value */
;;;679        tmpreg1 = ADCx->SQR1;
;;;680        /* Calculate the mask to clear */
;;;681        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
;;;682        /* Clear the old SQx bits for the selected rank */
;;;683        tmpreg1 &= ~tmpreg2;
;;;684        /* Calculate the mask to set */
;;;685        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
;;;686        /* Set the SQx bits for the selected rank */
;;;687        tmpreg1 |= tmpreg2;
;;;688        /* Store the new register value */
;;;689        ADCx->SQR1 = tmpreg1;
;;;690      }
;;;691    }
000054  bc30              POP      {r4,r5}
000056  4770              BX       lr
                  |L29.88|
000058  2a0d              CMP      r2,#0xd               ;660
00005a  d20c              BCS      |L29.118|
00005c  6b03              LDR      r3,[r0,#0x30]         ;663
00005e  1fd2              SUBS     r2,r2,#7              ;663
000060  eb020282          ADD      r2,r2,r2,LSL #2       ;665
000064  fa0cfc02          LSL      r12,r12,r2            ;665
000068  ea23030c          BIC      r3,r3,r12             ;667
00006c  4091              LSLS     r1,r1,r2              ;669
00006e  4319              ORRS     r1,r1,r3              ;671
000070  6301              STR      r1,[r0,#0x30]         ;673
000072  bc30              POP      {r4,r5}
000074  4770              BX       lr
                  |L29.118|
000076  6ac3              LDR      r3,[r0,#0x2c]         ;679
000078  3a0d              SUBS     r2,r2,#0xd            ;679
00007a  eb020282          ADD      r2,r2,r2,LSL #2       ;681
00007e  fa0cfc02          LSL      r12,r12,r2            ;681
000082  ea23030c          BIC      r3,r3,r12             ;683
000086  4091              LSLS     r1,r1,r2              ;685
000088  4319              ORRS     r1,r1,r3              ;687
00008a  62c1              STR      r1,[r0,#0x2c]         ;689
00008c  bc30              POP      {r4,r5}
00008e  4770              BX       lr
;;;692    
                          ENDP


                          AREA ||i.ADC_ResetCalibration||, CODE, READONLY, ALIGN=1

                  ADC_ResetCalibration PROC
;;;357    *******************************************************************************/
;;;358    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;359    {
;;;360      /* Check the parameters */
;;;361      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;362    
;;;363      /* Resets the selected ADC calibartion registers */  
;;;364      ADCx->CR2 |= CR2_RSTCAL_Set;
000002  f0410108          ORR      r1,r1,#8
000006  6081              STR      r1,[r0,#8]
;;;365    }
000008  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1097   *******************************************************************************/
;;;1098   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
000000  5042              STR      r2,[r0,r1]
;;;1099   {
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1102     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1103     assert_param(IS_ADC_OFFSET(Offset));  
;;;1104   
;;;1105     /* Set the selected injected channel data offset */
;;;1106     *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
;;;1107   }
000002  4770              BX       lr
;;;1108   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConvCmd PROC
;;;451    *******************************************************************************/
;;;452    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;456      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;457    
;;;458      if (NewState != DISABLE)
;;;459      {
;;;460        /* Enable the selected ADC conversion on external event and start the selected
;;;461           ADC conversion */
;;;462        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
;;;463      }
;;;464      else
;;;465      {
;;;466        /* Disable the selected ADC conversion on external event and stop the selected
;;;467           ADC conversion */
;;;468        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  bf14              ITE      NE                    ;462
000006  f44101a0          ORRNE    r1,r1,#0x500000       ;462
00000a  f42101a0          BICEQ    r1,r1,#0x500000
00000e  6081              STR      r1,[r0,#8]            ;462
;;;469      }
;;;470    }
000010  4770              BX       lr
;;;471    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;902    *******************************************************************************/
;;;903    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;904    {
;;;905      /* Check the parameters */
;;;906      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;907      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;908    
;;;909      if (NewState != DISABLE)
;;;910      {
;;;911        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;912           ADC injected conversion */
;;;913        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
;;;914      }
;;;915      else
;;;916      {
;;;917        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;918           ADC injected conversion */
;;;919        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  bf14              ITE      NE                    ;913
000006  f4411102          ORRNE    r1,r1,#0x208000       ;913
00000a  f4211102          BICEQ    r1,r1,#0x208000
00000e  6081              STR      r1,[r0,#8]            ;913
;;;920      }
;;;921    }
000010  4770              BX       lr
;;;922    
                          ENDP


                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=1

                  ADC_StartCalibration PROC
;;;403    *******************************************************************************/
;;;404    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;405    {
;;;406      /* Check the parameters */
;;;407      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;408    
;;;409      /* Enable the selected ADC calibration process */  
;;;410      ADCx->CR2 |= CR2_CAL_Set;
000002  f0410104          ORR      r1,r1,#4
000006  6081              STR      r1,[r0,#8]
;;;411    }
000008  4770              BX       lr
;;;412    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;234    *******************************************************************************/
;;;235    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;236    {
;;;237      /* Reset ADC init structure parameters values */
;;;238      /* Initialize the ADC_Mode member */
;;;239      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
;;;240    
;;;241      /* initialize the ADC_ScanConvMode member */
;;;242      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000002  6001              STR      r1,[r0,#0]
000004  7101              STRB     r1,[r0,#4]
;;;243    
;;;244      /* Initialize the ADC_ContinuousConvMode member */
;;;245      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;246    
;;;247      /* Initialize the ADC_ExternalTrigConv member */
;;;248      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
;;;249    
;;;250      /* Initialize the ADC_DataAlign member */
;;;251      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
000008  6081              STR      r1,[r0,#8]
;;;252    
;;;253      /* Initialize the ADC_NbrOfChannel member */
;;;254      ADC_InitStruct->ADC_NbrOfChannel = 1;
00000a  60c1              STR      r1,[r0,#0xc]
00000c  2101              MOVS     r1,#1
00000e  7401              STRB     r1,[r0,#0x10]
;;;255    }
000010  4770              BX       lr
;;;256    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;1252   *******************************************************************************/
;;;1253   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L36.20|
;;;1254   {
;;;1255     /* Check the parameters */
;;;1256     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1257   
;;;1258     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;1259     {
;;;1260       /* Enable the temperature sensor and Vrefint channel*/
;;;1261       ADC1->CR2 |= CR2_TSVREFE_Set;
;;;1262     }
;;;1263     else
;;;1264     {
;;;1265       /* Disable the temperature sensor and Vrefint channel*/
;;;1266       ADC1->CR2 &= CR2_TSVREFE_Reset;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;1261
000008  f4400000          ORRNE    r0,r0,#0x800000       ;1261
00000c  f4200000          BICEQ    r0,r0,#0x800000
000010  6008              STR      r0,[r1,#0]            ;1261
;;;1267     }
;;;1268   }
000012  4770              BX       lr
;;;1269   
                          ENDP

                  |L36.20|
                          DCD      0x40012408
