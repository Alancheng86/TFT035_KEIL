; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_rcc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_rcc.crf ..\..\library\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;540    *******************************************************************************/
;;;541    void RCC_ADCCLKConfig(u32 RCC_PCLK2)
000000  4a03              LDR      r2,|L1.16|
;;;542    {
;;;543      u32 tmpreg = 0;
;;;544    
;;;545      /* Check the parameters */
;;;546      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;547    
;;;548      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;549    
;;;550      /* Clear ADCPRE[1:0] bits */
;;;551      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000004  f4214140          BIC      r1,r1,#0xc000
;;;552    
;;;553      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;554      tmpreg |= RCC_PCLK2;
000008  4308              ORRS     r0,r0,r1
;;;555    
;;;556      /* Store the new value */
;;;557      RCC->CFGR = tmpreg;
00000a  6050              STR      r0,[r2,#4]
;;;558    }
00000c  4770              BX       lr
;;;559    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;767    *******************************************************************************/
;;;768    void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;769    {
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;772      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;773    
;;;774      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;775      {
;;;776        RCC->AHBENR |= RCC_AHBPeriph;
;;;777      }
;;;778      else
;;;779      {
;;;780        RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  bf14              ITE      NE                    ;776
000008  4308              ORRNE    r0,r0,r1              ;776
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6150              STR      r0,[r2,#0x14]         ;776
;;;781      }
;;;782    }
000010  4770              BX       lr
;;;783    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;834    *******************************************************************************/
;;;835    void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;836    {
;;;837      /* Check the parameters */
;;;838      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;839      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;840    
;;;841      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;842      {
;;;843        RCC->APB1ENR |= RCC_APB1Periph;
;;;844      }
;;;845      else
;;;846      {
;;;847        RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  bf14              ITE      NE                    ;843
000008  4308              ORRNE    r0,r0,r1              ;843
00000a  ea210000          BICEQ    r0,r1,r0
00000e  61d0              STR      r0,[r2,#0x1c]         ;843
;;;848      }
;;;849    }
000010  4770              BX       lr
;;;850    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;899    *******************************************************************************/
;;;900    void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;901    {
;;;902      /* Check the parameters */
;;;903      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;904      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;905    
;;;906      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;907      {
;;;908        RCC->APB1RSTR |= RCC_APB1Periph;
;;;909      }
;;;910      else
;;;911      {
;;;912        RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  bf14              ITE      NE                    ;908
000008  4308              ORRNE    r0,r0,r1              ;908
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6110              STR      r0,[r2,#0x10]         ;908
;;;913      }
;;;914    }
000010  4770              BX       lr
;;;915    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;800    *******************************************************************************/
;;;801    void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;802    {
;;;803      /* Check the parameters */
;;;804      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;805      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;806    
;;;807      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;808      {
;;;809        RCC->APB2ENR |= RCC_APB2Periph;
;;;810      }
;;;811      else
;;;812      {
;;;813        RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  bf14              ITE      NE                    ;809
000008  4308              ORRNE    r0,r0,r1              ;809
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6190              STR      r0,[r2,#0x18]         ;809
;;;814      }
;;;815    }
000010  4770              BX       lr
;;;816    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;866    *******************************************************************************/
;;;867    void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;868    {
;;;869      /* Check the parameters */
;;;870      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;871      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;872    
;;;873      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;874      {
;;;875        RCC->APB2RSTR |= RCC_APB2Periph;
;;;876      }
;;;877      else
;;;878      {
;;;879        RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  bf14              ITE      NE                    ;875
000008  4308              ORRNE    r0,r0,r1              ;875
00000a  ea210000          BICEQ    r0,r1,r0
00000e  60d0              STR      r0,[r2,#0xc]          ;875
;;;880      }
;;;881    }
000010  4770              BX       lr
;;;882    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;232    *******************************************************************************/
;;;233    void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
000000  4a03              LDR      r2,|L7.16|
;;;234    {
;;;235      u32 tmpreg = 0;
;;;236    
;;;237      /* Check the parameters */
;;;238      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;239    
;;;240      tmpreg = RCC->CR;
000002  6811              LDR      r1,[r2,#0]
;;;241    
;;;242      /* Clear HSITRIM[4:0] bits */
;;;243      tmpreg &= CR_HSITRIM_Mask;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;244    
;;;245      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;246      tmpreg |= (u32)HSICalibrationValue << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;247    
;;;248      /* Store the new value */
;;;249      RCC->CR = tmpreg;
00000c  6010              STR      r0,[r2,#0]
;;;250    }
00000e  4770              BX       lr
;;;251    
                          ENDP

                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;923    *******************************************************************************/
;;;924    void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;925    {
;;;926      /* Check the parameters */
;;;927      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;928    
;;;929      *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;930    }
000004  4770              BX       lr
;;;931    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1039   *******************************************************************************/
;;;1040   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L9.12|
;;;1041   {
;;;1042     /* Set RMVF bit to clear the reset flags */
;;;1043     RCC->CSR |= CSR_RMVF_Set;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1044   }
00000a  4770              BX       lr
;;;1045   
                          ENDP

                  |L9.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1094   *******************************************************************************/
;;;1095   void RCC_ClearITPendingBit(u8 RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1096   {
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1099   
;;;1100     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1101        pending bits */
;;;1102     *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1103   }
000004  4770              BX       lr
;;;1104   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;939    *******************************************************************************/
;;;940    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;941    {
;;;942      /* Check the parameters */
;;;943      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;944    
;;;945      *(vu32 *) CR_CSSON_BB = (u32)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;946    }
000004  4770              BX       lr
;;;947    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;123    *******************************************************************************/
;;;124    void RCC_DeInit(void)
000000  480c              LDR      r0,|L12.52|
;;;125    {
;;;126      /* Set HSION bit */
;;;127      RCC->CR |= (u32)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;128    
;;;129      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;130      RCC->CFGR &= (u32)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L12.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;131      
;;;132      /* Reset HSEON, CSSON and PLLON bits */
;;;133      RCC->CR &= (u32)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  f4212110          BIC      r1,r1,#0x90000
000018  f0217180          BIC      r1,r1,#0x1000000
00001c  6001              STR      r1,[r0,#0]
;;;134    
;;;135      /* Reset HSEBYP bit */
;;;136      RCC->CR &= (u32)0xFFFBFFFF;
00001e  6801              LDR      r1,[r0,#0]
000020  f4212180          BIC      r1,r1,#0x40000
000024  6001              STR      r1,[r0,#0]
;;;137    
;;;138      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;139      RCC->CFGR &= (u32)0xFF80FFFF;
000026  6841              LDR      r1,[r0,#4]
000028  f42101fe          BIC      r1,r1,#0x7f0000
00002c  6041              STR      r1,[r0,#4]
;;;140    
;;;141      /* Disable all interrupts */
;;;142      RCC->CIR = 0x00000000;
00002e  2100              MOVS     r1,#0
000030  6081              STR      r1,[r0,#8]
;;;143    }
000032  4770              BX       lr
;;;144    
                          ENDP

                  |L12.52|
                          DCD      0x40021000
                  |L12.56|
                          DCD      0xf8ff0000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;667    *******************************************************************************/
;;;668    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  4a24              LDR      r2,|L13.148|
;;;669    {
000002  b410              PUSH     {r4}
;;;670      u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;671    
;;;672      /* Get SYSCLK source -------------------------------------------------------*/
;;;673      tmp = RCC->CFGR & CFGR_SWS_Mask;
000004  6851              LDR      r1,[r2,#4]
;;;674    
;;;675      switch (tmp)
;;;676      {
;;;677        case 0x00:  /* HSI used as system clock */
;;;678          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
000006  4b24              LDR      r3,|L13.152|
000008  f011010c          ANDS     r1,r1,#0xc            ;673
00000c  bf18              IT       NE                    ;675
00000e  2904              CMPNE    r1,#4                 ;675
000010  d001              BEQ      |L13.22|
000012  2908              CMP      r1,#8                 ;675
000014  d001              BEQ      |L13.26|
                  |L13.22|
;;;679          break;
000016  6003              STR      r3,[r0,#0]
000018  e014              B        |L13.68|
                  |L13.26|
;;;680    
;;;681        case 0x04:  /* HSE used as system clock */
;;;682          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
;;;683          break;
;;;684    
;;;685        case 0x08:  /* PLL used as system clock */
;;;686          /* Get PLL clock source and multiplication factor ----------------------*/
;;;687          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00001a  6851              LDR      r1,[r2,#4]
;;;688          pllmull = ( pllmull >> 18) + 2;
00001c  2302              MOVS     r3,#2
00001e  f4011170          AND      r1,r1,#0x3c0000       ;687
000022  eb034191          ADD      r1,r3,r1,LSR #18
;;;689    
;;;690          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000026  6853              LDR      r3,[r2,#4]
000028  f4133f80          TST      r3,#0x10000
;;;691    
;;;692          if (pllsource == 0x00)
00002c  d003              BEQ      |L13.54|
;;;693          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;694            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
;;;695          }
;;;696          else
;;;697          {/* HSE selected as PLL clock entry */
;;;698    
;;;699            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
00002e  6853              LDR      r3,[r2,#4]
000030  f4133f00          TST      r3,#0x20000
000034  d003              BEQ      |L13.62|
                  |L13.54|
;;;700            {/* HSE oscillator clock divided by 2 */
;;;701    
;;;702              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
000036  4b19              LDR      r3,|L13.156|
000038  4359              MULS     r1,r3,r1
00003a  6001              STR      r1,[r0,#0]
00003c  e002              B        |L13.68|
                  |L13.62|
;;;703            }
;;;704            else
;;;705            {
;;;706              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
00003e  4b16              LDR      r3,|L13.152|
000040  4359              MULS     r1,r3,r1
000042  6001              STR      r1,[r0,#0]
                  |L13.68|
;;;707            }
;;;708          }
;;;709          break;
;;;710    
;;;711        default:
;;;712          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
;;;713          break;
;;;714      }
;;;715    
;;;716      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;717      /* Get HCLK prescaler */
;;;718      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000044  6851              LDR      r1,[r2,#4]
;;;719      tmp = tmp >> 4;
;;;720      presc = APBAHBPrescTable[tmp];
;;;721    
;;;722      /* HCLK clock frequency */
;;;723      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;724    
;;;725      /* Get PCLK1 prescaler */
;;;726      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
;;;727      tmp = tmp >> 8;
;;;728      presc = APBAHBPrescTable[tmp];
;;;729    
;;;730      /* PCLK1 clock frequency */
;;;731      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;732    
;;;733      /* Get PCLK2 prescaler */
;;;734      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
;;;735      tmp = tmp >> 11;
;;;736      presc = APBAHBPrescTable[tmp];
;;;737    
;;;738      /* PCLK2 clock frequency */
;;;739      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;740    
;;;741      /* Get ADCCLK prescaler */
;;;742      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
;;;743      tmp = tmp >> 14;
;;;744      presc = ADCPrescTable[tmp];
;;;745    
;;;746      /* ADCCLK clock frequency */
;;;747      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
;;;748    }
000046  230f              MOVS     r3,#0xf
000048  f8dfc054          LDR      r12,|L13.160|
00004c  ea031111          AND      r1,r3,r1,LSR #4
000050  6803              LDR      r3,[r0,#0]            ;723
000052  f81c1001          LDRB     r1,[r12,r1]           ;720
000056  fa23f101          LSR      r1,r3,r1              ;723
00005a  6041              STR      r1,[r0,#4]            ;726
00005c  6853              LDR      r3,[r2,#4]            ;726
00005e  2407              MOVS     r4,#7
000060  ea042313          AND      r3,r4,r3,LSR #8
000064  f81c3003          LDRB     r3,[r12,r3]           ;728
000068  fa21f303          LSR      r3,r1,r3              ;731
00006c  6083              STR      r3,[r0,#8]            ;734
00006e  6853              LDR      r3,[r2,#4]            ;734
000070  ea0423d3          AND      r3,r4,r3,LSR #11
000074  f81c3003          LDRB     r3,[r12,r3]           ;736
000078  40d9              LSRS     r1,r1,r3              ;739
00007a  60c1              STR      r1,[r0,#0xc]          ;742
00007c  6852              LDR      r2,[r2,#4]            ;742
00007e  2303              MOVS     r3,#3
000080  ea033292          AND      r2,r3,r2,LSR #14
000084  f1ac0304          SUB      r3,r12,#4             ;744
000088  5c9a              LDRB     r2,[r3,r2]            ;744
00008a  fbb1f1f2          UDIV     r1,r1,r2              ;747
00008e  6101              STR      r1,[r0,#0x10]         ;747
000090  bc10              POP      {r4}
000092  4770              BX       lr
;;;749    
                          ENDP

                  |L13.148|
                          DCD      0x40021000
                  |L13.152|
                          DCD      0x007a1200
                  |L13.156|
                          DCD      0x003d0900
                  |L13.160|
                          DCD      ||.constdata||+0x4

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;988    *******************************************************************************/
;;;989    FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
000000  2200              MOVS     r2,#0
;;;990    {
;;;991      u32 tmp = 0;
;;;992      u32 statusreg = 0;
;;;993      FlagStatus bitstatus = RESET;
;;;994    
;;;995      /* Check the parameters */
;;;996      assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;997    
;;;998      /* Get the RCC register index */
;;;999      tmp = RCC_FLAG >> 5;
000002  0941              LSRS     r1,r0,#5
;;;1000   
;;;1001     if (tmp == 1)               /* The flag to check is in CR register */
;;;1002     {
;;;1003       statusreg = RCC->CR;
000004  4b09              LDR      r3,|L14.44|
000006  2901              CMP      r1,#1                 ;1001
000008  bf08              IT       EQ
00000a  6819              LDREQ    r1,[r3,#0]
00000c  d003              BEQ      |L14.22|
;;;1004     }
;;;1005     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000e  2902              CMP      r1,#2
;;;1006     {
;;;1007       statusreg = RCC->BDCR;
000010  bf0c              ITE      EQ
000012  6a19              LDREQ    r1,[r3,#0x20]
;;;1008     }
;;;1009     else                       /* The flag to check is in CSR register */
;;;1010     {
;;;1011       statusreg = RCC->CSR;
000014  6a59              LDRNE    r1,[r3,#0x24]
                  |L14.22|
;;;1012     }
;;;1013   
;;;1014     /* Get the flag position */
;;;1015     tmp = RCC_FLAG & FLAG_Mask;
000016  f000001f          AND      r0,r0,#0x1f
;;;1016   
;;;1017     if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)
00001a  2301              MOVS     r3,#1
00001c  fa03f000          LSL      r0,r3,r0
000020  4208              TST      r0,r1
;;;1018     {
;;;1019       bitstatus = SET;
000022  bf18              IT       NE
000024  2201              MOVNE    r2,#1
;;;1020     }
;;;1021     else
;;;1022     {
;;;1023       bitstatus = RESET;
;;;1024     }
;;;1025   
;;;1026     /* Return the flag status */
;;;1027     return bitstatus;
000026  4610              MOV      r0,r2
;;;1028   }
000028  4770              BX       lr
;;;1029   
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1059   *******************************************************************************/
;;;1060   ITStatus RCC_GetITStatus(u8 RCC_IT)
000000  4a03              LDR      r2,|L15.16|
;;;1061   {
000002  4601              MOV      r1,r0
;;;1062     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1063   
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1066   
;;;1067     /* Check the status of the specified RCC interrupt */
;;;1068     if ((RCC->CIR & RCC_IT) != (u32)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
;;;1069     {
;;;1070       bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;1071     }
;;;1072     else
;;;1073     {
;;;1074       bitstatus = RESET;
;;;1075     }
;;;1076   
;;;1077     /* Return the RCC_IT status */
;;;1078     return  bitstatus;
;;;1079   }
00000e  4770              BX       lr
;;;1080   
                          ENDP

                  |L15.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;364    *******************************************************************************/
;;;365    u8 RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;366    {
;;;367      return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;368    }
000008  4770              BX       lr
;;;369    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;387    *******************************************************************************/
;;;388    void RCC_HCLKConfig(u32 RCC_SYSCLK)
000000  4a03              LDR      r2,|L17.16|
;;;389    {
;;;390      u32 tmpreg = 0;
;;;391    
;;;392      /* Check the parameters */
;;;393      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;394    
;;;395      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;396    
;;;397      /* Clear HPRE[3:0] bits */
;;;398      tmpreg &= CFGR_HPRE_Reset_Mask;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;399    
;;;400      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;401      tmpreg |= RCC_SYSCLK;
000008  4308              ORRS     r0,r0,r1
;;;402    
;;;403      /* Store the new value */
;;;404      RCC->CFGR = tmpreg;
00000a  6050              STR      r0,[r2,#4]
;;;405    }
00000c  4770              BX       lr
;;;406    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;158    *******************************************************************************/
;;;159    void RCC_HSEConfig(u32 RCC_HSE)
000000  490c              LDR      r1,|L18.52|
;;;160    {
;;;161      /* Check the parameters */
;;;162      assert_param(IS_RCC_HSE(RCC_HSE));
;;;163    
;;;164      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;165      /* Reset HSEON bit */
;;;166      RCC->CR &= CR_HSEON_Reset;
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;167    
;;;168      /* Reset HSEBYP bit */
;;;169      RCC->CR &= CR_HSEBYP_Reset;
00000a  680a              LDR      r2,[r1,#0]
00000c  f4222280          BIC      r2,r2,#0x40000
000010  600a              STR      r2,[r1,#0]
;;;170    
;;;171      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;172      switch(RCC_HSE)
000012  f5b03f80          CMP      r0,#0x10000
;;;173      {
;;;174        case RCC_HSE_ON:
;;;175          /* Set HSEON bit */
;;;176          RCC->CR |= CR_HSEON_Set;
000016  bf04              ITT      EQ
000018  6808              LDREQ    r0,[r1,#0]
00001a  f4403080          ORREQ    r0,r0,#0x10000
00001e  d006              BEQ      |L18.46|
000020  f5b02f80          CMP      r0,#0x40000           ;172
;;;177          break;
;;;178          
;;;179        case RCC_HSE_Bypass:
;;;180          /* Set HSEBYP and HSEON bits */
;;;181          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000024  bf06              ITTE     EQ
000026  6808              LDREQ    r0,[r1,#0]
000028  f44020a0          ORREQ    r0,r0,#0x50000
;;;182          break;            
;;;183          
;;;184        default:
;;;185          break;      
;;;186      }
;;;187    }
00002c  4770              BXNE     lr
                  |L18.46|
00002e  6008              STR      r0,[r1,#0]            ;181
000030  4770              BX       lr
;;;188    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;261    *******************************************************************************/
;;;262    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;263    {
;;;264      /* Check the parameters */
;;;265      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;266    
;;;267      *(vu32 *) CR_HSION_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;268    }
000004  4770              BX       lr
;;;269    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;488    *******************************************************************************/
;;;489    void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L20.20|
;;;490    {
;;;491      /* Check the parameters */
;;;492      assert_param(IS_RCC_IT(RCC_IT));
;;;493      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;494    
;;;495      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;496      {
;;;497        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;498        *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;499      }
;;;500      else
;;;501      {
;;;502        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;503        *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  bf14              ITE      NE                    ;498
000008  4308              ORRNE    r0,r0,r1              ;498
00000a  ea210000          BICEQ    r0,r1,r0
00000e  7250              STRB     r0,[r2,#9]            ;498
;;;504      }
;;;505    }
000010  4770              BX       lr
;;;506    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;571    *******************************************************************************/
;;;572    void RCC_LSEConfig(u8 RCC_LSE)
000000  4907              LDR      r1,|L21.32|
;;;573    {
;;;574      /* Check the parameters */
;;;575      assert_param(IS_RCC_LSE(RCC_LSE));
;;;576    
;;;577      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;578      /* Reset LSEON bit */
;;;579      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  f8812020          STRB     r2,[r1,#0x20]
;;;580    
;;;581      /* Reset LSEBYP bit */
;;;582      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
000008  f8812020          STRB     r2,[r1,#0x20]
;;;583    
;;;584      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;585      switch(RCC_LSE)
00000c  2801              CMP      r0,#1
00000e  d003              BEQ      |L21.24|
000010  2804              CMP      r0,#4
;;;586      {
;;;587        case RCC_LSE_ON:
;;;588          /* Set LSEON bit */
;;;589          *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
;;;590          break;
;;;591          
;;;592        case RCC_LSE_Bypass:
;;;593          /* Set LSEBYP and LSEON bits */
;;;594          *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000012  bf0c              ITE      EQ
000014  2005              MOVEQ    r0,#5
;;;595          break;            
;;;596          
;;;597        default:
;;;598          break;      
;;;599      }
;;;600    }
000016  4770              BXNE     lr
                  |L21.24|
000018  f8810020          STRB     r0,[r1,#0x20]         ;594
00001c  4770              BX       lr
;;;601    
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      0x40021000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;610    *******************************************************************************/
;;;611    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;612    {
;;;613      /* Check the parameters */
;;;614      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;615    
;;;616      *(vu32 *) CSR_LSION_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;617    }
000004  4770              BX       lr
;;;618    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;960    *******************************************************************************/
;;;961    void RCC_MCOConfig(u8 RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;962    {
;;;963      /* Check the parameters */
;;;964      assert_param(IS_RCC_MCO(RCC_MCO));
;;;965    
;;;966      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;967      *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;968    }
000004  4770              BX       lr
;;;969    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;420    *******************************************************************************/
;;;421    void RCC_PCLK1Config(u32 RCC_HCLK)
000000  4a03              LDR      r2,|L24.16|
;;;422    {
;;;423      u32 tmpreg = 0;
;;;424    
;;;425      /* Check the parameters */
;;;426      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;427    
;;;428      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;429    
;;;430      /* Clear PPRE1[2:0] bits */
;;;431      tmpreg &= CFGR_PPRE1_Reset_Mask;
000004  f42161e0          BIC      r1,r1,#0x700
;;;432    
;;;433      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;434      tmpreg |= RCC_HCLK;
000008  4308              ORRS     r0,r0,r1
;;;435    
;;;436      /* Store the new value */
;;;437      RCC->CFGR = tmpreg;
00000a  6050              STR      r0,[r2,#4]
;;;438    }
00000c  4770              BX       lr
;;;439    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;453    *******************************************************************************/
;;;454    void RCC_PCLK2Config(u32 RCC_HCLK)
000000  4a03              LDR      r2,|L25.16|
;;;455    {
;;;456      u32 tmpreg = 0;
;;;457    
;;;458      /* Check the parameters */
;;;459      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;460    
;;;461      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;462    
;;;463      /* Clear PPRE2[2:0] bits */
;;;464      tmpreg &= CFGR_PPRE2_Reset_Mask;
000004  f4215160          BIC      r1,r1,#0x3800
;;;465    
;;;466      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;467      tmpreg |= RCC_HCLK << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;468    
;;;469      /* Store the new value */
;;;470      RCC->CFGR = tmpreg;
00000c  6050              STR      r0,[r2,#4]
;;;471    }
00000e  4770              BX       lr
;;;472    
                          ENDP

                  |L25.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;315    *******************************************************************************/
;;;316    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;317    {
;;;318      /* Check the parameters */
;;;319      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;320    
;;;321      *(vu32 *) CR_PLLON_BB = (u32)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;322    }
000004  4770              BX       lr
;;;323    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;286    *******************************************************************************/
;;;287    void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
000000  4b03              LDR      r3,|L27.16|
;;;288    {
;;;289      u32 tmpreg = 0;
;;;290    
;;;291      /* Check the parameters */
;;;292      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;293      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;294    
;;;295      tmpreg = RCC->CFGR;
000002  685a              LDR      r2,[r3,#4]
;;;296    
;;;297      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;298      tmpreg &= CFGR_PLL_Mask;
;;;299    
;;;300      /* Set the PLL configuration bits */
;;;301      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000004  4308              ORRS     r0,r0,r1
000006  f422127c          BIC      r2,r2,#0x3f0000       ;298
00000a  4310              ORRS     r0,r0,r2
;;;302    
;;;303      /* Store the new value */
;;;304      RCC->CFGR = tmpreg;
00000c  6058              STR      r0,[r3,#4]
;;;305    }
00000e  4770              BX       lr
;;;306    
                          ENDP

                  |L27.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;651    *******************************************************************************/
;;;652    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;653    {
;;;654      /* Check the parameters */
;;;655      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;656    
;;;657      *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;658    }
000004  4770              BX       lr
;;;659    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;632    *******************************************************************************/
;;;633    void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;634    {
;;;635      /* Check the parameters */
;;;636      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;637    
;;;638      /* Select the RTC clock source */
;;;639      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4310              ORRS     r0,r0,r2
000006  6208              STR      r0,[r1,#0x20]
;;;640    }
000008  4770              BX       lr
;;;641    
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;334    *******************************************************************************/
;;;335    void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L30.16|
;;;336    {
;;;337      u32 tmpreg = 0;
;;;338    
;;;339      /* Check the parameters */
;;;340      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;341    
;;;342      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;343    
;;;344      /* Clear SW[1:0] bits */
;;;345      tmpreg &= CFGR_SW_Mask;
000004  f0210103          BIC      r1,r1,#3
;;;346    
;;;347      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;348      tmpreg |= RCC_SYSCLKSource;
000008  4308              ORRS     r0,r0,r1
;;;349    
;;;350      /* Store the new value */
;;;351      RCC->CFGR = tmpreg;
00000a  6050              STR      r0,[r2,#4]
;;;352    }
00000c  4770              BX       lr
;;;353    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;519    *******************************************************************************/
;;;520    void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;521    {
;;;522      /* Check the parameters */
;;;523      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;524    
;;;525      *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  f8c100d8          STR      r0,[r1,#0xd8]
;;;526    }
000006  4770              BX       lr
;;;527    
                          ENDP

                  |L31.8|
                          DCD      0x42420000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=2

                  RCC_WaitForHSEStartUp PROC
;;;197    *******************************************************************************/
;;;198    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b508              PUSH     {r3,lr}
;;;199    {
;;;200      vu32 StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  4a0a              LDR      r2,|L32.48|
000006  9000              STR      r0,[sp,#0]
                  |L32.8|
000008  2000              MOVS     r0,#0
00000a  6811              LDR      r1,[r2,#0]
00000c  f4113f00          TST      r1,#0x20000
000010  bf18              IT       NE
000012  2001              MOVNE    r0,#1
;;;201      ErrorStatus status = ERROR;
;;;202      FlagStatus HSEStatus = RESET;
;;;203      
;;;204      /* Wait till HSE is ready and if Time out is reached exit */
;;;205      do
;;;206      {
;;;207        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;208        StartUpCounter++;  
000014  9900              LDR      r1,[sp,#0]
000016  1c49              ADDS     r1,r1,#1
000018  9100              STR      r1,[sp,#0]
00001a  b910              CBNZ     r0,|L32.34|
;;;209      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
00001c  f5b16fa0          CMP      r1,#0x500
000020  d1f2              BNE      |L32.8|
                  |L32.34|
;;;210    
;;;211    
;;;212      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000022  2031              MOVS     r0,#0x31
000024  f7fffffe          BL       RCC_GetFlagStatus
000028  2800              CMP      r0,#0
;;;213      {
;;;214        status = SUCCESS;
00002a  bf18              IT       NE
00002c  2001              MOVNE    r0,#1
;;;215      }
;;;216      else
;;;217      {
;;;218        status = ERROR;
;;;219      }  
;;;220    
;;;221      return (status);
;;;222    }
00002e  bd08              POP      {r3,pc}
;;;223    
                          ENDP

                  |L32.48|
                          DCD      0x40021000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
