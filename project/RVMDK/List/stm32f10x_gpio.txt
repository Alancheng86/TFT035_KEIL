; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_gpio.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_gpio.d --cpu=Cortex-M3 --apcs=interwork -Otime --diag_suppress=9931 -I..\..\project -I..\..\library\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 -DVECT_TAB_FLASH --omf_browse=.\obj\stm32f10x_gpio.crf ..\..\library\src\stm32f10x_gpio.c]
                          THUMB

                          AREA ||i.GPIO_AFIODeInit||, CODE, READONLY, ALIGN=1

                  GPIO_AFIODeInit PROC
;;;106    *******************************************************************************/
;;;107    void GPIO_AFIODeInit(void)
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109      RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;110      RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2001              MOVS     r0,#1
000012  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;111    }
;;;112    
                          ENDP


                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;50     *******************************************************************************/
;;;51     void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  4a31              LDR      r2,|L2.200|
;;;52     {
000002  b510              PUSH     {r4,lr}
;;;53       /* Check the parameters */
;;;54       assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;55       
;;;56       switch (*(u32*)&GPIOx)
000004  1a81              SUBS     r1,r0,r2
000006  4290              CMP      r0,r2
000008  d03f              BEQ      |L2.138|
00000a  dc15              BGT      |L2.56|
00000c  f5a03084          SUB      r0,r0,#0x10800
000010  f1b04080          SUBS     r0,r0,#0x40000000
000014  d025              BEQ      |L2.98|
000016  f5b06f80          CMP      r0,#0x400
00001a  d02c              BEQ      |L2.118|
00001c  f5b06f00          CMP      r0,#0x800
;;;57       {
;;;58         case GPIOA_BASE:
;;;59           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
;;;60           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
;;;61           break;
;;;62     
;;;63         case GPIOB_BASE:
;;;64           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
;;;65           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
;;;66           break;
;;;67     
;;;68         case GPIOC_BASE:
;;;69           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
;;;70           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
;;;71           break;
;;;72     
;;;73         case GPIOD_BASE:
;;;74           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
;;;75           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
;;;76           break;
;;;77           
;;;78         case GPIOE_BASE:
;;;79           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
;;;80           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
;;;81           break; 
;;;82     
;;;83         case GPIOF_BASE:
;;;84           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
;;;85           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
;;;86           break;
;;;87     
;;;88         case GPIOG_BASE:
;;;89           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
;;;90           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
;;;91           break;                       
;;;92     
;;;93         default:
;;;94           break;
;;;95       }
;;;96     }
000020  bf18              IT       NE
000022  bd10              POPNE    {r4,pc}
000024  2101              MOVS     r1,#1                 ;69
000026  2010              MOVS     r0,#0x10              ;69
000028  f7fffffe          BL       RCC_APB2PeriphResetCmd
00002c  2100              MOVS     r1,#0                 ;70
00002e  e8bd4010          POP      {r4,lr}               ;70
000032  2010              MOVS     r0,#0x10              ;70
000034  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L2.56|
000038  f5b16f80          CMP      r1,#0x400             ;56
00003c  d02f              BEQ      |L2.158|
00003e  f5b16f00          CMP      r1,#0x800             ;56
000042  d036              BEQ      |L2.178|
000044  f5b16f40          CMP      r1,#0xc00             ;56
000048  bf18              IT       NE
00004a  bd10              POPNE    {r4,pc}
00004c  2101              MOVS     r1,#1                 ;89
00004e  0208              LSLS     r0,r1,#8              ;89
000050  f7fffffe          BL       RCC_APB2PeriphResetCmd
000054  e8bd4010          POP      {r4,lr}               ;90
000058  2100              MOVS     r1,#0                 ;90
00005a  f44f7080          MOV      r0,#0x100             ;90
00005e  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L2.98|
000062  2101              MOVS     r1,#1                 ;59
000064  2004              MOVS     r0,#4                 ;59
000066  f7fffffe          BL       RCC_APB2PeriphResetCmd
00006a  2100              MOVS     r1,#0                 ;60
00006c  e8bd4010          POP      {r4,lr}               ;60
000070  2004              MOVS     r0,#4                 ;60
000072  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L2.118|
000076  2101              MOVS     r1,#1                 ;64
000078  2008              MOVS     r0,#8                 ;64
00007a  f7fffffe          BL       RCC_APB2PeriphResetCmd
00007e  2100              MOVS     r1,#0                 ;65
000080  e8bd4010          POP      {r4,lr}               ;65
000084  2008              MOVS     r0,#8                 ;65
000086  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L2.138|
00008a  2101              MOVS     r1,#1                 ;74
00008c  2020              MOVS     r0,#0x20              ;74
00008e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000092  2100              MOVS     r1,#0                 ;75
000094  e8bd4010          POP      {r4,lr}               ;75
000098  2020              MOVS     r0,#0x20              ;75
00009a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L2.158|
00009e  2101              MOVS     r1,#1                 ;79
0000a0  2040              MOVS     r0,#0x40              ;79
0000a2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000a6  2100              MOVS     r1,#0                 ;80
0000a8  e8bd4010          POP      {r4,lr}               ;80
0000ac  2040              MOVS     r0,#0x40              ;80
0000ae  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L2.178|
0000b2  2101              MOVS     r1,#1                 ;84
0000b4  2080              MOVS     r0,#0x80              ;84
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000ba  2100              MOVS     r1,#0                 ;85
0000bc  e8bd4010          POP      {r4,lr}               ;85
0000c0  2080              MOVS     r0,#0x80              ;85
0000c2  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;97     
                          ENDP

0000c6  0000              DCW      0x0000
                  |L2.200|
                          DCD      0x40011400

                          AREA ||i.GPIO_EXTILineConfig||, CODE, READONLY, ALIGN=1

                  GPIO_EXTILineConfig PROC
;;;568    *******************************************************************************/
;;;569    void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
000000  078a              LSLS     r2,r1,#30
;;;570    {
;;;571      u32 tmp = 0x00;
;;;572    
;;;573      /* Check the parameters */
;;;574      assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
;;;575      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;576      
;;;577      tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
;;;578    
;;;579      AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
000002  f0210103          BIC      r1,r1,#3
000006  f1014180          ADD      r1,r1,#0x40000000
00000a  f5013180          ADD      r1,r1,#0x10000
00000e  0f12              LSRS     r2,r2,#28             ;577
000010  230f              MOVS     r3,#0xf               ;577
000012  f8d1c008          LDR      r12,[r1,#8]
000016  4093              LSLS     r3,r3,r2              ;577
000018  ea2c0303          BIC      r3,r12,r3
00001c  608b              STR      r3,[r1,#8]
;;;580      AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
00001e  688b              LDR      r3,[r1,#8]
000020  4090              LSLS     r0,r0,r2
000022  4318              ORRS     r0,r0,r3
000024  6088              STR      r0,[r1,#8]
;;;581    }
000026  4770              BX       lr
;;;582    
                          ENDP


                          AREA ||i.GPIO_EventOutputCmd||, CODE, READONLY, ALIGN=2

                  GPIO_EventOutputCmd PROC
;;;475    *******************************************************************************/
;;;476    void GPIO_EventOutputCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L4.8|
;;;477    {
;;;478      /* Check the parameters */
;;;479      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;480      
;;;481      *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
000002  61c8              STR      r0,[r1,#0x1c]
;;;482    }
000004  4770              BX       lr
;;;483    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x42200000

                          AREA ||i.GPIO_EventOutputConfig||, CODE, READONLY, ALIGN=2

                  GPIO_EventOutputConfig PROC
;;;450    *******************************************************************************/
;;;451    void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
000000  4b05              LDR      r3,|L5.24|
;;;452    {
;;;453      u32 tmpreg = 0x00;
;;;454    
;;;455      /* Check the parameters */
;;;456      assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
;;;457      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;458        
;;;459      tmpreg = AFIO->EVCR;
000002  681a              LDR      r2,[r3,#0]
;;;460      /* Clear the PORT[6:4] and PIN[3:0] bits */
;;;461      tmpreg &= EVCR_PORTPINCONFIG_MASK;
000004  f64f7c80          MOV      r12,#0xff80
000008  ea02020c          AND      r2,r2,r12
;;;462      tmpreg |= (u32)GPIO_PortSource << 0x04;
00000c  ea421000          ORR      r0,r2,r0,LSL #4
;;;463      tmpreg |= GPIO_PinSource;
000010  4308              ORRS     r0,r0,r1
;;;464    
;;;465      AFIO->EVCR = tmpreg;
000012  6018              STR      r0,[r3,#0]
;;;466    }
000014  4770              BX       lr
;;;467    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40010000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;123    *******************************************************************************/
;;;124    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
000000  e92d01f0          PUSH     {r4-r8}
;;;125    {
;;;126      u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
;;;127      u32 tmpreg = 0x00, pinmask = 0x00;
;;;128    
;;;129      /* Check the parameters */
;;;130      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;131      assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;132      assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
;;;133      
;;;134    /*---------------------------- GPIO Mode Configuration -----------------------*/
;;;135      currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
000004  f891c003          LDRB     r12,[r1,#3]
000008  2200              MOVS     r2,#0                 ;126
00000a  f00c030f          AND      r3,r12,#0xf
;;;136    
;;;137      if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
00000e  f01c0f10          TST      r12,#0x10
;;;138      { 
;;;139        /* Check the parameters */
;;;140        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;141        /* Output mode */
;;;142        currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
000012  bf1c              ITT      NE
000014  f891c002          LDRBNE   r12,[r1,#2]
000018  ea4c0303          ORRNE    r3,r12,r3
;;;143      }
;;;144    
;;;145    /*---------------------------- GPIO CRL Configuration ------------------------*/
;;;146      /* Configure the eight low port pins */
;;;147      if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
00001c  f891c000          LDRB     r12,[r1,#0]
;;;148      {
;;;149        tmpreg = GPIOx->CRL;
;;;150    
;;;151        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
;;;152        {
;;;153          pos = ((u32)0x01) << pinpos;
;;;154          /* Get the port pins position */
;;;155          currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
;;;156    
;;;157          if (currentpin == pos)
;;;158          {
;;;159            pos = pinpos << 2;
;;;160            /* Clear the corresponding low control register bits */
;;;161            pinmask = ((u32)0x0F) << pos;
000020  f04f070f          MOV      r7,#0xf
000024  f01c0fff          TST      r12,#0xff             ;147
000028  f04f0601          MOV      r6,#1                 ;153
00002c  bf18              IT       NE                    ;149
00002e  6804              LDRNE    r4,[r0,#0]            ;149
000030  d01c              BEQ      |L6.108|
                  |L6.50|
000032  880d              LDRH     r5,[r1,#0]            ;155
000034  fa06fc02          LSL      r12,r6,r2             ;153
000038  ea05050c          AND      r5,r5,r12             ;155
00003c  4565              CMP      r5,r12                ;157
00003e  d111              BNE      |L6.100|
000040  0095              LSLS     r5,r2,#2              ;159
000042  fa07f805          LSL      r8,r7,r5
;;;162            tmpreg &= ~pinmask;
000046  ea240408          BIC      r4,r4,r8
;;;163    
;;;164            /* Write the mode configuration in the corresponding bits */
;;;165            tmpreg |= (currentmode << pos);
00004a  fa03f505          LSL      r5,r3,r5
00004e  432c              ORRS     r4,r4,r5
;;;166    
;;;167            /* Reset the corresponding ODR bit */
;;;168            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
000050  78cd              LDRB     r5,[r1,#3]
000052  2d28              CMP      r5,#0x28
;;;169            {
;;;170              GPIOx->BRR = (((u32)0x01) << pinpos);
000054  bf08              IT       EQ
000056  f8c0c014          STREQ    r12,[r0,#0x14]
00005a  d003              BEQ      |L6.100|
;;;171            }
;;;172            else
;;;173            {
;;;174              /* Set the corresponding ODR bit */
;;;175              if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
00005c  2d48              CMP      r5,#0x48
;;;176              {
;;;177                GPIOx->BSRR = (((u32)0x01) << pinpos);
00005e  bf08              IT       EQ
000060  f8c0c010          STREQ    r12,[r0,#0x10]
                  |L6.100|
000064  1c52              ADDS     r2,r2,#1
000066  2a08              CMP      r2,#8                 ;151
000068  d3e3              BCC      |L6.50|
;;;178              }
;;;179            }
;;;180          }
;;;181        }
;;;182        GPIOx->CRL = tmpreg;
00006a  6004              STR      r4,[r0,#0]
                  |L6.108|
;;;183      }
;;;184    
;;;185    /*---------------------------- GPIO CRH Configuration ------------------------*/
;;;186      /* Configure the eight high port pins */
;;;187      if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
00006c  880a              LDRH     r2,[r1,#0]
00006e  2aff              CMP      r2,#0xff
;;;188      {
;;;189        tmpreg = GPIOx->CRH;
000070  bf87              ITTEE    HI
000072  6844              LDRHI    r4,[r0,#4]
;;;190        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
000074  2200              MOVHI    r2,#0
;;;191        {
;;;192          pos = (((u32)0x01) << (pinpos + 0x08));
;;;193          /* Get the port pins position */
;;;194          currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
;;;195          if (currentpin == pos)
;;;196          {
;;;197            pos = pinpos << 2;
;;;198            /* Clear the corresponding high control register bits */
;;;199            pinmask = ((u32)0x0F) << pos;
;;;200            tmpreg &= ~pinmask;
;;;201    
;;;202            /* Write the mode configuration in the corresponding bits */
;;;203            tmpreg |= (currentmode << pos);
;;;204    
;;;205            /* Reset the corresponding ODR bit */
;;;206            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
;;;207            {
;;;208              GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
;;;209            }
;;;210            /* Set the corresponding ODR bit */
;;;211            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
;;;212            {
;;;213              GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
;;;214            }
;;;215          }
;;;216        }
;;;217        GPIOx->CRH = tmpreg;
;;;218      }
;;;219    }
000076  e8bd01f0          POPLS    {r4-r8}
00007a  4770              BXLS     lr
                  |L6.124|
00007c  f1020c08          ADD      r12,r2,#8             ;192
000080  880d              LDRH     r5,[r1,#0]            ;194
000082  fa06fc0c          LSL      r12,r6,r12            ;192
000086  ea05050c          AND      r5,r5,r12             ;194
00008a  4565              CMP      r5,r12                ;195
00008c  d111              BNE      |L6.178|
00008e  0095              LSLS     r5,r2,#2              ;197
000090  fa07f805          LSL      r8,r7,r5              ;199
000094  ea240408          BIC      r4,r4,r8              ;200
000098  fa03f505          LSL      r5,r3,r5              ;203
00009c  432c              ORRS     r4,r4,r5              ;203
00009e  78cd              LDRB     r5,[r1,#3]            ;206
0000a0  2d28              CMP      r5,#0x28              ;206
0000a2  bf08              IT       EQ                    ;208
0000a4  f8c0c014          STREQ    r12,[r0,#0x14]        ;208
0000a8  78cd              LDRB     r5,[r1,#3]            ;211
0000aa  2d48              CMP      r5,#0x48              ;211
0000ac  bf08              IT       EQ                    ;213
0000ae  f8c0c010          STREQ    r12,[r0,#0x10]        ;213
                  |L6.178|
0000b2  1c52              ADDS     r2,r2,#1              ;213
0000b4  2a08              CMP      r2,#8                 ;190
0000b6  d3e1              BCC      |L6.124|
0000b8  6044              STR      r4,[r0,#4]            ;217
0000ba  e8bd01f0          POP      {r4-r8}
0000be  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;417    *******************************************************************************/
;;;418    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  f4413280          ORR      r2,r1,#0x10000
;;;419    {
;;;420      u32 tmp = 0x00010000;
;;;421      
;;;422      /* Check the parameters */
;;;423      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;424      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;425      
;;;426      tmp |= GPIO_Pin;
;;;427      /* Set LCKK bit */
;;;428      GPIOx->LCKR = tmp;
000004  6182              STR      r2,[r0,#0x18]
;;;429      /* Reset LCKK bit */
;;;430      GPIOx->LCKR =  GPIO_Pin;
000006  6181              STR      r1,[r0,#0x18]
;;;431      /* Set LCKK bit */
;;;432      GPIOx->LCKR = tmp;
000008  6182              STR      r2,[r0,#0x18]
;;;433      /* Read LCKK bit*/
;;;434      tmp = GPIOx->LCKR;
00000a  6981              LDR      r1,[r0,#0x18]
;;;435      /* Read LCKK bit*/
;;;436      tmp = GPIOx->LCKR;
00000c  6980              LDR      r0,[r0,#0x18]
;;;437    }
00000e  4770              BX       lr
;;;438    
                          ENDP


                          AREA ||i.GPIO_PinRemapConfig||, CODE, READONLY, ALIGN=2

                  GPIO_PinRemapConfig PROC
;;;518    *******************************************************************************/
;;;519    void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
000000  b470              PUSH     {r4-r6}
;;;520    {
;;;521      u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
;;;522    
;;;523      /* Check the parameters */
;;;524      assert_param(IS_GPIO_REMAP(GPIO_Remap));
;;;525      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;526      
;;;527      tmpreg = AFIO->MAPR;
000002  4c14              LDR      r4,|L8.84|
000004  6862              LDR      r2,[r4,#4]
;;;528    
;;;529      tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
;;;530      tmp = GPIO_Remap & LSB_MASK;
;;;531    
;;;532      if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
000006  f44f1340          MOV      r3,#0x300000
00000a  ea330500          BICS     r5,r3,r0
;;;533      {
;;;534        tmpreg &= DBGAFR_SWJCFG_MASK;
;;;535        AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
;;;536      }
;;;537      else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
;;;538      {
;;;539        tmp1 = ((u32)0x03) << tmpmask;
;;;540        tmpreg &= ~tmp1;
;;;541        tmpreg |= ~DBGAFR_SWJCFG_MASK;
;;;542      }
;;;543      else
;;;544      {
;;;545        tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
00000e  ea4f5350          LSR      r3,r0,#21
000012  ea4f1303          LSL      r3,r3,#4
000016  b286              UXTH     r6,r0                 ;530
000018  f3c04c03          UBFX     r12,r0,#16,#4         ;529
00001c  fa06f303          LSL      r3,r6,r3
000020  d00c              BEQ      |L8.60|
000022  f4101f80          TST      r0,#0x100000          ;537
000026  bf0f              ITEEE    EQ
000028  ea220003          BICEQ    r0,r2,r3
00002c  2003              MOVNE    r0,#3                 ;539
00002e  fa00f00c          LSLNE    r0,r0,r12             ;539
000032  ea220000          BICNE    r0,r2,r0              ;540
000036  f0406070          ORR      r0,r0,#0xf000000      ;541
00003a  e005              B        |L8.72|
                  |L8.60|
00003c  f0226070          BIC      r0,r2,#0xf000000      ;534
000040  6862              LDR      r2,[r4,#4]            ;535
000042  f0226270          BIC      r2,r2,#0xf000000      ;535
000046  6062              STR      r2,[r4,#4]            ;535
                  |L8.72|
;;;546        tmpreg |= ~DBGAFR_SWJCFG_MASK;
;;;547      }
;;;548    
;;;549      if (NewState != DISABLE)
000048  2900              CMP      r1,#0
;;;550      {
;;;551        tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
00004a  bf18              IT       NE
00004c  4318              ORRNE    r0,r0,r3
;;;552      }
;;;553    
;;;554      AFIO->MAPR = tmpreg;
00004e  6060              STR      r0,[r4,#4]
;;;555    }
000050  bc70              POP      {r4-r6}
000052  4770              BX       lr
;;;556    
                          ENDP

                  |L8.84|
                          DCD      0x40010000

                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;271    *******************************************************************************/
;;;272    u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  6880              LDR      r0,[r0,#8]
;;;273    {
;;;274      /* Check the parameters */
;;;275      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;276      
;;;277      return ((u16)GPIOx->IDR);
000002  b280              UXTH     r0,r0
;;;278    }
000004  4770              BX       lr
;;;279    
                          ENDP


                          AREA ||i.GPIO_ReadInputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputDataBit PROC
;;;245    *******************************************************************************/
;;;246    u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  4602              MOV      r2,r0
;;;247    {
;;;248      u8 bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;249      
;;;250      /* Check the parameters */
;;;251      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;252      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;253      
;;;254      if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
000004  6892              LDR      r2,[r2,#8]
000006  420a              TST      r2,r1
;;;255      {
;;;256        bitstatus = (u8)Bit_SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;257      }
;;;258      else
;;;259      {
;;;260        bitstatus = (u8)Bit_RESET;
;;;261      }
;;;262      return bitstatus;
;;;263    }
00000c  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;314    *******************************************************************************/
;;;315    u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  68c0              LDR      r0,[r0,#0xc]
;;;316    {
;;;317      /* Check the parameters */
;;;318      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;319        
;;;320      return ((u16)GPIOx->ODR);
000002  b280              UXTH     r0,r0
;;;321    }
000004  4770              BX       lr
;;;322    
                          ENDP


                          AREA ||i.GPIO_ReadOutputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputDataBit PROC
;;;288    *******************************************************************************/
;;;289    u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  4602              MOV      r2,r0
;;;290    {
;;;291      u8 bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;292    
;;;293      /* Check the parameters */
;;;294      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;295      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;296      
;;;297      if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
000004  68d2              LDR      r2,[r2,#0xc]
000006  420a              TST      r2,r1
;;;298      {
;;;299        bitstatus = (u8)Bit_SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;300      }
;;;301      else
;;;302      {
;;;303        bitstatus = (u8)Bit_RESET;
;;;304      }
;;;305      return bitstatus;
;;;306    }
00000c  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;351    *******************************************************************************/
;;;352    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  6141              STR      r1,[r0,#0x14]
;;;353    {
;;;354      /* Check the parameters */
;;;355      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;356      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;357      
;;;358      GPIOx->BRR = GPIO_Pin;
;;;359    }
000002  4770              BX       lr
;;;360    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;332    *******************************************************************************/
;;;333    void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  6101              STR      r1,[r0,#0x10]
;;;334    {
;;;335      /* Check the parameters */
;;;336      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;337      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;338      
;;;339      GPIOx->BSRR = GPIO_Pin;
;;;340    }
000002  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.GPIO_StructInit||, CODE, READONLY, ALIGN=1

                  GPIO_StructInit PROC
;;;228    *******************************************************************************/
;;;229    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;230    {
;;;231      /* Reset GPIO init structure parameters values */
;;;232      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
000004  8001              STRH     r1,[r0,#0]
;;;233      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
000006  2102              MOVS     r1,#2
000008  7081              STRB     r1,[r0,#2]
;;;234      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
00000a  2104              MOVS     r1,#4
00000c  70c1              STRB     r1,[r0,#3]
;;;235    }
00000e  4770              BX       lr
;;;236    
                          ENDP


                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;399    *******************************************************************************/
;;;400    void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
000000  60c1              STR      r1,[r0,#0xc]
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;404      
;;;405      GPIOx->ODR = PortVal;
;;;406    }
000002  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;373    *******************************************************************************/
;;;374    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
000000  2a00              CMP      r2,#0
;;;375    {
;;;376      /* Check the parameters */
;;;377      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;378      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;379      assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
;;;380      
;;;381      if (BitVal != Bit_RESET)
;;;382      {
;;;383        GPIOx->BSRR = GPIO_Pin;
000002  bf14              ITE      NE
000004  6101              STRNE    r1,[r0,#0x10]
;;;384      }
;;;385      else
;;;386      {
;;;387        GPIOx->BRR = GPIO_Pin;
000006  6141              STREQ    r1,[r0,#0x14]
;;;388      }
;;;389    }
000008  4770              BX       lr
;;;390    
                          ENDP

